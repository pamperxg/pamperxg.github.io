---
title: 排序算法
date: 2018-08-17 15:28:22
tags: [coding,Java,Python,排序算法]
---

​	在Java中，待排序的元素需要实现Comparable接口，该接口中有compareTo方法，可以用来判断两个元素的大小关系。排序算法的成本主要是比较和交换的次数，一个排序算法可以定义为如下形式：

```java
public abstract class Sort<T extends Comparable>{
    public abstract void sort(T[] obs);
    protected boolean less(T a,T b){return a.compareTo(b)<0;};
    protected void swap(T[] obs,int i,int j){
        T tmp = obs[i];
        obs[j] = obs[i];
        obs[i] = tmp;
    }
}
```



<!--more-->

#### 选择排序

**基本思想**：选择数组中最小的元素，与数组的第一个元素交换位置。后续每第n步都选择剩余数组中最小的元素与第n个元素交换位置。每一步排好一个数。

无论输入如何，都会进行同样的比较和交换，运行时间和输入无关。

Java:

```
TODO
```

Python:

```
TODO
```



---

#### 冒泡排序

**基本思想**：从左到右不断交换相邻逆序的元素，一轮循环后可以将最大元素上浮至右侧。

如果一轮循环中没有发生交换，则数组有序，退出循环。

Java:

```
TODO
```

Python:

```
TODO
```



---

#### 插入排序

**基本思想**：每次将元素插入到左侧已经排序的数组中，使得左侧数组依然有序。

每一次只交换相邻元素，只能使逆序减少1，因此逆序越少（本身已部分有序）的数组插入排序越快。大规模数组插入排序非常慢。

Java:

```
TODO
```

Python:

```
TODO
```



---

#### 希尔排序

**基本思想**：改进插入排序每次只能使逆序减少1的局限性，通过交换不相邻元素，使得每一步减少的逆序数量大于1。

Java:

```
TODO
```

Python:

```
TODO
```



---

#### 归并排序

**基本思想**：将序列拆分为排序好的两个子序列，然后归并起来，经典的分治思想。

**归并**：将两个已经有序的子序列合并成一个有序序列。i，j分别为两个子序列的起始指针位置，从起始位置开始比较i ，j元素的大小。复制一份当前整个序列作为辅助序列，比较两个子序列i，j位置的元素，较小的存入最终结果序列。当其中一个子序列指针移到末尾，将另一个子序列的剩余元素放入结果序列末尾。详情见下Java代码。

归并排序是稳定的排序，最好最坏的时间复杂度都为O(nlogn)。

Java:

```java
import java.util.Arrays;
public class MergeSort<T[] extends Comparable<T>>{
    T[] tmp;
    public void sort(T[] nums){
        tmp = (T[]) new Comparable[nums.length];
        sort(nums,0,nums.length-1)
    }
    private void sort(T[] nums,int l,int h){
        if(h<=l)
            return;
        int mid = l + (h - l) / 2;
        sort(nums,l,mid);
        sort(nums,mid+1,h);
        merge(nums,l,mid,h);
    }
    private void merge(int[] nums,int l,int m,int h){
        int i = l,j = m + 1;
        for(int k=l;k<=h;k++)
            tmp[k] = nums[k];
        for(int k=l;k<=h;k++){
            if(i > m)
                nums[k] = tmp[j++];
            else if(j > h)
                nums[k] = tmp[i++];
            else if(tmp[i].compareTo(nums[j])<0)
                nums[k] = tmp[i++];
            else
                nums[k] = tmp[j++];
        }
    }
    public static void main(String[] args){
        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};
        MergeSort ms = new MergeSort();
        ms.sort();
        System.out.println(Arrays.toString(nums));
    }
}
//输出：[1, 2, 3, 4, 5, 6, 7, 8]
```

Python:

```python
class MergeSort(object):
    def __init__(self):
        pass
    def merge_sort(self,lists):
        if len(lists) <= 1:
            return lists
        mid = int(len(lists)/2)
        left = self.merge_sort(lists[:mid])
        right = self.merge_sort(lists[mid:])
        return merge(left,right)
    def merge(self,left,right):
        i,j = 0,0
        result = []
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result += left[i:]
        result += right[j:]
        return result
if __name__ == "__main__":
    lists = [6,5,8,7,1,4,2,3]
    ms = MergeSort()
    result = ms.sort(lists)
    print(result)
#输出：[1, 2, 3, 4, 5, 6, 7, 8]
```

自顶向下：

自底向上：



---

#### 快速排序

**基本思想**：通过一个切分元素把数组分为两个子数组，左边子数组小于等于切分元素，右边子数组大于等于切分元素。将两个子数组排序则整体有序了。

**切分元素**：选定位置，如：数组第一个元素，作为切分元素。指针i从左往右寻找第一个大于它的元素，指针j从右往左寻找第一个小于它的元素，交换这两个元素。不断进行该过程，指针i左边的元素都不大于切分元素，指针j右边的元素都大于切分元素，当i==j时，将切分元素交换到j位置。

快速排序是原地排序，不需要额外的辅助数组（但是递归调用需要辅助栈）。最好情况：每次都将数组对半分，O(nlogn)。最坏情况：数组本来就是有序的，O(n^2^)。所以为了防止这种最坏的情况出现，排序前先把数组shuffle一下。

Java:

```
TODO
```

Python:

```
TODO
```



---

#### 堆排序

**基本思想**：

Java:

```
TODO
```

Python:

```
TODO
```









