---
title: 排序算法
date: 2018-08-17 15:28:22
tags: [coding,Java,Python,排序算法]
---

​	在Java中，待排序的元素需要实现Comparable接口，该接口中有compareTo方法，可以用来判断两个元素的大小关系。排序算法的成本主要是比较和交换的次数，一个排序算法可以定义为如下形式：

```java
public abstract class Sort<T extends Comparable>{
    public abstract void sort(T[] obs);
    protected boolean less(T a,T b){return a.compareTo(b)<0;};
    protected void swap(T[] obs,int i,int j){
        T tmp = obs[i];
        obs[j] = obs[i];
        obs[i] = tmp;
    }
}
```



<!--more-->

#### 选择排序

---



#### 冒泡排序

---



#### 插入排序

---



#### 希尔排序

---





#### 归并排序

**基本思想**：将序列拆分为排序好的两个子序列，然后归并起来，经典的分治思想。

**归并**：将两个已经有序的子序列合并成一个有序序列。i，j分别为两个子序列的起始指针位置，从起始位置开始比较i ，j元素的大小。复制一份当前整个序列作为辅助序列，比较两个子序列i，j位置的元素，较小的存入最终结果序列。当其中一个子序列指针移到末尾，将另一个子序列的剩余元素放入结果序列末尾。详情见下Java代码。

归并排序是稳定的排序，最好最坏的时间复杂度都为O(nlogn)。

Java:

```java
import java.util.Arrays;
public class MergeSort<T[] extends Comparable<T>>{
    T[] tmp;
    public void sort(T[] nums){
        tmp = (T[]) new Comparable[nums.length];
        sort(nums,0,nums.length-1)
    }
    private void sort(T[] nums,int l,int h){
        if(h<=l)
            return;
        int mid = l + (h - l) / 2;
        sort(nums,l,mid);
        sort(nums,mid+1,h);
        merge(nums,l,mid,h);
    }
    private void merge(int[] nums,int l,int m,int h){
        int i = l,j = m + 1;
        for(int k=l;k<=h;k++)
            tmp[k] = nums[k];
        for(int k=l;k<=h;k++){
            if(i > m)
                nums[k] = tmp[j++];
            else if(j > h)
                nums[k] = tmp[i++];
            else if(tmp[i].compareTo(nums[j])<0)
                nums[k] = tmp[i++];
            else
                nums[k] = tmp[j++];
        }
    }
    public static void main(String[] args){
        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};
        MergeSort ms = new MergeSort();
        ms.sort();
        System.out.println(Arrays.toString(nums));
    }
}
//输出：[1, 2, 3, 4, 5, 6, 7, 8]
```

Python:

```python
class MergeSort(object):
    def __init__(self):
        pass
    def merge_sort(self,lists):
        if len(lists) <= 1:
            return lists
        mid = int(len(lists)/2)
        left = self.merge_sort(lists[:mid])
        right = self.merge_sort(lists[mid:])
        return merge(left,right)
    def merge(self,left,right):
        i,j = 0,0
        result = []
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        result += left[i:]
        result += right[j:]
        return result
if __name__ == "__main__":
    lists = [6,5,8,7,1,4,2,3]
    ms = MergeSort()
    result = ms.sort(lists)
    print(result)
#输出：[1, 2, 3, 4, 5, 6, 7, 8]
```

---



#### 快速排序











