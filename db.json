{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia2/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"source/assets/riven.png","path":"assets/riven.png","modified":1,"renderable":0},{"_id":"themes/yilia2/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/riven.png","path":"riven.png","modified":1,"renderable":1},{"_id":"source/assets/BP.jpg","path":"assets/BP.jpg","modified":1,"renderable":0},{"_id":"themes/yilia2/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia2/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"source/assets/GMM.png","path":"assets/GMM.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia2/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1538064893620},{"_id":"themes/yilia2/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1538064893620},{"_id":"themes/yilia2/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1538064893620},{"_id":"themes/yilia2/_config.yml","hash":"3c105d9bd20d85c3a10de75a6aaaaf2d6b2918b8","modified":1538064893620},{"_id":"themes/yilia2/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1538064893620},{"_id":"themes/yilia2/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1538064893620},{"_id":"source/_posts/BigData.md","hash":"18baa07882b628374ebf3b8b933e54acd1c48b8f","modified":1538589144002},{"_id":"themes/yilia2/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1533215557621},{"_id":"source/_posts/ML&DL基础概念.md","hash":"32534d30db926803ab8a6661c1ef69ad1b94c794","modified":1538932063267},{"_id":"source/_posts/protocol.md","hash":"5792a8953c538418f40b02c038444927621daddf","modified":1565535358039},{"_id":"themes/yilia2/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1533215557647},{"_id":"source/_posts/Hexo+GithubPages搭建博客.md","hash":"d8abbc2a6ad5a10205084e7d9c49296993e1a8d4","modified":1562510713632},{"_id":"source/_posts/面试总结.md","hash":"a33f52e1c61ac1c742ab5ae3e993fedff66920ca","modified":1539104006694},{"_id":"source/_posts/排序算法.md","hash":"1ad85635cc150f7e464793a8a9ed016ca3786e03","modified":1538064893620},{"_id":"source/_posts/Java-Python.md","hash":"5c5c8a25a601907f7bbf06933b756f0e8c31ac17","modified":1562510713636},{"_id":"source/draft/JVM.md","hash":"35e1d2b0e20d92c811a5d654852e0547b5436c69","modified":1538064893615},{"_id":"source/_posts/刷题总结DayANight.md","hash":"5ae8bfc781d3fc2a5cdfa96553eb1619ad5cc1fa","modified":1564673619853},{"_id":"themes/yilia2/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1533215557608},{"_id":"themes/yilia2/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1533215557608},{"_id":"themes/yilia2/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1533215557608},{"_id":"themes/yilia2/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1533215557609},{"_id":"themes/yilia2/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1533215557609},{"_id":"themes/yilia2/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1533215557609},{"_id":"themes/yilia2/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1533215557610},{"_id":"themes/yilia2/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1533215557620},{"_id":"themes/yilia2/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1533215557620},{"_id":"themes/yilia2/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1533215557620},{"_id":"themes/yilia2/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1533215557620},{"_id":"themes/yilia2/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1533215557620},{"_id":"themes/yilia2/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1533215557620},{"_id":"themes/yilia2/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1533215557621},{"_id":"themes/yilia2/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1533215557621},{"_id":"source/draft/LeetCode.md","hash":"32b2fe9caf8a15fb9b36001667d68866ad8a34ca","modified":1538410667252},{"_id":"themes/yilia2/source/main.0cf68a.css","hash":"df40f927f7845f20f97ae0eebd9c8ef7f8813c66","modified":1538064893624},{"_id":"source/assets/riven.png","hash":"9564bc357133b3c562ffe80a4c2f51610b2f137b","modified":1533221758581},{"_id":"themes/yilia2/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1533215557647},{"_id":"themes/yilia2/source/riven.png","hash":"9564bc357133b3c562ffe80a4c2f51610b2f137b","modified":1533215557646},{"_id":"source/assets/BP.jpg","hash":"bfdc69dc583e188bf6c1e55c23922659f232ff62","modified":1538669408137},{"_id":"themes/yilia2/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1533215557619},{"_id":"themes/yilia2/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1533215557645},{"_id":"themes/yilia2/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1533215557610},{"_id":"themes/yilia2/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1533215557611},{"_id":"themes/yilia2/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1533215557611},{"_id":"themes/yilia2/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1533215557639},{"_id":"themes/yilia2/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1533215557612},{"_id":"themes/yilia2/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1533215557612},{"_id":"themes/yilia2/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1533215557612},{"_id":"themes/yilia2/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1533215557613},{"_id":"themes/yilia2/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1533215557613},{"_id":"themes/yilia2/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1533215557613},{"_id":"themes/yilia2/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1533215557614},{"_id":"source/_posts/carryC.md","hash":"c3fa59e1e391370e328e11984de38d57b30322a3","modified":1563290951547},{"_id":"themes/yilia2/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1533215557614},{"_id":"themes/yilia2/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1533215557614},{"_id":"themes/yilia2/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1533215557614},{"_id":"themes/yilia2/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1533215557622},{"_id":"themes/yilia2/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1533215557619},{"_id":"themes/yilia2/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1533215557622},{"_id":"themes/yilia2/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1533215557622},{"_id":"themes/yilia2/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1533215557623},{"_id":"themes/yilia2/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1533215557623},{"_id":"themes/yilia2/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1533215557624},{"_id":"themes/yilia2/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1533215557624},{"_id":"themes/yilia2/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1533215557624},{"_id":"themes/yilia2/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1533215557626},{"_id":"themes/yilia2/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1533215557629},{"_id":"themes/yilia2/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1533215557629},{"_id":"themes/yilia2/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1533215557629},{"_id":"themes/yilia2/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1533215557629},{"_id":"themes/yilia2/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1533215557631},{"_id":"themes/yilia2/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1533215557631},{"_id":"themes/yilia2/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1533215557632},{"_id":"themes/yilia2/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1533215557619},{"_id":"themes/yilia2/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1533215557632},{"_id":"themes/yilia2/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1533215557611},{"_id":"themes/yilia2/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1533215557632},{"_id":"themes/yilia2/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1533215557623},{"_id":"themes/yilia2/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1533215557633},{"_id":"themes/yilia2/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1533215557633},{"_id":"themes/yilia2/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1533215557633},{"_id":"themes/yilia2/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1533215557634},{"_id":"themes/yilia2/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1533215557634},{"_id":"themes/yilia2/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1533215557634},{"_id":"themes/yilia2/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1533215557632},{"_id":"themes/yilia2/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1533215557634},{"_id":"themes/yilia2/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1533215557635},{"_id":"themes/yilia2/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1533215557636},{"_id":"themes/yilia2/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1533215557637},{"_id":"themes/yilia2/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1533215557636},{"_id":"themes/yilia2/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1533215557636},{"_id":"themes/yilia2/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1533215557636},{"_id":"themes/yilia2/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1533215557637},{"_id":"themes/yilia2/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1533215557638},{"_id":"themes/yilia2/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1533215557638},{"_id":"themes/yilia2/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1533215557638},{"_id":"themes/yilia2/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1533215557638},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1533215557641},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1533215557641},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1533215557640},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1533215557642},{"_id":"themes/yilia2/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1533215557643},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1533215557642},{"_id":"themes/yilia2/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1533215557639},{"_id":"themes/yilia2/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1533215557618},{"_id":"themes/yilia2/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1533215557646},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1533215557642},{"_id":"themes/yilia2/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1533215557615},{"_id":"themes/yilia2/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1533215557615},{"_id":"themes/yilia2/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1533215557615},{"_id":"themes/yilia2/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1533215557616},{"_id":"themes/yilia2/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1533215557616},{"_id":"themes/yilia2/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1533215557616},{"_id":"themes/yilia2/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1533215557617},{"_id":"themes/yilia2/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1533215557617},{"_id":"themes/yilia2/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1533215557617},{"_id":"themes/yilia2/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1533215557618},{"_id":"themes/yilia2/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1533215557625},{"_id":"themes/yilia2/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1533215557625},{"_id":"themes/yilia2/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1533215557626},{"_id":"themes/yilia2/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1533215557626},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1533215557643},{"_id":"themes/yilia2/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1533215557643},{"_id":"themes/yilia2/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1533215557625},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1533215557627},{"_id":"themes/yilia2/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1533215557630},{"_id":"themes/yilia2/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1533215557630},{"_id":"themes/yilia2/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1533215557631},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1533215557628},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1533215557628},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1533215557627},{"_id":"source/assets/GMM.png","hash":"b74e52368b4d5da72277d95cf94e21a1d2aa357c","modified":1538843509546},{"_id":"public/content.json","hash":"34802a6dee4fc67d26931734f09d5d42b40aa748","modified":1565535412661},{"_id":"public/draft/LeetCode.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1565535412889},{"_id":"public/draft/JVM.html","hash":"ed933492ce45feed3d678ee0d2b007661454c6a5","modified":1565535412889},{"_id":"public/2019/07/31/protocol/index.html","hash":"ee93d6fa316b3cb35ebe524c1843ca68dbee87d1","modified":1565535412889},{"_id":"public/2019/07/07/carryC/index.html","hash":"10ad43a18dcde117415c2f0259b5471a8f667fb9","modified":1565535412889},{"_id":"public/2018/09/19/面试总结/index.html","hash":"b4766f8970de76f92ce474e0bc23c886be2128b0","modified":1565535412889},{"_id":"public/2018/08/25/ML&DL基础概念/index.html","hash":"3ec0673e60a895f22a545a49eac39fabe36ee61d","modified":1565535412889},{"_id":"public/2018/08/31/刷题总结DayANight/index.html","hash":"bfefeb5b8dd5ec42753d97ef0cbab841db42be70","modified":1565535412889},{"_id":"public/2018/08/25/BigData/index.html","hash":"c8b17e73a2dd926e3ce05c89ec5c2d6fd0752f0e","modified":1565535412890},{"_id":"public/2018/08/20/Java-Python/index.html","hash":"92d6868c92803859deb0d94434b887ce085d24ac","modified":1565535412890},{"_id":"public/2018/08/17/排序算法/index.html","hash":"b5636a66f66b74c108ea130da002bbf5cad5e425","modified":1565535412890},{"_id":"public/2018/08/02/Hexo+GithubPages搭建博客/index.html","hash":"fcdd50d766882222a8c0c4f9196841f7abe1a59b","modified":1565535412890},{"_id":"public/archives/index.html","hash":"315740f1c8e5e5014ee39a75f6295648c3b0345f","modified":1565535412890},{"_id":"public/archives/page/2/index.html","hash":"e280507551061718c6576fad9367fba60706c9ae","modified":1565535412890},{"_id":"public/archives/2018/index.html","hash":"19f3e969fc2f52a3696fd900c7e2b2cfad058076","modified":1565535412890},{"_id":"public/archives/2018/page/2/index.html","hash":"78b5487bcb7cc3ccd4e7dd5a4eff5aa869ce14f6","modified":1565535412891},{"_id":"public/archives/2018/08/index.html","hash":"586b57fa5835a5f7ba29dccd3c05e8e4c6f59edf","modified":1565535412891},{"_id":"public/archives/2018/08/page/2/index.html","hash":"409f5085e3541a3b886bcffc2b11a6e8a9c3a0ac","modified":1565535412891},{"_id":"public/archives/2018/09/index.html","hash":"2337fdc2bb7bcfd1b4d0c319a987cc80ab529a43","modified":1565535412891},{"_id":"public/archives/2019/index.html","hash":"ca90b3d8f4b8a2e3022edaa22cff242bcd2b96f3","modified":1565535412891},{"_id":"public/index.html","hash":"5c53affb5b0679ef88d5524967b1112a3242cbc6","modified":1565535412892},{"_id":"public/archives/2019/07/index.html","hash":"92b69fed72e77a4781e9643727caed8d6d5732ac","modified":1565535412893},{"_id":"public/page/2/index.html","hash":"34c39d879d5aa140868362987d5d492a6fe58008","modified":1565535412893},{"_id":"public/tags/notes/index.html","hash":"50dddf8f9f0c4a680571eb2a522b8bd92ea9b56b","modified":1565535412893},{"_id":"public/tags/notes/page/2/index.html","hash":"268c562ab3b59793c18ad9063122c6eb2746a6c4","modified":1565535412893},{"_id":"public/tags/大数据/index.html","hash":"f268911196dbf32bca15e1b78da56788a7242cb1","modified":1565535412893},{"_id":"public/tags//index.html","hash":"7fcb7aa3fec93cd216d0306cb06445377b85354a","modified":1565535412893},{"_id":"public/tags/Github-Pages/index.html","hash":"5bb9be9781d88387d08a7cf886a1ef0c99ea539e","modified":1565535412893},{"_id":"public/tags/Hexo/index.html","hash":"d81e02dd4201c0d1b328d27ef5d9e014ce87ed89","modified":1565535412894},{"_id":"public/tags/面试总结/index.html","hash":"c292cfda3631a63573f61aab8787d79604611f11","modified":1565535412894},{"_id":"public/tags/coding/index.html","hash":"b877bddfbc8ae35893f8a053a9e7383b72148eb3","modified":1565535412894},{"_id":"public/tags/Java/index.html","hash":"5a889acd4e0d48cda6899f3933bf6b9ea2b132b6","modified":1565535412894},{"_id":"public/tags/Python/index.html","hash":"43bc3083d2a3e5ba61fc01db620e5d3822b4ae00","modified":1565535412894},{"_id":"public/tags/排序算法/index.html","hash":"fb80a3cb7e9081fd225e62a26d7d142cfab2282b","modified":1565535412894},{"_id":"public/tags/SQL/index.html","hash":"e2f0df4ffff06f5314669801542aa9b652aebd6d","modified":1565535412894},{"_id":"public/tags/Shell/index.html","hash":"e9da4aa126e9198805dc76b21527d8046ce325bb","modified":1565535412894},{"_id":"public/tags/语言基础知识/index.html","hash":"4e2c38137b6291e8007b6c6d2f3b031e116907df","modified":1565535412895},{"_id":"public/tags/DataScience/index.html","hash":"25a8eb34340f51b7f90bdb135d62941f4b146ab9","modified":1565535412895},{"_id":"public/tags/MachineLearning/index.html","hash":"3e36299f65ab503d7120a7164c36a035f10093a6","modified":1565535412895},{"_id":"public/tags/DeepLearning/index.html","hash":"b5b37025b91802d2aa7c4929926914ca7bfa3c7c","modified":1565535412895},{"_id":"public/assets/riven.png","hash":"9564bc357133b3c562ffe80a4c2f51610b2f137b","modified":1565535412901},{"_id":"public/riven.png","hash":"9564bc357133b3c562ffe80a4c2f51610b2f137b","modified":1565535412901},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1565535412902},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1565535412902},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1565535412902},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1565535412902},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1565535412903},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1565535412903},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1565535412903},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1565535412903},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1565535412903},{"_id":"public/assets/BP.jpg","hash":"bfdc69dc583e188bf6c1e55c23922659f232ff62","modified":1565535412909},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1565535412927},{"_id":"public/main.0cf68a.css","hash":"60910467cac30a06e183ac936e8b887fb3aecad4","modified":1565535412929},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1565535412930},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1565535412934},{"_id":"public/assets/GMM.png","hash":"b74e52368b4d5da72277d95cf94e21a1d2aa357c","modified":1565535412935}],"Category":[],"Data":[],"Page":[{"title":"JVM","date":"2018-09-10T07:29:22.000Z","tags":null,"_content":"","source":"draft/JVM.md","raw":"---\ntitle: JVM\ndate: 2018-09-10 15:29:22\ntags:\n---\n","updated":"2018-09-27T16:14:53.615Z","path":"draft/JVM.html","comments":1,"layout":"page","_id":"cjz73d2qu0006qseze3hhmlns","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"LeetCode","date":"2018-08-23T14:23:30.000Z","tags":["coding","Java","LeetCode"],"_content":"\n。。。\n\n<!--more-->\n\n#### 双指针\n\n```java\n//input sorted array 167\npublic int[] twoSum(int[] nums,int target){\n    int i = 0,j = nums.length - 1;\n    while (i <= j) {\n        int sum = nums[i] + nums[j];\n        if (sum == target)\n            return new int[]{i+1,j+1};\n        else if (sum < target)\n            i++;\n        else\n            j--;\n    }\n    return null;\n}\n```\n\n```java\n//sum of square numbers  633\npublic boolean judgeSquareSum(int c){\n    int i = 0,j = (int) Math.sqrt(c);\n    while (i <= j) {\n        int squareSum = i*i + j*j;\n        if (squareSum == c)\n            return true;\n        else if (squareSum < c)\n            i++;\n        else\n            j--;\n    }\n    return false;\n}\n```\n\n```java\n//vowels  345\nprivate static final HashSet<Character> vowels = new HashSet<>(Arrays.asList('a','e','i','o','u','A','E','I','O','U'));\npublic String reverseVowels(String s){\n    int i = 0,j = s.length() - 1;\n    char[] result = new char[s.length()];\n    while(i <= j){\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci))\n            result[i++] = ci;\n        else if (!vowels.contains(cj))\n            result[j--] = cj;\n        else{\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}\n```\n\n```java\n//valid palindrome delete 1char 680\npublic boolean validPalindrome(String s){\n    int i = -1,j = s.length();\n    while (++i < --j){\n        if (s.charAt(i) != s.charAt(j)){\n            return isPalidrome(s,i,j-1) || isPalidrome(s,i+1,j);\n        }\n    }\n}\nprivate boolean isPalidrome(String s,int i,int j){\n    while (i < j){\n        if (s.charAt(i++) != s.charAt(j--))\n            return false;\n    }\n    return true;\n}\n```\n\n```java\n//merge sorted array  88\npublic void merge(int[] nums1,int m,int[] nums2,int n){\n    int index1 = m - 1,index2 = n - 1;\n    int mergedIndex = m + n - 1;\n    while (index1 >= 0 || index2 >= 0){\n        if (index1 < 0)\n            nums1[mergedIndex--] = nums2[index2--];\n        else if (index2 < 0)\n            nums1[mergedIndex--] - nums1[index1--];\n        else if (nums1[index1] > nums2[index2])\n            nums1[mergedIndex--] = nums1[index1--];\n        else\n            nums1[mergedIndex--] = nums2[index2--];\n    }\n}\n```\n\n```java\n//linked list cycle  141\npublic boolean hasCycle(listNode head){\n    if (head == null)\n        return false;\n    listNode l1 = head,l2 = head.next;\n    while (l1 != null && l2 != null && l2.next != null){\n        if (l1 == l2)\n            return true;\n        l1 = l1.next;\n        l2 = l1.next.next;\n    }\n    return false;\n}\n```\n\n```java\n//最长子序列  524\npublic String findLongestWord(String s,List<String> d){\n    String longestWord = \"\";\n    for(String target:d){\n        int l1 = longestWord.length(),l2 = target.length();\n        if(l1 > l2 || (l1 == l2 && longestWord.compareTo(target) < 0))\n            continue;\n        if(isValid(s,target))\n            longestWord = target;\n    }\n    return longestWord;\n}\nprivate boolean isValid(String s,String target){\n    int i = 0,j = 0;\n    while(i < s.length() && j < target.length()){\n        if(s.charAt(i) == target.charAt(j))\n            j++;\n        i++;\n    }\n    return j == target;\n}\n```\n\n#### 排序\n\nKth Element问题，使用quicksort的partition函数实现，需先打乱数组\n\nTopK Elements问题，堆排序求解\n\n出现频率最多的K个数，桶排序\n\n三向切分排\n\n```java\npublic class ThreeWaySort{\n    public void sortThreeWay(int[] nums){\n        int zero = -1,one = 0,two = nums.length;\n        while(one < two){\n            if(nums[one] == 0)\n                swap(nums,++zero,one++);\n            else if(nums[one] == 2)\n                swap(nums,one,--two);\n            else \n                ++one;\n        }\n    }\n    private void swap(int[] nums,int i,int j){\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n\n\n#### 贪心思想\n\n```java\n//删除重叠区间个数\npublic class Interval{\n    int start;\n    int end;\n    Interval(){start = 0;end = 0};\n    Interval(int s,int e){\n        this.start = s;\n        this.end = e;\n    }\n}\npublic class EraseIntervals{\n    public int eraseIntervals(Interval[] intervals){\n        if(intervals.length == 0 || intervals == null)\n            return 0;\n        Arrays.sort(intervals,new Comparator<Interval>(){\n            @Override\n            public int compare(Interval o1,Interval o2){\n                return o1.end - o2.end;\n            }\n        });\n        //Arrays.sort(intervals,Comparator.comparingInt(o -> o.end));\n        int cnt = 1;\n        int end = intervals[0].end;\n        for(int i=1;i<intervals.length;i++){\n            if(intervals[i].start<end)\n                continue;\n            cnt++;\n            end = intervals[i].end;\n        }\n        return intervals.length - cnt;\n    }\n}\n```\n\n#### 二分\n\n```java\npublic int BinarySearch(int[] nums,int target){\n    int l = 0,h = nums.length - 1;\n    while(l <= h){\n        int mid = l + (h - l) / 2; \n        if(nums[mid] == target)\n            return mid;\n        else if(nums[mid] < target)\n            l = mid + 1;\n        else\n            h = mid - 1;\n    }\n    return -1;\n}\n```\n\n```java\n//sqrt(x)\npublic class Sqrt{\n    public int sqrt(int x){\n        if(x <= 1)\n            return x;\n        int l = 1,h = x;\n        while(l <= h){\n            int mid = l + (h-l)/2;\n            int sqrt = x/mid;\n            if(sqrt == mid)\n                return mid;\n            else if(mid > sqrt)\n                h = mid - 1;\n            else\n                l = mid + 1;\n        }\n        return h;   //循环中值后l比h大\n    }\n}\n```\n\n#### 搜索\n\n```java\n//bfs\n\n```\n\n","source":"draft/LeetCode.md","raw":"---\ntitle: LeetCode\ndate: 2018-08-23 22:23:30\ntags: [coding,Java,LeetCode]\n---\n\n。。。\n\n<!--more-->\n\n#### 双指针\n\n```java\n//input sorted array 167\npublic int[] twoSum(int[] nums,int target){\n    int i = 0,j = nums.length - 1;\n    while (i <= j) {\n        int sum = nums[i] + nums[j];\n        if (sum == target)\n            return new int[]{i+1,j+1};\n        else if (sum < target)\n            i++;\n        else\n            j--;\n    }\n    return null;\n}\n```\n\n```java\n//sum of square numbers  633\npublic boolean judgeSquareSum(int c){\n    int i = 0,j = (int) Math.sqrt(c);\n    while (i <= j) {\n        int squareSum = i*i + j*j;\n        if (squareSum == c)\n            return true;\n        else if (squareSum < c)\n            i++;\n        else\n            j--;\n    }\n    return false;\n}\n```\n\n```java\n//vowels  345\nprivate static final HashSet<Character> vowels = new HashSet<>(Arrays.asList('a','e','i','o','u','A','E','I','O','U'));\npublic String reverseVowels(String s){\n    int i = 0,j = s.length() - 1;\n    char[] result = new char[s.length()];\n    while(i <= j){\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci))\n            result[i++] = ci;\n        else if (!vowels.contains(cj))\n            result[j--] = cj;\n        else{\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}\n```\n\n```java\n//valid palindrome delete 1char 680\npublic boolean validPalindrome(String s){\n    int i = -1,j = s.length();\n    while (++i < --j){\n        if (s.charAt(i) != s.charAt(j)){\n            return isPalidrome(s,i,j-1) || isPalidrome(s,i+1,j);\n        }\n    }\n}\nprivate boolean isPalidrome(String s,int i,int j){\n    while (i < j){\n        if (s.charAt(i++) != s.charAt(j--))\n            return false;\n    }\n    return true;\n}\n```\n\n```java\n//merge sorted array  88\npublic void merge(int[] nums1,int m,int[] nums2,int n){\n    int index1 = m - 1,index2 = n - 1;\n    int mergedIndex = m + n - 1;\n    while (index1 >= 0 || index2 >= 0){\n        if (index1 < 0)\n            nums1[mergedIndex--] = nums2[index2--];\n        else if (index2 < 0)\n            nums1[mergedIndex--] - nums1[index1--];\n        else if (nums1[index1] > nums2[index2])\n            nums1[mergedIndex--] = nums1[index1--];\n        else\n            nums1[mergedIndex--] = nums2[index2--];\n    }\n}\n```\n\n```java\n//linked list cycle  141\npublic boolean hasCycle(listNode head){\n    if (head == null)\n        return false;\n    listNode l1 = head,l2 = head.next;\n    while (l1 != null && l2 != null && l2.next != null){\n        if (l1 == l2)\n            return true;\n        l1 = l1.next;\n        l2 = l1.next.next;\n    }\n    return false;\n}\n```\n\n```java\n//最长子序列  524\npublic String findLongestWord(String s,List<String> d){\n    String longestWord = \"\";\n    for(String target:d){\n        int l1 = longestWord.length(),l2 = target.length();\n        if(l1 > l2 || (l1 == l2 && longestWord.compareTo(target) < 0))\n            continue;\n        if(isValid(s,target))\n            longestWord = target;\n    }\n    return longestWord;\n}\nprivate boolean isValid(String s,String target){\n    int i = 0,j = 0;\n    while(i < s.length() && j < target.length()){\n        if(s.charAt(i) == target.charAt(j))\n            j++;\n        i++;\n    }\n    return j == target;\n}\n```\n\n#### 排序\n\nKth Element问题，使用quicksort的partition函数实现，需先打乱数组\n\nTopK Elements问题，堆排序求解\n\n出现频率最多的K个数，桶排序\n\n三向切分排\n\n```java\npublic class ThreeWaySort{\n    public void sortThreeWay(int[] nums){\n        int zero = -1,one = 0,two = nums.length;\n        while(one < two){\n            if(nums[one] == 0)\n                swap(nums,++zero,one++);\n            else if(nums[one] == 2)\n                swap(nums,one,--two);\n            else \n                ++one;\n        }\n    }\n    private void swap(int[] nums,int i,int j){\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n\n\n\n#### 贪心思想\n\n```java\n//删除重叠区间个数\npublic class Interval{\n    int start;\n    int end;\n    Interval(){start = 0;end = 0};\n    Interval(int s,int e){\n        this.start = s;\n        this.end = e;\n    }\n}\npublic class EraseIntervals{\n    public int eraseIntervals(Interval[] intervals){\n        if(intervals.length == 0 || intervals == null)\n            return 0;\n        Arrays.sort(intervals,new Comparator<Interval>(){\n            @Override\n            public int compare(Interval o1,Interval o2){\n                return o1.end - o2.end;\n            }\n        });\n        //Arrays.sort(intervals,Comparator.comparingInt(o -> o.end));\n        int cnt = 1;\n        int end = intervals[0].end;\n        for(int i=1;i<intervals.length;i++){\n            if(intervals[i].start<end)\n                continue;\n            cnt++;\n            end = intervals[i].end;\n        }\n        return intervals.length - cnt;\n    }\n}\n```\n\n#### 二分\n\n```java\npublic int BinarySearch(int[] nums,int target){\n    int l = 0,h = nums.length - 1;\n    while(l <= h){\n        int mid = l + (h - l) / 2; \n        if(nums[mid] == target)\n            return mid;\n        else if(nums[mid] < target)\n            l = mid + 1;\n        else\n            h = mid - 1;\n    }\n    return -1;\n}\n```\n\n```java\n//sqrt(x)\npublic class Sqrt{\n    public int sqrt(int x){\n        if(x <= 1)\n            return x;\n        int l = 1,h = x;\n        while(l <= h){\n            int mid = l + (h-l)/2;\n            int sqrt = x/mid;\n            if(sqrt == mid)\n                return mid;\n            else if(mid > sqrt)\n                h = mid - 1;\n            else\n                l = mid + 1;\n        }\n        return h;   //循环中值后l比h大\n    }\n}\n```\n\n#### 搜索\n\n```java\n//bfs\n\n```\n\n","updated":"2018-10-01T16:17:47.252Z","path":"draft/LeetCode.html","comments":1,"layout":"page","_id":"cjz73d2ra000gqsezs7l84lwy","content":"<p>。。。</p>\n<a id=\"more\"></a>\n<h4 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//input sorted array 167</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = nums[i] + nums[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sum of square numbers  633</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">judgeSquareSum</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = (<span class=\"keyword\">int</span>) Math.sqrt(c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> squareSum = i*i + j*j;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (squareSum == c)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (squareSum &lt; c)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//vowels  345</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashSet&lt;Character&gt; vowels = <span class=\"keyword\">new</span> HashSet&lt;&gt;(Arrays.asList(<span class=\"string\">'a'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'i'</span>,<span class=\"string\">'o'</span>,<span class=\"string\">'u'</span>,<span class=\"string\">'A'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'I'</span>,<span class=\"string\">'O'</span>,<span class=\"string\">'U'</span>));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseVowels</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[s.length()];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ci = s.charAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> cj = s.charAt(j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vowels.contains(ci))</span><br><span class=\"line\">            result[i++] = ci;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!vowels.contains(cj))</span><br><span class=\"line\">            result[j--] = cj;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            result[i++] = cj;</span><br><span class=\"line\">            result[j--] = ci;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//valid palindrome delete 1char 680</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validPalindrome</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = -<span class=\"number\">1</span>,j = s.length();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++i &lt; --j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(j))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isPalidrome(s,i,j-<span class=\"number\">1</span>) || isPalidrome(s,i+<span class=\"number\">1</span>,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalidrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i++) != s.charAt(j--))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//merge sorted array  88</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span>[] nums2,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index1 = m - <span class=\"number\">1</span>,index2 = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mergedIndex = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (index1 &gt;= <span class=\"number\">0</span> || index2 &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index1 &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            nums1[mergedIndex--] = nums2[index2--];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index2 &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            nums1[mergedIndex--] - nums1[index1--];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[index1] &gt; nums2[index2])</span><br><span class=\"line\">            nums1[mergedIndex--] = nums1[index1--];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            nums1[mergedIndex--] = nums2[index2--];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//linked list cycle  141</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(listNode head)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    listNode l1 = head,l2 = head.next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l1 != <span class=\"keyword\">null</span> &amp;&amp; l2 != <span class=\"keyword\">null</span> &amp;&amp; l2.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == l2)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        l1 = l1.next;</span><br><span class=\"line\">        l2 = l1.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最长子序列  524</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">findLongestWord</span><span class=\"params\">(String s,List&lt;String&gt; d)</span></span>&#123;</span><br><span class=\"line\">    String longestWord = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(String target:d)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l1 = longestWord.length(),l2 = target.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class=\"number\">0</span>))</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isValid(s,target))</span><br><span class=\"line\">            longestWord = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> longestWord;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s,String target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(i) == target.charAt(j))</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> j == target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>Kth Element问题，使用quicksort的partition函数实现，需先打乱数组</p>\n<p>TopK Elements问题，堆排序求解</p>\n<p>出现频率最多的K个数，桶排序</p>\n<p>三向切分排</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreeWaySort</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortThreeWay</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> zero = -<span class=\"number\">1</span>,one = <span class=\"number\">0</span>,two = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(one &lt; two)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[one] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                swap(nums,++zero,one++);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[one] == <span class=\"number\">2</span>)</span><br><span class=\"line\">                swap(nums,one,--two);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">                ++one;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"贪心思想\"><a href=\"#贪心思想\" class=\"headerlink\" title=\"贪心思想\"></a>贪心思想</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除重叠区间个数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interval</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    Interval()&#123;start = <span class=\"number\">0</span>;end = <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    Interval(<span class=\"keyword\">int</span> s,<span class=\"keyword\">int</span> e)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = s;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EraseIntervals</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">eraseIntervals</span><span class=\"params\">(Interval[] intervals)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.length == <span class=\"number\">0</span> || intervals == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Arrays.sort(intervals,<span class=\"keyword\">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Interval o1,Interval o2)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.end - o2.end;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o.end));</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = intervals[<span class=\"number\">0</span>].end;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i].start&lt;end)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            end = intervals[i].end;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intervals.length - cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">BinarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>,h = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt;= h)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = l + (h - l) / <span class=\"number\">2</span>; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid] == target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &lt; target)</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            h = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sqrt(x)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sqrt</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sqrt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>,h = x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= h)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = l + (h-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sqrt = x/mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sqrt == mid)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid &gt; sqrt)</span><br><span class=\"line\">                h = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;   <span class=\"comment\">//循环中值后l比h大</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//bfs</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>。。。</p>","more":"<h4 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//input sorted array 167</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = nums[i] + nums[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; target)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sum of square numbers  633</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">judgeSquareSum</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = (<span class=\"keyword\">int</span>) Math.sqrt(c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> squareSum = i*i + j*j;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (squareSum == c)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (squareSum &lt; c)</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//vowels  345</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashSet&lt;Character&gt; vowels = <span class=\"keyword\">new</span> HashSet&lt;&gt;(Arrays.asList(<span class=\"string\">'a'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'i'</span>,<span class=\"string\">'o'</span>,<span class=\"string\">'u'</span>,<span class=\"string\">'A'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'I'</span>,<span class=\"string\">'O'</span>,<span class=\"string\">'U'</span>));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseVowels</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[s.length()];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ci = s.charAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> cj = s.charAt(j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vowels.contains(ci))</span><br><span class=\"line\">            result[i++] = ci;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!vowels.contains(cj))</span><br><span class=\"line\">            result[j--] = cj;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            result[i++] = cj;</span><br><span class=\"line\">            result[j--] = ci;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//valid palindrome delete 1char 680</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validPalindrome</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = -<span class=\"number\">1</span>,j = s.length();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++i &lt; --j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(j))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isPalidrome(s,i,j-<span class=\"number\">1</span>) || isPalidrome(s,i+<span class=\"number\">1</span>,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalidrome</span><span class=\"params\">(String s,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i++) != s.charAt(j--))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//merge sorted array  88</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span>[] nums2,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index1 = m - <span class=\"number\">1</span>,index2 = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mergedIndex = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (index1 &gt;= <span class=\"number\">0</span> || index2 &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index1 &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            nums1[mergedIndex--] = nums2[index2--];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index2 &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            nums1[mergedIndex--] - nums1[index1--];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[index1] &gt; nums2[index2])</span><br><span class=\"line\">            nums1[mergedIndex--] = nums1[index1--];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            nums1[mergedIndex--] = nums2[index2--];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//linked list cycle  141</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(listNode head)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    listNode l1 = head,l2 = head.next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l1 != <span class=\"keyword\">null</span> &amp;&amp; l2 != <span class=\"keyword\">null</span> &amp;&amp; l2.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == l2)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        l1 = l1.next;</span><br><span class=\"line\">        l2 = l1.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最长子序列  524</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">findLongestWord</span><span class=\"params\">(String s,List&lt;String&gt; d)</span></span>&#123;</span><br><span class=\"line\">    String longestWord = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(String target:d)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l1 = longestWord.length(),l2 = target.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class=\"number\">0</span>))</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isValid(s,target))</span><br><span class=\"line\">            longestWord = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> longestWord;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s,String target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(i) == target.charAt(j))</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> j == target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>Kth Element问题，使用quicksort的partition函数实现，需先打乱数组</p>\n<p>TopK Elements问题，堆排序求解</p>\n<p>出现频率最多的K个数，桶排序</p>\n<p>三向切分排</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreeWaySort</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortThreeWay</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> zero = -<span class=\"number\">1</span>,one = <span class=\"number\">0</span>,two = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(one &lt; two)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[one] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                swap(nums,++zero,one++);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[one] == <span class=\"number\">2</span>)</span><br><span class=\"line\">                swap(nums,one,--two);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">                ++one;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"贪心思想\"><a href=\"#贪心思想\" class=\"headerlink\" title=\"贪心思想\"></a>贪心思想</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除重叠区间个数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interval</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    Interval()&#123;start = <span class=\"number\">0</span>;end = <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    Interval(<span class=\"keyword\">int</span> s,<span class=\"keyword\">int</span> e)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = s;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EraseIntervals</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">eraseIntervals</span><span class=\"params\">(Interval[] intervals)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.length == <span class=\"number\">0</span> || intervals == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Arrays.sort(intervals,<span class=\"keyword\">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Interval o1,Interval o2)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.end - o2.end;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//Arrays.sort(intervals,Comparator.comparingInt(o -&gt; o.end));</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = intervals[<span class=\"number\">0</span>].end;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i].start&lt;end)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            end = intervals[i].end;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intervals.length - cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">BinarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>,h = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt;= h)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = l + (h - l) / <span class=\"number\">2</span>; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[mid] == target)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &lt; target)</span><br><span class=\"line\">            l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            h = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sqrt(x)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sqrt</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sqrt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>,h = x;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= h)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = l + (h-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sqrt = x/mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sqrt == mid)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid &gt; sqrt)</span><br><span class=\"line\">                h = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;   <span class=\"comment\">//循环中值后l比h大</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//bfs</span></span><br></pre></td></tr></table></figure>"}],"Post":[{"title":"BigData","date":"2018-08-25T01:03:43.000Z","_content":"\n一些大数据相关基础思想和概念，[曾经我的简书](https://www.jianshu.com/u/484f3f0c4dd3)\n\n<!--more-->\n\n#### HDFS\n\n#### MapReduce","source":"_posts/BigData.md","raw":"---\ntitle: BigData\ndate: 2018-8-25 09:03:43\ntags: [notes,大数据]\n---\n\n一些大数据相关基础思想和概念，[曾经我的简书](https://www.jianshu.com/u/484f3f0c4dd3)\n\n<!--more-->\n\n#### HDFS\n\n#### MapReduce","slug":"BigData","published":1,"updated":"2018-10-03T17:52:24.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2q70000qseztvnrbvw2","content":"<p>一些大数据相关基础思想和概念，<a href=\"https://www.jianshu.com/u/484f3f0c4dd3\" target=\"_blank\" rel=\"noopener\">曾经我的简书</a></p>\n<a id=\"more\"></a>\n<h4 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h4><h4 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h4>","site":{"data":{}},"excerpt":"<p>一些大数据相关基础思想和概念，<a href=\"https://www.jianshu.com/u/484f3f0c4dd3\" target=\"_blank\" rel=\"noopener\">曾经我的简书</a></p>","more":"<h4 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h4><h4 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h4>"},{"layout":"communication","title":"protocol","date":"2019-07-31T14:16:26.000Z","_content":"\ncommunication protocol\n\n<!--more-->\n\nOSI七层模型和TCP/IP五层模型：\n\n>应用层：为应用程序提供服务\n>\n>表示层：数据格式转化、数据加密\n>\n>会话层：建立、管理、维护会话\n>\n>传输层：建立、管理、维护端到端地链接\n>\n>网络层：IP选址以及路由\n>\n>数据链路层：提供介质访问和链路管理\n>\n>物理层\n\n>应用层 HTTP\n>\n>传输层 TCP UDP\n>\n>网络层 IP ICMP\n>\n>数据链路层 ARP(直接和网络设备接口打交道)\n>\n>物理层\n\n​    Linux中的BSD socket和INET socket：对应于七层模型中的表示层和会话层，重要的数据结构为struct socket、struct sock、proto。\n\n​    Linux中的IP协议向下需要和网络设备接口打交道，向上需要提供传输和接收服务(路由服务)，是一个非常核心的协议。\n\n​    Linux中网络接口模块为内核代码的/linux/net部分代码，其中tcp/ip协议的实现在/linux/net/ipv4部分。网络接口主要由网络设备接口、网络接口core模块、网络协议族、网络接口socket四部分组成，其中网络设备接口(linux/driver/net)负责与物理介质进行数据的交互；网络接口核心模块主要功能为屏蔽物理层介质，为网络协议提供统一的接口，负责把包送入合适的协议(主要管理文件为linux/net/core/dev.c)；网络协议层实现各种网络协议；网络接口Socket为用户提供的网络服务提供编程接口(linux/net/socket.c)。\n\n​    linux/include/linux/socket.h中linuxBSDsocket定义了多至32中支持的协议族，其中PF_INET为tcp/ip协议族。在/linux/net/ipv4目录下，**af_inet.c**为主要的管理文件。\n\n- UDP：（UserDatagramProtocol）\n\n  无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多\n\n- TCP：\n\n  面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接\n\n  基于字节序号的SequenceNumber和ACK，确认消息的有序到达；重传也不会改变的SequenceNumber会导致TCP**重传歧义**问题。\n\n  TCP连接的四元组标识：源IP、源端口、目的IP、目的端口\n\n  **慢启动、拥塞避免、快速重传、快速恢复**（锯齿曲线）\n\n  TCP头(60字节，其中标准头20字节，TCP Option40字节(TcpTimestampOption10字节，所以留给Sack仅30字节，又由于SackBlock为8字节，SackOption为2字节，所以TcpSackOption最大为3个))\n\n  AckDelay，服务端接收到segment到ack中回复TimestampOption的时间，导致RTT计算误差\n\n  RTT-RoundTripTime\n\n  WindowSize\n\n  MSS-maximun segment size\n\n  ACK/SACK(告诉发送方接收到连续Segment范围)\n\n  FLOW-control/Congestion-control\n\n  CWND/RWND\n\n  TCP中接收速率的计算，可以采用固定时间窗口的计算方式和数ACK数的计算方式，如果在存在ACK传输过程中丢失的情况下，后者的计算准确性更好。\n\n  源码中接收速率的计算方法：\n\n  ```c\n  //tcp.c、tcp_rate.c\n  static u64 tcp_compute_delivery_rate(const struct tcp_sock *tp)\n  {\n  \tu32 rate = READ_ONCE(tp->rate_delivered);\n  \tu32 intv = READ_ONCE(tp->rate_interval_us);\n  \tu64 rate64 = 0;\n  \n  \tif (rate && intv) {\n  \t\trate64 = (u64)rate * tp->mss_cache * USEC_PER_SEC;\n  \t\tdo_div(rate64, intv);\n  \t}\n  \treturn rate64;\n  }\n  \n  /* The bandwidth estimator estimates the rate at which the network\n   * can currently deliver outbound data packets for this flow. At a high\n   * level, it operates by taking a delivery rate sample for each ACK.\n   *\n   * A rate sample records the rate at which the network delivered packets\n   * for this flow, calculated over the time interval between the transmission\n   * of a data packet and the acknowledgment of that packet.\n   *\n   * Specifically, over the interval between each transmit and corresponding ACK,\n   * the estimator generates a delivery rate sample. Typically it uses the rate\n   * at which packets were acknowledged. However, the approach of using only the\n   * acknowledgment rate faces a challenge under the prevalent ACK decimation or\n   * compression: packets can temporarily appear to be delivered much quicker\n   * than the bottleneck rate. Since it is physically impossible to do that in a\n   * sustained fashion, when the estimator notices that the ACK rate is faster\n   * than the transmit rate, it uses the latter:\n   *\n   *    send_rate = #pkts_delivered/(last_snd_time - first_snd_time)\n   *    ack_rate  = #pkts_delivered/(last_ack_time - first_ack_time)\n   *    bw = min(send_rate, ack_rate)\n   *\n   * Notice the estimator essentially estimates the goodput, not always the\n   * network bottleneck link rate when the sending or receiving is limited by\n   * other factors like applications or receiver window limits.  The estimator\n   * deliberately avoids using the inter-packet spacing approach because that\n   * approach requires a large number of samples and sophisticated filtering.\n   *\n   * TCP flows can often be application-limited in request/response workloads.\n   * The estimator marks a bandwidth sample as application-limited if there\n   * was some moment during the sampled window of packets when there was no data\n   * ready to send in the write queue.\n   */\n  ```\n\n  \n\n  **TCPBBR**：启动、排空、带宽探测、时延探测(STARTUP、DRAIN、PROBE_BW、PROBE_RTT)\n\n  ​\tBBR算法不能感知丢包，只能看到bw和rtt。\n\n  ​\tpacing rate(cwnd窗口中的数据包以多大的时间间隔发送) & cwnd(当前TCP最多可以发送多少数据)\n\n  ​\t即时带宽：bw=delivered/interval_us\n\n  ​\t\n\n- http2+tcp+tls广泛应用\n\n  tcp和tls带来了两次握手时延\n\n- QUIC\n\n  quick **udp** internet connection（使用udp进行多路并发传输的协议），避免协议对操作系统和中间设备依赖问题？\n\n  0-RTT、可插拔拥塞控制、多路复用(避免队头阻塞(tcp(sequence number)和tls(record)均会出现))、连接迁移(不再用四元组标识连接，用ID标识)、前向冗余纠错\n\n严格递增的PacketNumber+StreamOffset(不变)保证数据有序可靠\n\nReneging，丢弃已接受并回SACK的内容\n\nQUIC ACK Frame可以同时提供256个AckBlock，在丢包率较高的网络下，可以提升网络恢复速度，减少重传\n\nlock free queue\n\nred-blue Tree\n\n\n\n","source":"_posts/protocol.md","raw":"---\nlayout: communication\ntitle: protocol\ndate: 2019-07-31 22:16:26\ntags: [notes,...]\n---\n\ncommunication protocol\n\n<!--more-->\n\nOSI七层模型和TCP/IP五层模型：\n\n>应用层：为应用程序提供服务\n>\n>表示层：数据格式转化、数据加密\n>\n>会话层：建立、管理、维护会话\n>\n>传输层：建立、管理、维护端到端地链接\n>\n>网络层：IP选址以及路由\n>\n>数据链路层：提供介质访问和链路管理\n>\n>物理层\n\n>应用层 HTTP\n>\n>传输层 TCP UDP\n>\n>网络层 IP ICMP\n>\n>数据链路层 ARP(直接和网络设备接口打交道)\n>\n>物理层\n\n​    Linux中的BSD socket和INET socket：对应于七层模型中的表示层和会话层，重要的数据结构为struct socket、struct sock、proto。\n\n​    Linux中的IP协议向下需要和网络设备接口打交道，向上需要提供传输和接收服务(路由服务)，是一个非常核心的协议。\n\n​    Linux中网络接口模块为内核代码的/linux/net部分代码，其中tcp/ip协议的实现在/linux/net/ipv4部分。网络接口主要由网络设备接口、网络接口core模块、网络协议族、网络接口socket四部分组成，其中网络设备接口(linux/driver/net)负责与物理介质进行数据的交互；网络接口核心模块主要功能为屏蔽物理层介质，为网络协议提供统一的接口，负责把包送入合适的协议(主要管理文件为linux/net/core/dev.c)；网络协议层实现各种网络协议；网络接口Socket为用户提供的网络服务提供编程接口(linux/net/socket.c)。\n\n​    linux/include/linux/socket.h中linuxBSDsocket定义了多至32中支持的协议族，其中PF_INET为tcp/ip协议族。在/linux/net/ipv4目录下，**af_inet.c**为主要的管理文件。\n\n- UDP：（UserDatagramProtocol）\n\n  无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多\n\n- TCP：\n\n  面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接\n\n  基于字节序号的SequenceNumber和ACK，确认消息的有序到达；重传也不会改变的SequenceNumber会导致TCP**重传歧义**问题。\n\n  TCP连接的四元组标识：源IP、源端口、目的IP、目的端口\n\n  **慢启动、拥塞避免、快速重传、快速恢复**（锯齿曲线）\n\n  TCP头(60字节，其中标准头20字节，TCP Option40字节(TcpTimestampOption10字节，所以留给Sack仅30字节，又由于SackBlock为8字节，SackOption为2字节，所以TcpSackOption最大为3个))\n\n  AckDelay，服务端接收到segment到ack中回复TimestampOption的时间，导致RTT计算误差\n\n  RTT-RoundTripTime\n\n  WindowSize\n\n  MSS-maximun segment size\n\n  ACK/SACK(告诉发送方接收到连续Segment范围)\n\n  FLOW-control/Congestion-control\n\n  CWND/RWND\n\n  TCP中接收速率的计算，可以采用固定时间窗口的计算方式和数ACK数的计算方式，如果在存在ACK传输过程中丢失的情况下，后者的计算准确性更好。\n\n  源码中接收速率的计算方法：\n\n  ```c\n  //tcp.c、tcp_rate.c\n  static u64 tcp_compute_delivery_rate(const struct tcp_sock *tp)\n  {\n  \tu32 rate = READ_ONCE(tp->rate_delivered);\n  \tu32 intv = READ_ONCE(tp->rate_interval_us);\n  \tu64 rate64 = 0;\n  \n  \tif (rate && intv) {\n  \t\trate64 = (u64)rate * tp->mss_cache * USEC_PER_SEC;\n  \t\tdo_div(rate64, intv);\n  \t}\n  \treturn rate64;\n  }\n  \n  /* The bandwidth estimator estimates the rate at which the network\n   * can currently deliver outbound data packets for this flow. At a high\n   * level, it operates by taking a delivery rate sample for each ACK.\n   *\n   * A rate sample records the rate at which the network delivered packets\n   * for this flow, calculated over the time interval between the transmission\n   * of a data packet and the acknowledgment of that packet.\n   *\n   * Specifically, over the interval between each transmit and corresponding ACK,\n   * the estimator generates a delivery rate sample. Typically it uses the rate\n   * at which packets were acknowledged. However, the approach of using only the\n   * acknowledgment rate faces a challenge under the prevalent ACK decimation or\n   * compression: packets can temporarily appear to be delivered much quicker\n   * than the bottleneck rate. Since it is physically impossible to do that in a\n   * sustained fashion, when the estimator notices that the ACK rate is faster\n   * than the transmit rate, it uses the latter:\n   *\n   *    send_rate = #pkts_delivered/(last_snd_time - first_snd_time)\n   *    ack_rate  = #pkts_delivered/(last_ack_time - first_ack_time)\n   *    bw = min(send_rate, ack_rate)\n   *\n   * Notice the estimator essentially estimates the goodput, not always the\n   * network bottleneck link rate when the sending or receiving is limited by\n   * other factors like applications or receiver window limits.  The estimator\n   * deliberately avoids using the inter-packet spacing approach because that\n   * approach requires a large number of samples and sophisticated filtering.\n   *\n   * TCP flows can often be application-limited in request/response workloads.\n   * The estimator marks a bandwidth sample as application-limited if there\n   * was some moment during the sampled window of packets when there was no data\n   * ready to send in the write queue.\n   */\n  ```\n\n  \n\n  **TCPBBR**：启动、排空、带宽探测、时延探测(STARTUP、DRAIN、PROBE_BW、PROBE_RTT)\n\n  ​\tBBR算法不能感知丢包，只能看到bw和rtt。\n\n  ​\tpacing rate(cwnd窗口中的数据包以多大的时间间隔发送) & cwnd(当前TCP最多可以发送多少数据)\n\n  ​\t即时带宽：bw=delivered/interval_us\n\n  ​\t\n\n- http2+tcp+tls广泛应用\n\n  tcp和tls带来了两次握手时延\n\n- QUIC\n\n  quick **udp** internet connection（使用udp进行多路并发传输的协议），避免协议对操作系统和中间设备依赖问题？\n\n  0-RTT、可插拔拥塞控制、多路复用(避免队头阻塞(tcp(sequence number)和tls(record)均会出现))、连接迁移(不再用四元组标识连接，用ID标识)、前向冗余纠错\n\n严格递增的PacketNumber+StreamOffset(不变)保证数据有序可靠\n\nReneging，丢弃已接受并回SACK的内容\n\nQUIC ACK Frame可以同时提供256个AckBlock，在丢包率较高的网络下，可以提升网络恢复速度，减少重传\n\nlock free queue\n\nred-blue Tree\n\n\n\n","slug":"protocol","published":1,"updated":"2019-08-11T14:55:58.039Z","comments":1,"photos":[],"link":"","_id":"cjz73d2qt0005qsez3myv2eau","content":"<p>communication protocol</p>\n<a id=\"more\"></a>\n<p>OSI七层模型和TCP/IP五层模型：</p>\n<blockquote>\n<p>应用层：为应用程序提供服务</p>\n<p>表示层：数据格式转化、数据加密</p>\n<p>会话层：建立、管理、维护会话</p>\n<p>传输层：建立、管理、维护端到端地链接</p>\n<p>网络层：IP选址以及路由</p>\n<p>数据链路层：提供介质访问和链路管理</p>\n<p>物理层</p>\n</blockquote>\n<blockquote>\n<p>应用层 HTTP</p>\n<p>传输层 TCP UDP</p>\n<p>网络层 IP ICMP</p>\n<p>数据链路层 ARP(直接和网络设备接口打交道)</p>\n<p>物理层</p>\n</blockquote>\n<p>​    Linux中的BSD socket和INET socket：对应于七层模型中的表示层和会话层，重要的数据结构为struct socket、struct sock、proto。</p>\n<p>​    Linux中的IP协议向下需要和网络设备接口打交道，向上需要提供传输和接收服务(路由服务)，是一个非常核心的协议。</p>\n<p>​    Linux中网络接口模块为内核代码的/linux/net部分代码，其中tcp/ip协议的实现在/linux/net/ipv4部分。网络接口主要由网络设备接口、网络接口core模块、网络协议族、网络接口socket四部分组成，其中网络设备接口(linux/driver/net)负责与物理介质进行数据的交互；网络接口核心模块主要功能为屏蔽物理层介质，为网络协议提供统一的接口，负责把包送入合适的协议(主要管理文件为linux/net/core/dev.c)；网络协议层实现各种网络协议；网络接口Socket为用户提供的网络服务提供编程接口(linux/net/socket.c)。</p>\n<p>​    linux/include/linux/socket.h中linuxBSDsocket定义了多至32中支持的协议族，其中PF_INET为tcp/ip协议族。在/linux/net/ipv4目录下，<strong>af_inet.c</strong>为主要的管理文件。</p>\n<ul>\n<li><p>UDP：（UserDatagramProtocol）</p>\n<p>无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多</p>\n</li>\n<li><p>TCP：</p>\n<p>面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接</p>\n<p>基于字节序号的SequenceNumber和ACK，确认消息的有序到达；重传也不会改变的SequenceNumber会导致TCP<strong>重传歧义</strong>问题。</p>\n<p>TCP连接的四元组标识：源IP、源端口、目的IP、目的端口</p>\n<p><strong>慢启动、拥塞避免、快速重传、快速恢复</strong>（锯齿曲线）</p>\n<p>TCP头(60字节，其中标准头20字节，TCP Option40字节(TcpTimestampOption10字节，所以留给Sack仅30字节，又由于SackBlock为8字节，SackOption为2字节，所以TcpSackOption最大为3个))</p>\n<p>AckDelay，服务端接收到segment到ack中回复TimestampOption的时间，导致RTT计算误差</p>\n<p>RTT-RoundTripTime</p>\n<p>WindowSize</p>\n<p>MSS-maximun segment size</p>\n<p>ACK/SACK(告诉发送方接收到连续Segment范围)</p>\n<p>FLOW-control/Congestion-control</p>\n<p>CWND/RWND</p>\n<p>TCP中接收速率的计算，可以采用固定时间窗口的计算方式和数ACK数的计算方式，如果在存在ACK传输过程中丢失的情况下，后者的计算准确性更好。</p>\n<p>源码中接收速率的计算方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//tcp.c、tcp_rate.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> u64 <span class=\"title\">tcp_compute_delivery_rate</span><span class=\"params\">(<span class=\"keyword\">const</span> struct tcp_sock *tp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tu32 rate = READ_ONCE(tp-&gt;rate_delivered);</span><br><span class=\"line\">\tu32 intv = READ_ONCE(tp-&gt;rate_interval_us);</span><br><span class=\"line\">\tu64 rate64 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rate &amp;&amp; intv) &#123;</span><br><span class=\"line\">\t\trate64 = (u64)rate * tp-&gt;mss_cache * USEC_PER_SEC;</span><br><span class=\"line\">\t\tdo_div(rate64, intv);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rate64;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The bandwidth estimator estimates the rate at which the network</span></span><br><span class=\"line\"><span class=\"comment\"> * can currently deliver outbound data packets for this flow. At a high</span></span><br><span class=\"line\"><span class=\"comment\"> * level, it operates by taking a delivery rate sample for each ACK.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * A rate sample records the rate at which the network delivered packets</span></span><br><span class=\"line\"><span class=\"comment\"> * for this flow, calculated over the time interval between the transmission</span></span><br><span class=\"line\"><span class=\"comment\"> * of a data packet and the acknowledgment of that packet.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Specifically, over the interval between each transmit and corresponding ACK,</span></span><br><span class=\"line\"><span class=\"comment\"> * the estimator generates a delivery rate sample. Typically it uses the rate</span></span><br><span class=\"line\"><span class=\"comment\"> * at which packets were acknowledged. However, the approach of using only the</span></span><br><span class=\"line\"><span class=\"comment\"> * acknowledgment rate faces a challenge under the prevalent ACK decimation or</span></span><br><span class=\"line\"><span class=\"comment\"> * compression: packets can temporarily appear to be delivered much quicker</span></span><br><span class=\"line\"><span class=\"comment\"> * than the bottleneck rate. Since it is physically impossible to do that in a</span></span><br><span class=\"line\"><span class=\"comment\"> * sustained fashion, when the estimator notices that the ACK rate is faster</span></span><br><span class=\"line\"><span class=\"comment\"> * than the transmit rate, it uses the latter:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    send_rate = #pkts_delivered/(last_snd_time - first_snd_time)</span></span><br><span class=\"line\"><span class=\"comment\"> *    ack_rate  = #pkts_delivered/(last_ack_time - first_ack_time)</span></span><br><span class=\"line\"><span class=\"comment\"> *    bw = min(send_rate, ack_rate)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Notice the estimator essentially estimates the goodput, not always the</span></span><br><span class=\"line\"><span class=\"comment\"> * network bottleneck link rate when the sending or receiving is limited by</span></span><br><span class=\"line\"><span class=\"comment\"> * other factors like applications or receiver window limits.  The estimator</span></span><br><span class=\"line\"><span class=\"comment\"> * deliberately avoids using the inter-packet spacing approach because that</span></span><br><span class=\"line\"><span class=\"comment\"> * approach requires a large number of samples and sophisticated filtering.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * TCP flows can often be application-limited in request/response workloads.</span></span><br><span class=\"line\"><span class=\"comment\"> * The estimator marks a bandwidth sample as application-limited if there</span></span><br><span class=\"line\"><span class=\"comment\"> * was some moment during the sampled window of packets when there was no data</span></span><br><span class=\"line\"><span class=\"comment\"> * ready to send in the write queue.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  <strong>TCPBBR</strong>：启动、排空、带宽探测、时延探测(STARTUP、DRAIN、PROBE_BW、PROBE_RTT)</p>\n<p>  ​    BBR算法不能感知丢包，只能看到bw和rtt。</p>\n<p>  ​    pacing rate(cwnd窗口中的数据包以多大的时间间隔发送) &amp; cwnd(当前TCP最多可以发送多少数据)</p>\n<p>  ​    即时带宽：bw=delivered/interval_us</p>\n<p>  ​    </p>\n<ul>\n<li><p>http2+tcp+tls广泛应用</p>\n<p>tcp和tls带来了两次握手时延</p>\n</li>\n<li><p>QUIC</p>\n<p>quick <strong>udp</strong> internet connection（使用udp进行多路并发传输的协议），避免协议对操作系统和中间设备依赖问题？</p>\n<p>0-RTT、可插拔拥塞控制、多路复用(避免队头阻塞(tcp(sequence number)和tls(record)均会出现))、连接迁移(不再用四元组标识连接，用ID标识)、前向冗余纠错</p>\n</li>\n</ul>\n<p>严格递增的PacketNumber+StreamOffset(不变)保证数据有序可靠</p>\n<p>Reneging，丢弃已接受并回SACK的内容</p>\n<p>QUIC ACK Frame可以同时提供256个AckBlock，在丢包率较高的网络下，可以提升网络恢复速度，减少重传</p>\n<p>lock free queue</p>\n<p>red-blue Tree</p>\n","site":{"data":{}},"excerpt":"<p>communication protocol</p>","more":"<p>OSI七层模型和TCP/IP五层模型：</p>\n<blockquote>\n<p>应用层：为应用程序提供服务</p>\n<p>表示层：数据格式转化、数据加密</p>\n<p>会话层：建立、管理、维护会话</p>\n<p>传输层：建立、管理、维护端到端地链接</p>\n<p>网络层：IP选址以及路由</p>\n<p>数据链路层：提供介质访问和链路管理</p>\n<p>物理层</p>\n</blockquote>\n<blockquote>\n<p>应用层 HTTP</p>\n<p>传输层 TCP UDP</p>\n<p>网络层 IP ICMP</p>\n<p>数据链路层 ARP(直接和网络设备接口打交道)</p>\n<p>物理层</p>\n</blockquote>\n<p>​    Linux中的BSD socket和INET socket：对应于七层模型中的表示层和会话层，重要的数据结构为struct socket、struct sock、proto。</p>\n<p>​    Linux中的IP协议向下需要和网络设备接口打交道，向上需要提供传输和接收服务(路由服务)，是一个非常核心的协议。</p>\n<p>​    Linux中网络接口模块为内核代码的/linux/net部分代码，其中tcp/ip协议的实现在/linux/net/ipv4部分。网络接口主要由网络设备接口、网络接口core模块、网络协议族、网络接口socket四部分组成，其中网络设备接口(linux/driver/net)负责与物理介质进行数据的交互；网络接口核心模块主要功能为屏蔽物理层介质，为网络协议提供统一的接口，负责把包送入合适的协议(主要管理文件为linux/net/core/dev.c)；网络协议层实现各种网络协议；网络接口Socket为用户提供的网络服务提供编程接口(linux/net/socket.c)。</p>\n<p>​    linux/include/linux/socket.h中linuxBSDsocket定义了多至32中支持的协议族，其中PF_INET为tcp/ip协议族。在/linux/net/ipv4目录下，<strong>af_inet.c</strong>为主要的管理文件。</p>\n<ul>\n<li><p>UDP：（UserDatagramProtocol）</p>\n<p>无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多</p>\n</li>\n<li><p>TCP：</p>\n<p>面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接</p>\n<p>基于字节序号的SequenceNumber和ACK，确认消息的有序到达；重传也不会改变的SequenceNumber会导致TCP<strong>重传歧义</strong>问题。</p>\n<p>TCP连接的四元组标识：源IP、源端口、目的IP、目的端口</p>\n<p><strong>慢启动、拥塞避免、快速重传、快速恢复</strong>（锯齿曲线）</p>\n<p>TCP头(60字节，其中标准头20字节，TCP Option40字节(TcpTimestampOption10字节，所以留给Sack仅30字节，又由于SackBlock为8字节，SackOption为2字节，所以TcpSackOption最大为3个))</p>\n<p>AckDelay，服务端接收到segment到ack中回复TimestampOption的时间，导致RTT计算误差</p>\n<p>RTT-RoundTripTime</p>\n<p>WindowSize</p>\n<p>MSS-maximun segment size</p>\n<p>ACK/SACK(告诉发送方接收到连续Segment范围)</p>\n<p>FLOW-control/Congestion-control</p>\n<p>CWND/RWND</p>\n<p>TCP中接收速率的计算，可以采用固定时间窗口的计算方式和数ACK数的计算方式，如果在存在ACK传输过程中丢失的情况下，后者的计算准确性更好。</p>\n<p>源码中接收速率的计算方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//tcp.c、tcp_rate.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> u64 <span class=\"title\">tcp_compute_delivery_rate</span><span class=\"params\">(<span class=\"keyword\">const</span> struct tcp_sock *tp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tu32 rate = READ_ONCE(tp-&gt;rate_delivered);</span><br><span class=\"line\">\tu32 intv = READ_ONCE(tp-&gt;rate_interval_us);</span><br><span class=\"line\">\tu64 rate64 = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (rate &amp;&amp; intv) &#123;</span><br><span class=\"line\">\t\trate64 = (u64)rate * tp-&gt;mss_cache * USEC_PER_SEC;</span><br><span class=\"line\">\t\tdo_div(rate64, intv);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rate64;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The bandwidth estimator estimates the rate at which the network</span></span><br><span class=\"line\"><span class=\"comment\"> * can currently deliver outbound data packets for this flow. At a high</span></span><br><span class=\"line\"><span class=\"comment\"> * level, it operates by taking a delivery rate sample for each ACK.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * A rate sample records the rate at which the network delivered packets</span></span><br><span class=\"line\"><span class=\"comment\"> * for this flow, calculated over the time interval between the transmission</span></span><br><span class=\"line\"><span class=\"comment\"> * of a data packet and the acknowledgment of that packet.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Specifically, over the interval between each transmit and corresponding ACK,</span></span><br><span class=\"line\"><span class=\"comment\"> * the estimator generates a delivery rate sample. Typically it uses the rate</span></span><br><span class=\"line\"><span class=\"comment\"> * at which packets were acknowledged. However, the approach of using only the</span></span><br><span class=\"line\"><span class=\"comment\"> * acknowledgment rate faces a challenge under the prevalent ACK decimation or</span></span><br><span class=\"line\"><span class=\"comment\"> * compression: packets can temporarily appear to be delivered much quicker</span></span><br><span class=\"line\"><span class=\"comment\"> * than the bottleneck rate. Since it is physically impossible to do that in a</span></span><br><span class=\"line\"><span class=\"comment\"> * sustained fashion, when the estimator notices that the ACK rate is faster</span></span><br><span class=\"line\"><span class=\"comment\"> * than the transmit rate, it uses the latter:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *    send_rate = #pkts_delivered/(last_snd_time - first_snd_time)</span></span><br><span class=\"line\"><span class=\"comment\"> *    ack_rate  = #pkts_delivered/(last_ack_time - first_ack_time)</span></span><br><span class=\"line\"><span class=\"comment\"> *    bw = min(send_rate, ack_rate)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Notice the estimator essentially estimates the goodput, not always the</span></span><br><span class=\"line\"><span class=\"comment\"> * network bottleneck link rate when the sending or receiving is limited by</span></span><br><span class=\"line\"><span class=\"comment\"> * other factors like applications or receiver window limits.  The estimator</span></span><br><span class=\"line\"><span class=\"comment\"> * deliberately avoids using the inter-packet spacing approach because that</span></span><br><span class=\"line\"><span class=\"comment\"> * approach requires a large number of samples and sophisticated filtering.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * TCP flows can often be application-limited in request/response workloads.</span></span><br><span class=\"line\"><span class=\"comment\"> * The estimator marks a bandwidth sample as application-limited if there</span></span><br><span class=\"line\"><span class=\"comment\"> * was some moment during the sampled window of packets when there was no data</span></span><br><span class=\"line\"><span class=\"comment\"> * ready to send in the write queue.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  <strong>TCPBBR</strong>：启动、排空、带宽探测、时延探测(STARTUP、DRAIN、PROBE_BW、PROBE_RTT)</p>\n<p>  ​    BBR算法不能感知丢包，只能看到bw和rtt。</p>\n<p>  ​    pacing rate(cwnd窗口中的数据包以多大的时间间隔发送) &amp; cwnd(当前TCP最多可以发送多少数据)</p>\n<p>  ​    即时带宽：bw=delivered/interval_us</p>\n<p>  ​    </p>\n<ul>\n<li><p>http2+tcp+tls广泛应用</p>\n<p>tcp和tls带来了两次握手时延</p>\n</li>\n<li><p>QUIC</p>\n<p>quick <strong>udp</strong> internet connection（使用udp进行多路并发传输的协议），避免协议对操作系统和中间设备依赖问题？</p>\n<p>0-RTT、可插拔拥塞控制、多路复用(避免队头阻塞(tcp(sequence number)和tls(record)均会出现))、连接迁移(不再用四元组标识连接，用ID标识)、前向冗余纠错</p>\n</li>\n</ul>\n<p>严格递增的PacketNumber+StreamOffset(不变)保证数据有序可靠</p>\n<p>Reneging，丢弃已接受并回SACK的内容</p>\n<p>QUIC ACK Frame可以同时提供256个AckBlock，在丢包率较高的网络下，可以提升网络恢复速度，减少重传</p>\n<p>lock free queue</p>\n<p>red-blue Tree</p>"},{"title":"Hexo+GithubPages搭建博客","date":"2018-08-02T13:17:37.000Z","_content":"​\t本博客完整搭建流程\n\n<!--more-->\n\n#  一、安装Node.js、Hexo\n\n​\tUbuntu、Mac、Win下的安装都大同小异\n\n```bash\n$ sudo apt-get install node.js\n$ sudo apt-get install npm   #一种包管理工具\n$ sudo npm install -g hexo\n\n$ node -v\n$ hexo -v  #输出相应的版本即安装成功\n```\n# 二、Git相关配置\n\n## 1、创建一个**username.github.io**的repository\n\n## 2、配置ssh key\n\n- 打开bash\n\n```bash\n$ ssh-keygen -t rsa -C \"xxxx@xx.xx\" \n# 一路回车\n```\n\n- 打开用户目录下的*~/.ssh/*目录，目录下文件id_rsa为私钥，id_rsa.pub为公钥。复制id_rsa.pub里面的内容\n- 打开Github->Settings->SSH and GPG keys->new SSH key，取好别名，粘贴秘钥，回到bash\n\n```bash\n$ ssh -T git@github.com    #如果输出hello。。。字样，表示配置成功\n```\n\n若同一电脑需要用到多个sshkey，则还需如下操作：\n\n```bash\n$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.xx -C \"xxx@xx.xx\"   #生成另外一个带别名的key\n$ ssh-add ~/.ssh/id_rsa.xx  #添加新的ssh key到ssh agent，其默认只读id_rsa\n$ touch config  #创建多个key的配置文件\n```\n\n已同时配置gitlab和github的key为例，config文件中写入如下信息\n\n```reStructuredText\nHost github\nHostName github.com\nUser git\nIdentityFile ~.ssh/id_rsa.github\n\nHost gitlab\nHostName gitlab.com\nUser git\nIdentityFile ~.ssh/id_rsa.gitlab\n```\n\n编写完成后同样可以如前所述 *“ssh -T xxx”* 检查是否配置成功\n\n> 遇到git push origin/hexo时提示：Please make sure you have the correct access rights and the repository exists.\n>\n> 解决办法：操作一下~/.ssh目录下的known_hosts文件，mv known_hosts known_hosts.bat\n\n## 3、Git常规配置\n\n```bash\n$ git config --list     #查看config信息\n$ git config --global user.name \"xxx\"    \n$ git config --global user.email \"xxx@xxx.xx\"\n```\n\n如果须有某个文件夹下单独配置，--global改为--local即可\n\n# 三、搭建博客开启写作之旅\n\n### 搭建流程\n\n​\tHexo搭建博客后部署到Github，如果我们需要把我们原始文件也存到Github便于我们后续在不同电脑更改，理论上我们需要一个库部署，一个库来存储我们的原始文件。这里我们通过建立不同的分支来实现。\n\n```bash\n$ git clone git@github.com:xxx/xxx.github.io.git\n$ git branch hexo\n$ git checkout hexo\n```\n\n​\t我们可以把hexo分支设置为默认分支，打开项目的settings->Branches->Default Branch更改即可。因为后续更改只会发生在hexo分支，master分支仅起部署作用。\n\n接着，我们操作Hexo：\n\n于hexo分支下，\n\n```bash\n$ hexo init  #只有空文件夹时需要这句代码\n$ npm install hexo-deployer-git\n$ hexo g  #generate,生成静态网页\n$ hexo s  #server,本地预览http://localhost:4000/\n```\n\n博客的配置文件为_config.yml，关于部署的配置如下：\n\n```\ndeploy:\n  type: git\n  repository: git@github.com:xxx/xxx.github.io.git\n  branch: master\n```\n\n其他配置参考注释。。\n\n重新生成部署：\n\n```bash\n$hexo clean\n$ hexo g\n$ hexo d  #deploy\n```\n\n此时，打开<https://xxx.github.io/>即可访问博客。\n\n开启写作之旅：\n\n```bash\n$ hexo n \"xxx\"  #new,命令执行后，在/source/_posts下回产生一个xxx.md文件\n```\n\n修改完后，push到hexo分支：\n\n```bash\n$ git add .\n$ git commit -m \"xxx\"\n$ git push origin hexo  #-f强行push\n```\n\n如需在其他机器写作，git clone下来即可\n\n### 坑点记录\n\n- **修改配置_config.yml文件时，记得配置项之前加空格**\n\n  比如：title: *<-这个地方必须有空格*Pamper'Blog\n\n- 当我们在多台机器上修改博客，产生修改不一致的情况时，可以强制某台机器本地同步git上的代码：\n\n```bash\n$ git fetch --all\n$ git reset --hard origin/hexo\n$ git pull\n\n$ git fetch origin hexo\n$ git log -p hexo..origin/hexo\n$ git merge origin/hexo\n```\n\n- 添加.gitignore忽略某些文件，如.DS_Store，.deploy_git，如果发现.gitignore没起作用，清除一下git缓存即可：\n\n```bash\n$ git rm -r --cached .\n$ git add .\n$ git commit -m \"update .gitignore\"\n$ git push origin hexo\n```\n\n # 四、主题配置\n\n​\t配置文件_config.yml中有主题配置选项theme，将心仪的主题clone到themes文件夹下，修改配置重新部署即可应用主题，主题基本配置同样主题文件夹下的 _config.yml配置。\n\n​\t本博客采用[yilia](https://github.com/litten/hexo-theme-yilia)主题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Hexo+GithubPages搭建博客.md","raw":"---\ntitle: Hexo+GithubPages搭建博客\ndate: 2018-08-02 21:17:37\ntags: [notes,Github Pages,Hexo]\n---\n​\t本博客完整搭建流程\n\n<!--more-->\n\n#  一、安装Node.js、Hexo\n\n​\tUbuntu、Mac、Win下的安装都大同小异\n\n```bash\n$ sudo apt-get install node.js\n$ sudo apt-get install npm   #一种包管理工具\n$ sudo npm install -g hexo\n\n$ node -v\n$ hexo -v  #输出相应的版本即安装成功\n```\n# 二、Git相关配置\n\n## 1、创建一个**username.github.io**的repository\n\n## 2、配置ssh key\n\n- 打开bash\n\n```bash\n$ ssh-keygen -t rsa -C \"xxxx@xx.xx\" \n# 一路回车\n```\n\n- 打开用户目录下的*~/.ssh/*目录，目录下文件id_rsa为私钥，id_rsa.pub为公钥。复制id_rsa.pub里面的内容\n- 打开Github->Settings->SSH and GPG keys->new SSH key，取好别名，粘贴秘钥，回到bash\n\n```bash\n$ ssh -T git@github.com    #如果输出hello。。。字样，表示配置成功\n```\n\n若同一电脑需要用到多个sshkey，则还需如下操作：\n\n```bash\n$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.xx -C \"xxx@xx.xx\"   #生成另外一个带别名的key\n$ ssh-add ~/.ssh/id_rsa.xx  #添加新的ssh key到ssh agent，其默认只读id_rsa\n$ touch config  #创建多个key的配置文件\n```\n\n已同时配置gitlab和github的key为例，config文件中写入如下信息\n\n```reStructuredText\nHost github\nHostName github.com\nUser git\nIdentityFile ~.ssh/id_rsa.github\n\nHost gitlab\nHostName gitlab.com\nUser git\nIdentityFile ~.ssh/id_rsa.gitlab\n```\n\n编写完成后同样可以如前所述 *“ssh -T xxx”* 检查是否配置成功\n\n> 遇到git push origin/hexo时提示：Please make sure you have the correct access rights and the repository exists.\n>\n> 解决办法：操作一下~/.ssh目录下的known_hosts文件，mv known_hosts known_hosts.bat\n\n## 3、Git常规配置\n\n```bash\n$ git config --list     #查看config信息\n$ git config --global user.name \"xxx\"    \n$ git config --global user.email \"xxx@xxx.xx\"\n```\n\n如果须有某个文件夹下单独配置，--global改为--local即可\n\n# 三、搭建博客开启写作之旅\n\n### 搭建流程\n\n​\tHexo搭建博客后部署到Github，如果我们需要把我们原始文件也存到Github便于我们后续在不同电脑更改，理论上我们需要一个库部署，一个库来存储我们的原始文件。这里我们通过建立不同的分支来实现。\n\n```bash\n$ git clone git@github.com:xxx/xxx.github.io.git\n$ git branch hexo\n$ git checkout hexo\n```\n\n​\t我们可以把hexo分支设置为默认分支，打开项目的settings->Branches->Default Branch更改即可。因为后续更改只会发生在hexo分支，master分支仅起部署作用。\n\n接着，我们操作Hexo：\n\n于hexo分支下，\n\n```bash\n$ hexo init  #只有空文件夹时需要这句代码\n$ npm install hexo-deployer-git\n$ hexo g  #generate,生成静态网页\n$ hexo s  #server,本地预览http://localhost:4000/\n```\n\n博客的配置文件为_config.yml，关于部署的配置如下：\n\n```\ndeploy:\n  type: git\n  repository: git@github.com:xxx/xxx.github.io.git\n  branch: master\n```\n\n其他配置参考注释。。\n\n重新生成部署：\n\n```bash\n$hexo clean\n$ hexo g\n$ hexo d  #deploy\n```\n\n此时，打开<https://xxx.github.io/>即可访问博客。\n\n开启写作之旅：\n\n```bash\n$ hexo n \"xxx\"  #new,命令执行后，在/source/_posts下回产生一个xxx.md文件\n```\n\n修改完后，push到hexo分支：\n\n```bash\n$ git add .\n$ git commit -m \"xxx\"\n$ git push origin hexo  #-f强行push\n```\n\n如需在其他机器写作，git clone下来即可\n\n### 坑点记录\n\n- **修改配置_config.yml文件时，记得配置项之前加空格**\n\n  比如：title: *<-这个地方必须有空格*Pamper'Blog\n\n- 当我们在多台机器上修改博客，产生修改不一致的情况时，可以强制某台机器本地同步git上的代码：\n\n```bash\n$ git fetch --all\n$ git reset --hard origin/hexo\n$ git pull\n\n$ git fetch origin hexo\n$ git log -p hexo..origin/hexo\n$ git merge origin/hexo\n```\n\n- 添加.gitignore忽略某些文件，如.DS_Store，.deploy_git，如果发现.gitignore没起作用，清除一下git缓存即可：\n\n```bash\n$ git rm -r --cached .\n$ git add .\n$ git commit -m \"update .gitignore\"\n$ git push origin hexo\n```\n\n # 四、主题配置\n\n​\t配置文件_config.yml中有主题配置选项theme，将心仪的主题clone到themes文件夹下，修改配置重新部署即可应用主题，主题基本配置同样主题文件夹下的 _config.yml配置。\n\n​\t本博客采用[yilia](https://github.com/litten/hexo-theme-yilia)主题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Hexo+GithubPages搭建博客","published":1,"updated":"2019-07-07T14:45:13.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2qv0007qsez0zmjgokw","content":"<p>​    本博客完整搭建流程</p>\n<a id=\"more\"></a>\n<h1 id=\"一、安装Node-js、Hexo\"><a href=\"#一、安装Node-js、Hexo\" class=\"headerlink\" title=\"一、安装Node.js、Hexo\"></a>一、安装Node.js、Hexo</h1><p>​    Ubuntu、Mac、Win下的安装都大同小异</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install node.js</span><br><span class=\"line\">$ sudo apt-get install npm   <span class=\"comment\">#一种包管理工具</span></span><br><span class=\"line\">$ sudo npm install -g hexo</span><br><span class=\"line\"></span><br><span class=\"line\">$ node -v</span><br><span class=\"line\">$ hexo -v  <span class=\"comment\">#输出相应的版本即安装成功</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"二、Git相关配置\"><a href=\"#二、Git相关配置\" class=\"headerlink\" title=\"二、Git相关配置\"></a>二、Git相关配置</h1><h2 id=\"1、创建一个username-github-io的repository\"><a href=\"#1、创建一个username-github-io的repository\" class=\"headerlink\" title=\"1、创建一个username.github.io的repository\"></a>1、创建一个<strong>username.github.io</strong>的repository</h2><h2 id=\"2、配置ssh-key\"><a href=\"#2、配置ssh-key\" class=\"headerlink\" title=\"2、配置ssh key\"></a>2、配置ssh key</h2><ul>\n<li>打开bash</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"xxxx@xx.xx\"</span> </span><br><span class=\"line\"><span class=\"comment\"># 一路回车</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>打开用户目录下的<em>~/.ssh/</em>目录，目录下文件id_rsa为私钥，id_rsa.pub为公钥。复制id_rsa.pub里面的内容</li>\n<li>打开Github-&gt;Settings-&gt;SSH and GPG keys-&gt;new SSH key，取好别名，粘贴秘钥，回到bash</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com    <span class=\"comment\">#如果输出hello。。。字样，表示配置成功</span></span><br></pre></td></tr></table></figure>\n<p>若同一电脑需要用到多个sshkey，则还需如下操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.xx -C <span class=\"string\">\"xxx@xx.xx\"</span>   <span class=\"comment\">#生成另外一个带别名的key</span></span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa.xx  <span class=\"comment\">#添加新的ssh key到ssh agent，其默认只读id_rsa</span></span><br><span class=\"line\">$ touch config  <span class=\"comment\">#创建多个key的配置文件</span></span><br></pre></td></tr></table></figure>\n<p>已同时配置gitlab和github的key为例，config文件中写入如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile ~.ssh/id_rsa.github</span><br><span class=\"line\"></span><br><span class=\"line\">Host gitlab</span><br><span class=\"line\">HostName gitlab.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile ~.ssh/id_rsa.gitlab</span><br></pre></td></tr></table></figure>\n<p>编写完成后同样可以如前所述 <em>“ssh -T xxx”</em> 检查是否配置成功</p>\n<blockquote>\n<p>遇到git push origin/hexo时提示：Please make sure you have the correct access rights and the repository exists.</p>\n<p>解决办法：操作一下~/.ssh目录下的known_hosts文件，mv known_hosts known_hosts.bat</p>\n</blockquote>\n<h2 id=\"3、Git常规配置\"><a href=\"#3、Git常规配置\" class=\"headerlink\" title=\"3、Git常规配置\"></a>3、Git常规配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --list     <span class=\"comment\">#查看config信息</span></span><br><span class=\"line\">$ git config --global user.name <span class=\"string\">\"xxx\"</span>    </span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"xxx@xxx.xx\"</span></span><br></pre></td></tr></table></figure>\n<p>如果须有某个文件夹下单独配置，–global改为–local即可</p>\n<h1 id=\"三、搭建博客开启写作之旅\"><a href=\"#三、搭建博客开启写作之旅\" class=\"headerlink\" title=\"三、搭建博客开启写作之旅\"></a>三、搭建博客开启写作之旅</h1><h3 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h3><p>​    Hexo搭建博客后部署到Github，如果我们需要把我们原始文件也存到Github便于我们后续在不同电脑更改，理论上我们需要一个库部署，一个库来存储我们的原始文件。这里我们通过建立不同的分支来实现。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:xxx/xxx.github.io.git</span><br><span class=\"line\">$ git branch hexo</span><br><span class=\"line\">$ git checkout hexo</span><br></pre></td></tr></table></figure>\n<p>​    我们可以把hexo分支设置为默认分支，打开项目的settings-&gt;Branches-&gt;Default Branch更改即可。因为后续更改只会发生在hexo分支，master分支仅起部署作用。</p>\n<p>接着，我们操作Hexo：</p>\n<p>于hexo分支下，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init  <span class=\"comment\">#只有空文件夹时需要这句代码</span></span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br><span class=\"line\">$ hexo g  <span class=\"comment\">#generate,生成静态网页</span></span><br><span class=\"line\">$ hexo s  <span class=\"comment\">#server,本地预览http://localhost:4000/</span></span><br></pre></td></tr></table></figure>\n<p>博客的配置文件为_config.yml，关于部署的配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:xxx/xxx.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>其他配置参考注释。。</p>\n<p>重新生成部署：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$hexo</span> clean</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d  <span class=\"comment\">#deploy</span></span><br></pre></td></tr></table></figure>\n<p>此时，打开<a href=\"https://xxx.github.io/\" target=\"_blank\" rel=\"noopener\">https://xxx.github.io/</a>即可访问博客。</p>\n<p>开启写作之旅：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo n <span class=\"string\">\"xxx\"</span>  <span class=\"comment\">#new,命令执行后，在/source/_posts下回产生一个xxx.md文件</span></span><br></pre></td></tr></table></figure>\n<p>修改完后，push到hexo分支：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">$ git push origin hexo  <span class=\"comment\">#-f强行push</span></span><br></pre></td></tr></table></figure>\n<p>如需在其他机器写作，git clone下来即可</p>\n<h3 id=\"坑点记录\"><a href=\"#坑点记录\" class=\"headerlink\" title=\"坑点记录\"></a>坑点记录</h3><ul>\n<li><p><strong>修改配置_config.yml文件时，记得配置项之前加空格</strong></p>\n<p>比如：title: <em>&lt;-这个地方必须有空格</em>Pamper’Blog</p>\n</li>\n<li><p>当我们在多台机器上修改博客，产生修改不一致的情况时，可以强制某台机器本地同步git上的代码：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch --all</span><br><span class=\"line\">$ git reset --hard origin/hexo</span><br><span class=\"line\">$ git pull</span><br><span class=\"line\"></span><br><span class=\"line\">$ git fetch origin hexo</span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -p hexo..origin/hexo</span><br><span class=\"line\">$ git merge origin/hexo</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加.gitignore忽略某些文件，如.DS_Store，.deploy_git，如果发现.gitignore没起作用，清除一下git缓存即可：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm -r --cached .</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"update .gitignore\"</span></span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n<h1 id=\"四、主题配置\"><a href=\"#四、主题配置\" class=\"headerlink\" title=\"四、主题配置\"></a>四、主题配置</h1><p>​    配置文件_config.yml中有主题配置选项theme，将心仪的主题clone到themes文件夹下，修改配置重新部署即可应用主题，主题基本配置同样主题文件夹下的 _config.yml配置。</p>\n<p>​    本博客采用<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">yilia</a>主题</p>\n","site":{"data":{}},"excerpt":"<p>​    本博客完整搭建流程</p>","more":"<h1 id=\"一、安装Node-js、Hexo\"><a href=\"#一、安装Node-js、Hexo\" class=\"headerlink\" title=\"一、安装Node.js、Hexo\"></a>一、安装Node.js、Hexo</h1><p>​    Ubuntu、Mac、Win下的安装都大同小异</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install node.js</span><br><span class=\"line\">$ sudo apt-get install npm   <span class=\"comment\">#一种包管理工具</span></span><br><span class=\"line\">$ sudo npm install -g hexo</span><br><span class=\"line\"></span><br><span class=\"line\">$ node -v</span><br><span class=\"line\">$ hexo -v  <span class=\"comment\">#输出相应的版本即安装成功</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"二、Git相关配置\"><a href=\"#二、Git相关配置\" class=\"headerlink\" title=\"二、Git相关配置\"></a>二、Git相关配置</h1><h2 id=\"1、创建一个username-github-io的repository\"><a href=\"#1、创建一个username-github-io的repository\" class=\"headerlink\" title=\"1、创建一个username.github.io的repository\"></a>1、创建一个<strong>username.github.io</strong>的repository</h2><h2 id=\"2、配置ssh-key\"><a href=\"#2、配置ssh-key\" class=\"headerlink\" title=\"2、配置ssh key\"></a>2、配置ssh key</h2><ul>\n<li>打开bash</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"xxxx@xx.xx\"</span> </span><br><span class=\"line\"><span class=\"comment\"># 一路回车</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>打开用户目录下的<em>~/.ssh/</em>目录，目录下文件id_rsa为私钥，id_rsa.pub为公钥。复制id_rsa.pub里面的内容</li>\n<li>打开Github-&gt;Settings-&gt;SSH and GPG keys-&gt;new SSH key，取好别名，粘贴秘钥，回到bash</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com    <span class=\"comment\">#如果输出hello。。。字样，表示配置成功</span></span><br></pre></td></tr></table></figure>\n<p>若同一电脑需要用到多个sshkey，则还需如下操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.xx -C <span class=\"string\">\"xxx@xx.xx\"</span>   <span class=\"comment\">#生成另外一个带别名的key</span></span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa.xx  <span class=\"comment\">#添加新的ssh key到ssh agent，其默认只读id_rsa</span></span><br><span class=\"line\">$ touch config  <span class=\"comment\">#创建多个key的配置文件</span></span><br></pre></td></tr></table></figure>\n<p>已同时配置gitlab和github的key为例，config文件中写入如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host github</span><br><span class=\"line\">HostName github.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile ~.ssh/id_rsa.github</span><br><span class=\"line\"></span><br><span class=\"line\">Host gitlab</span><br><span class=\"line\">HostName gitlab.com</span><br><span class=\"line\">User git</span><br><span class=\"line\">IdentityFile ~.ssh/id_rsa.gitlab</span><br></pre></td></tr></table></figure>\n<p>编写完成后同样可以如前所述 <em>“ssh -T xxx”</em> 检查是否配置成功</p>\n<blockquote>\n<p>遇到git push origin/hexo时提示：Please make sure you have the correct access rights and the repository exists.</p>\n<p>解决办法：操作一下~/.ssh目录下的known_hosts文件，mv known_hosts known_hosts.bat</p>\n</blockquote>\n<h2 id=\"3、Git常规配置\"><a href=\"#3、Git常规配置\" class=\"headerlink\" title=\"3、Git常规配置\"></a>3、Git常规配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --list     <span class=\"comment\">#查看config信息</span></span><br><span class=\"line\">$ git config --global user.name <span class=\"string\">\"xxx\"</span>    </span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"xxx@xxx.xx\"</span></span><br></pre></td></tr></table></figure>\n<p>如果须有某个文件夹下单独配置，–global改为–local即可</p>\n<h1 id=\"三、搭建博客开启写作之旅\"><a href=\"#三、搭建博客开启写作之旅\" class=\"headerlink\" title=\"三、搭建博客开启写作之旅\"></a>三、搭建博客开启写作之旅</h1><h3 id=\"搭建流程\"><a href=\"#搭建流程\" class=\"headerlink\" title=\"搭建流程\"></a>搭建流程</h3><p>​    Hexo搭建博客后部署到Github，如果我们需要把我们原始文件也存到Github便于我们后续在不同电脑更改，理论上我们需要一个库部署，一个库来存储我们的原始文件。这里我们通过建立不同的分支来实现。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:xxx/xxx.github.io.git</span><br><span class=\"line\">$ git branch hexo</span><br><span class=\"line\">$ git checkout hexo</span><br></pre></td></tr></table></figure>\n<p>​    我们可以把hexo分支设置为默认分支，打开项目的settings-&gt;Branches-&gt;Default Branch更改即可。因为后续更改只会发生在hexo分支，master分支仅起部署作用。</p>\n<p>接着，我们操作Hexo：</p>\n<p>于hexo分支下，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init  <span class=\"comment\">#只有空文件夹时需要这句代码</span></span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br><span class=\"line\">$ hexo g  <span class=\"comment\">#generate,生成静态网页</span></span><br><span class=\"line\">$ hexo s  <span class=\"comment\">#server,本地预览http://localhost:4000/</span></span><br></pre></td></tr></table></figure>\n<p>博客的配置文件为_config.yml，关于部署的配置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:xxx/xxx.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>其他配置参考注释。。</p>\n<p>重新生成部署：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$hexo</span> clean</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d  <span class=\"comment\">#deploy</span></span><br></pre></td></tr></table></figure>\n<p>此时，打开<a href=\"https://xxx.github.io/\" target=\"_blank\" rel=\"noopener\">https://xxx.github.io/</a>即可访问博客。</p>\n<p>开启写作之旅：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo n <span class=\"string\">\"xxx\"</span>  <span class=\"comment\">#new,命令执行后，在/source/_posts下回产生一个xxx.md文件</span></span><br></pre></td></tr></table></figure>\n<p>修改完后，push到hexo分支：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"xxx\"</span></span><br><span class=\"line\">$ git push origin hexo  <span class=\"comment\">#-f强行push</span></span><br></pre></td></tr></table></figure>\n<p>如需在其他机器写作，git clone下来即可</p>\n<h3 id=\"坑点记录\"><a href=\"#坑点记录\" class=\"headerlink\" title=\"坑点记录\"></a>坑点记录</h3><ul>\n<li><p><strong>修改配置_config.yml文件时，记得配置项之前加空格</strong></p>\n<p>比如：title: <em>&lt;-这个地方必须有空格</em>Pamper’Blog</p>\n</li>\n<li><p>当我们在多台机器上修改博客，产生修改不一致的情况时，可以强制某台机器本地同步git上的代码：</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch --all</span><br><span class=\"line\">$ git reset --hard origin/hexo</span><br><span class=\"line\">$ git pull</span><br><span class=\"line\"></span><br><span class=\"line\">$ git fetch origin hexo</span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -p hexo..origin/hexo</span><br><span class=\"line\">$ git merge origin/hexo</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加.gitignore忽略某些文件，如.DS_Store，.deploy_git，如果发现.gitignore没起作用，清除一下git缓存即可：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm -r --cached .</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"update .gitignore\"</span></span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n<h1 id=\"四、主题配置\"><a href=\"#四、主题配置\" class=\"headerlink\" title=\"四、主题配置\"></a>四、主题配置</h1><p>​    配置文件_config.yml中有主题配置选项theme，将心仪的主题clone到themes文件夹下，修改配置重新部署即可应用主题，主题基本配置同样主题文件夹下的 _config.yml配置。</p>\n<p>​    本博客采用<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">yilia</a>主题</p>"},{"title":"面试总结","date":"2018-09-19T14:09:54.000Z","_content":"\n\n\n不同面试官的侧重点不一样，有的比较看重基础，有的比较看重项目经验，你的xxx还是不错的。。\n\n今天我们就聊到这里。。。你先回去等通知。。\n\n<!--more-->\n\n### 关于数据结构\n\n二分查找\n\n给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数\n\n判断一棵树是否是另一棵树的子树\n\n链表反转\n\n归并排序\n\nString To Int\n\n考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index<s.length()\n\n求第k大的数(复杂度是多少？时间复杂度O(n)，空间复杂度O(1))\n\n### 关于算法\n\n#### 算法原理：\n\nXGBoost原理(如何并行)？\n\nXGBoost和LightGBM区别、和RF区别？\n\nRF原理？\n\nSVM的核函数有哪些？\n\n> 线性核、多项式核、径向基核（RBF）、傅里叶核、样条核、Sigmoid核\n\n树如何分裂？分裂后熵应该变大还是变小？\n\n熵的定义和意义、怎么计算熵？\n\n>我们一般使用**信息量**来进行**不确定性**的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。\n>\n>> 对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。\n>\n>**(信息)熵**定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。\n>\n>> 1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$\n>>\n>> 多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$\n>>\n>> > 随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0<H(X)<log(n)$)\n>\n>**条件熵**：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。\n>\n>> $H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$\n>>\n>> $H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$\n>>\n>> $H(Y|X)=H(X,Y)-H(X)$\n>\n>**相对熵**（KL散度）：两个概率分布之间的差异。\n>\n>> $D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)\n>\n>**交叉熵**：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。\n>\n>> $H(p,q)=-\\sum_xp(x)logq(x)$\n>>\n>> $H(p,q)=H(p)+D_{KL}(p||q)$\n>\n>熵与方差的关系(在大部分分布的情况下正相关？)\n>\n>**信息增益**：熵-条件熵\n>\n>**互信息**：联合分布于乘积分布之间的相对熵，熵-条件熵\n>\n>> $I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$\n\n二分类的label，数据如何分布熵最大？\n\n> 一半一半，均匀分布的时候\n\nBootstrap是什么？\n\n> 有放回抽样?\n\nBagging和Boosting区别、Stacking？\n\n> bagging：如果各个单独的模型产生的误差是不相关的，那么bagging后的平均误差可以仅仅通过M个版本求平均的方法减小M倍，但是实际应用中，误差通常是高度相关的。\n>\n> boosting：基分类器是顺序训练的，每个基分类器使用数据集的一个加权形式进行训练，其中与每个数据点相关的权系数依赖于前一个分类器的表现。被一个基分类器误分类的点在训练序列的下一个分类器时会被赋予更高的权重。Adaboost训练完毕后通过加权投票的方法进行组合。\n\n协方差矩阵？\n\n>标准差和方差都是用来描述一维数据，协方差是一种用来度量两个随机变量关系的统计量，是一个对称的方阵，对角线上的因子就是变量的方差。\n\npearson相关系数(如何定义)？\n\n> 协方差/标准差乘积\n\n评价指标有哪些(分类、回归)？\n\n- R-Squared：$R^2 = 1 - \\sum(y-\\hat{y})^2/\\sum(y-\\bar{y})^2$，衡量回归方程与真实样本输出之间的相似程度。\n\n  反映的是大概有多准，因为随着样本数增加R-Squared必然增加，无法真正定量说明准确程度。单独看R-Square并不能推断出特征是否有意义。应该使用校正决定系数（Adjusted R-Squared）\n\nAUC怎么计算？ROC曲线怎么画？\n\n降维的方法有哪些？\n\n>缺失比例过滤\n>\n>低方差滤波（方差与信息熵关系）\n>\n>高相关滤波（注意保留与目标变量存在高相关性的列，高相关性的特征会使得线性回归逻辑回归的效果变差）\n>\n>树模型特征重要性\n>\n>前向特征选择，反向特征消除（加减特征看效果。。）\n>\n>因子分析（按相关性分组）\n>\n>PCA、ICA、IOSMAP、t-SNE、UMAP\n>\n>AutoEncoder、Word2Vec\n\n如何做异常检测？\n\n如何判断一个特征是否有用？\n\n如何判断数据是线性的？\n\n> 线性分类模型是指决策面是输入向量X的线性函数。定义为D维输入空间的D-1维超平面。如果数据集可以被线性决策面精确地分类，该数据集是线性可分的。\n>\n> 判断数据集是否线性可分：低维直接画图判断，高维检查凸包是否相交。\n\n线性模型和非线性模型的区别？\n\n>决策边界是线性，自变量（单变量时）x是否只受一个w影响，是w的线性函数，特征交叉是非线性模型（基函数非线性）。\n\nCTR预估中如何处理样本不平衡的问题？\n\n如何判断采样是否有效？\n\nTextCNN原理？\n\nWord2Vec原理？\n\nFastText原理？\n\nTFIDF，怎么计算，怎么改进？\n\nTFIDF，有什么缺点？\n\n> 优点：简单快速，容易理解。缺点：用词频来衡量文章中的一个词的重要性不够全面，有时候重要的词出现的不够多，而且这种计算无法体现位置信息，无法体现词在上下文中的重要性。如需体现词的上下文结构，需要使用Word2Vec。\n\nN-gram怎么平滑？\n\n拉普拉斯平滑？贝叶斯平滑？\n\n聚类算法？硬核聚类软核聚类？\n\n>只能有一个类别的叫硬核聚类，kmeans是硬核，GMM是软核\n\n广义线性模型的理解？\n\n> 符合指数分布族的一般模型\n\n最小二乘和最大似然的关系？\n\n>最小二乘：找到一组估计值，使得实际值与估计值距离最小                                                \n>\n>最大似然：寻找一组参数估计值，使得已发生的样本概率最大\n>\n>最小二乘是高斯噪声模型假设下的最大似然解？\n>\n>对于二分类问题，不适宜用最小平方法，\n\n激活函数有哪些？ReLU和Sigmoid的区别有哪些？\n\n参数化方法和非参数化方法？\n\n> 线性回归是参数化的，kNN是非参数化的（基于记忆的方法）\n\n逻辑回归为什么不用squareloss？\n\n>\n\n各种范数？\n\n> $L_p$范数：向量各个元素绝对值的$p$次方求和，然后求$1/p$次方。\n>\n> $L_1$、$L_2$:向量各个元素绝对值之和，平方和然后求平方根。\n\n各种距离？\n\n> 曼哈顿距离、欧式距离、余弦距离、明式距离、pearson相关系数、\n\nSVM数据量大时为什么速度慢？\n\n> 大量的非支持向量参与训练过程，从而进行了大量的二次规划计算，导致分类计算量大、分类速度慢\n\nSVM核函数如何选择？\n\n> 1、样本特征很多时，特征的维数很高，往往可能线性可分，可以考虑线性核函数\n>\n> 2、样本数量很多，特征较少时，可以手动添加一些特征，在考虑线性核函数\n>\n> 3、样本特征维度不高，样本数量也不多，考虑高斯核函数（RBF核（指数核函数，拉普拉斯核函数）的一种）\n\n#### 手推公式\n\nLR\n\nSVM(适用于特征维度多于样本数的情况？)\n\nPCA\n\nXGB\n\n### 其他\n\n##### SQL题\n\n一个表包含Name，Subject，Score三个字段，输出总分前十名的同学\n\n```sql\nselect Name,sum(Score) as SumScore from A group by Name order by SumScore limit 10; ?\n```\n\n##### 编程语言题\n\nPython dict排序\n\n```python\nsorted(d.items(),key = lambda d:d[0])\nsorted(d.items(),key = lambda d:d[1],reverse=True)\n```\n\nPython 有哪些数据类型结构？List和Dict的区别？\n\n> list,dict,set,tuple\n>\n> collections(defaultdict、counter、deque、namedtuple、enum.Enum)\n>\n> [pythonGitbook](https://eastlakeside.gitbooks.io/interpy-zh/content/collections/collections.html)\n\n> dict:\n>\n> - 查找和插入速度极快，且不会随着key的增加而增加\n> - 占用大量内存\n>\n> list：\n>\n> - 查找和插入时间随着元素的增加而增加\n> - 占用空间小，浪费内存少\n>\n> > dict的key必须是不可变对象，dict根据key计算value的存储位置（hash算法）\n\nPython异常捕获？\n\n```python\ntry:\n    xxx\n    raise Exception\nexcept Exception as e:\n    print(type(e))  ##捕捉到异常对象执行\nelse:\n\tprint(1) ##不抛出异常执行    \nfinally:\n    print(2)  ##无论如何都执行\n```\n\nPython生成器？\n\n> 变循环，边计算的结构，节省空间（如果使用列表内存占用太大）\n\nPython map、reduce函数？\n\n```python\ndef char2num(s):\n    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]\ndef str2int(s):\n    return reduce(lambda x,y:x*10+y,map(char2num,s))\n#map\n#reduce 把结果继续和下一个元素做累积运算\n```\n\n##### 大数据相关题\n\n介绍下HDFS？\n\n说下MapReduce原理？\n\n高可用机制和联邦机制是什么？\n\n高可用机制的备用是冷的还是热的？为什么？\n\n如何对大文件中的数字排序？(文件很大机器内存有限)\n\n爬取大量URL时，如何判断这个URL是否已经爬过？（set？布隆过滤器？）","source":"_posts/面试总结.md","raw":"---\ntitle: 面试总结\ndate: 2018-09-19 22:09:54\ntags: [notes,面试总结]\n---\n\n\n\n不同面试官的侧重点不一样，有的比较看重基础，有的比较看重项目经验，你的xxx还是不错的。。\n\n今天我们就聊到这里。。。你先回去等通知。。\n\n<!--more-->\n\n### 关于数据结构\n\n二分查找\n\n给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数\n\n判断一棵树是否是另一棵树的子树\n\n链表反转\n\n归并排序\n\nString To Int\n\n考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index<s.length()\n\n求第k大的数(复杂度是多少？时间复杂度O(n)，空间复杂度O(1))\n\n### 关于算法\n\n#### 算法原理：\n\nXGBoost原理(如何并行)？\n\nXGBoost和LightGBM区别、和RF区别？\n\nRF原理？\n\nSVM的核函数有哪些？\n\n> 线性核、多项式核、径向基核（RBF）、傅里叶核、样条核、Sigmoid核\n\n树如何分裂？分裂后熵应该变大还是变小？\n\n熵的定义和意义、怎么计算熵？\n\n>我们一般使用**信息量**来进行**不确定性**的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。\n>\n>> 对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。\n>\n>**(信息)熵**定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。\n>\n>> 1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$\n>>\n>> 多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$\n>>\n>> > 随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0<H(X)<log(n)$)\n>\n>**条件熵**：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。\n>\n>> $H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$\n>>\n>> $H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$\n>>\n>> $H(Y|X)=H(X,Y)-H(X)$\n>\n>**相对熵**（KL散度）：两个概率分布之间的差异。\n>\n>> $D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)\n>\n>**交叉熵**：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。\n>\n>> $H(p,q)=-\\sum_xp(x)logq(x)$\n>>\n>> $H(p,q)=H(p)+D_{KL}(p||q)$\n>\n>熵与方差的关系(在大部分分布的情况下正相关？)\n>\n>**信息增益**：熵-条件熵\n>\n>**互信息**：联合分布于乘积分布之间的相对熵，熵-条件熵\n>\n>> $I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$\n\n二分类的label，数据如何分布熵最大？\n\n> 一半一半，均匀分布的时候\n\nBootstrap是什么？\n\n> 有放回抽样?\n\nBagging和Boosting区别、Stacking？\n\n> bagging：如果各个单独的模型产生的误差是不相关的，那么bagging后的平均误差可以仅仅通过M个版本求平均的方法减小M倍，但是实际应用中，误差通常是高度相关的。\n>\n> boosting：基分类器是顺序训练的，每个基分类器使用数据集的一个加权形式进行训练，其中与每个数据点相关的权系数依赖于前一个分类器的表现。被一个基分类器误分类的点在训练序列的下一个分类器时会被赋予更高的权重。Adaboost训练完毕后通过加权投票的方法进行组合。\n\n协方差矩阵？\n\n>标准差和方差都是用来描述一维数据，协方差是一种用来度量两个随机变量关系的统计量，是一个对称的方阵，对角线上的因子就是变量的方差。\n\npearson相关系数(如何定义)？\n\n> 协方差/标准差乘积\n\n评价指标有哪些(分类、回归)？\n\n- R-Squared：$R^2 = 1 - \\sum(y-\\hat{y})^2/\\sum(y-\\bar{y})^2$，衡量回归方程与真实样本输出之间的相似程度。\n\n  反映的是大概有多准，因为随着样本数增加R-Squared必然增加，无法真正定量说明准确程度。单独看R-Square并不能推断出特征是否有意义。应该使用校正决定系数（Adjusted R-Squared）\n\nAUC怎么计算？ROC曲线怎么画？\n\n降维的方法有哪些？\n\n>缺失比例过滤\n>\n>低方差滤波（方差与信息熵关系）\n>\n>高相关滤波（注意保留与目标变量存在高相关性的列，高相关性的特征会使得线性回归逻辑回归的效果变差）\n>\n>树模型特征重要性\n>\n>前向特征选择，反向特征消除（加减特征看效果。。）\n>\n>因子分析（按相关性分组）\n>\n>PCA、ICA、IOSMAP、t-SNE、UMAP\n>\n>AutoEncoder、Word2Vec\n\n如何做异常检测？\n\n如何判断一个特征是否有用？\n\n如何判断数据是线性的？\n\n> 线性分类模型是指决策面是输入向量X的线性函数。定义为D维输入空间的D-1维超平面。如果数据集可以被线性决策面精确地分类，该数据集是线性可分的。\n>\n> 判断数据集是否线性可分：低维直接画图判断，高维检查凸包是否相交。\n\n线性模型和非线性模型的区别？\n\n>决策边界是线性，自变量（单变量时）x是否只受一个w影响，是w的线性函数，特征交叉是非线性模型（基函数非线性）。\n\nCTR预估中如何处理样本不平衡的问题？\n\n如何判断采样是否有效？\n\nTextCNN原理？\n\nWord2Vec原理？\n\nFastText原理？\n\nTFIDF，怎么计算，怎么改进？\n\nTFIDF，有什么缺点？\n\n> 优点：简单快速，容易理解。缺点：用词频来衡量文章中的一个词的重要性不够全面，有时候重要的词出现的不够多，而且这种计算无法体现位置信息，无法体现词在上下文中的重要性。如需体现词的上下文结构，需要使用Word2Vec。\n\nN-gram怎么平滑？\n\n拉普拉斯平滑？贝叶斯平滑？\n\n聚类算法？硬核聚类软核聚类？\n\n>只能有一个类别的叫硬核聚类，kmeans是硬核，GMM是软核\n\n广义线性模型的理解？\n\n> 符合指数分布族的一般模型\n\n最小二乘和最大似然的关系？\n\n>最小二乘：找到一组估计值，使得实际值与估计值距离最小                                                \n>\n>最大似然：寻找一组参数估计值，使得已发生的样本概率最大\n>\n>最小二乘是高斯噪声模型假设下的最大似然解？\n>\n>对于二分类问题，不适宜用最小平方法，\n\n激活函数有哪些？ReLU和Sigmoid的区别有哪些？\n\n参数化方法和非参数化方法？\n\n> 线性回归是参数化的，kNN是非参数化的（基于记忆的方法）\n\n逻辑回归为什么不用squareloss？\n\n>\n\n各种范数？\n\n> $L_p$范数：向量各个元素绝对值的$p$次方求和，然后求$1/p$次方。\n>\n> $L_1$、$L_2$:向量各个元素绝对值之和，平方和然后求平方根。\n\n各种距离？\n\n> 曼哈顿距离、欧式距离、余弦距离、明式距离、pearson相关系数、\n\nSVM数据量大时为什么速度慢？\n\n> 大量的非支持向量参与训练过程，从而进行了大量的二次规划计算，导致分类计算量大、分类速度慢\n\nSVM核函数如何选择？\n\n> 1、样本特征很多时，特征的维数很高，往往可能线性可分，可以考虑线性核函数\n>\n> 2、样本数量很多，特征较少时，可以手动添加一些特征，在考虑线性核函数\n>\n> 3、样本特征维度不高，样本数量也不多，考虑高斯核函数（RBF核（指数核函数，拉普拉斯核函数）的一种）\n\n#### 手推公式\n\nLR\n\nSVM(适用于特征维度多于样本数的情况？)\n\nPCA\n\nXGB\n\n### 其他\n\n##### SQL题\n\n一个表包含Name，Subject，Score三个字段，输出总分前十名的同学\n\n```sql\nselect Name,sum(Score) as SumScore from A group by Name order by SumScore limit 10; ?\n```\n\n##### 编程语言题\n\nPython dict排序\n\n```python\nsorted(d.items(),key = lambda d:d[0])\nsorted(d.items(),key = lambda d:d[1],reverse=True)\n```\n\nPython 有哪些数据类型结构？List和Dict的区别？\n\n> list,dict,set,tuple\n>\n> collections(defaultdict、counter、deque、namedtuple、enum.Enum)\n>\n> [pythonGitbook](https://eastlakeside.gitbooks.io/interpy-zh/content/collections/collections.html)\n\n> dict:\n>\n> - 查找和插入速度极快，且不会随着key的增加而增加\n> - 占用大量内存\n>\n> list：\n>\n> - 查找和插入时间随着元素的增加而增加\n> - 占用空间小，浪费内存少\n>\n> > dict的key必须是不可变对象，dict根据key计算value的存储位置（hash算法）\n\nPython异常捕获？\n\n```python\ntry:\n    xxx\n    raise Exception\nexcept Exception as e:\n    print(type(e))  ##捕捉到异常对象执行\nelse:\n\tprint(1) ##不抛出异常执行    \nfinally:\n    print(2)  ##无论如何都执行\n```\n\nPython生成器？\n\n> 变循环，边计算的结构，节省空间（如果使用列表内存占用太大）\n\nPython map、reduce函数？\n\n```python\ndef char2num(s):\n    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]\ndef str2int(s):\n    return reduce(lambda x,y:x*10+y,map(char2num,s))\n#map\n#reduce 把结果继续和下一个元素做累积运算\n```\n\n##### 大数据相关题\n\n介绍下HDFS？\n\n说下MapReduce原理？\n\n高可用机制和联邦机制是什么？\n\n高可用机制的备用是冷的还是热的？为什么？\n\n如何对大文件中的数字排序？(文件很大机器内存有限)\n\n爬取大量URL时，如何判断这个URL是否已经爬过？（set？布隆过滤器？）","slug":"面试总结","published":1,"updated":"2018-10-09T16:53:26.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2rb000hqsezlczibg2u","content":"<p>不同面试官的侧重点不一样，有的比较看重基础，有的比较看重项目经验，你的xxx还是不错的。。</p>\n<p>今天我们就聊到这里。。。你先回去等通知。。</p>\n<a id=\"more\"></a>\n<h3 id=\"关于数据结构\"><a href=\"#关于数据结构\" class=\"headerlink\" title=\"关于数据结构\"></a>关于数据结构</h3><p>二分查找</p>\n<p>给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数</p>\n<p>判断一棵树是否是另一棵树的子树</p>\n<p>链表反转</p>\n<p>归并排序</p>\n<p>String To Int</p>\n<p>考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index&lt;s.length()</p>\n<p>求第k大的数(复杂度是多少？时间复杂度O(n)，空间复杂度O(1))</p>\n<h3 id=\"关于算法\"><a href=\"#关于算法\" class=\"headerlink\" title=\"关于算法\"></a>关于算法</h3><h4 id=\"算法原理：\"><a href=\"#算法原理：\" class=\"headerlink\" title=\"算法原理：\"></a>算法原理：</h4><p>XGBoost原理(如何并行)？</p>\n<p>XGBoost和LightGBM区别、和RF区别？</p>\n<p>RF原理？</p>\n<p>SVM的核函数有哪些？</p>\n<blockquote>\n<p>线性核、多项式核、径向基核（RBF）、傅里叶核、样条核、Sigmoid核</p>\n</blockquote>\n<p>树如何分裂？分裂后熵应该变大还是变小？</p>\n<p>熵的定义和意义、怎么计算熵？</p>\n<blockquote>\n<p>我们一般使用<strong>信息量</strong>来进行<strong>不确定性</strong>的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。</p>\n<blockquote>\n<p>对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。</p>\n</blockquote>\n<p><strong>(信息)熵</strong>定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。</p>\n<blockquote>\n<p>1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$</p>\n<p>多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$</p>\n<blockquote>\n<p>随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0&lt;H(X)&lt;log(n)$)</p>\n</blockquote>\n</blockquote>\n<p><strong>条件熵</strong>：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。</p>\n<blockquote>\n<p>$H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$</p>\n<p>$H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$</p>\n<p>$H(Y|X)=H(X,Y)-H(X)$</p>\n</blockquote>\n<p><strong>相对熵</strong>（KL散度）：两个概率分布之间的差异。</p>\n<blockquote>\n<p>$D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)</p>\n</blockquote>\n<p><strong>交叉熵</strong>：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。</p>\n<blockquote>\n<p>$H(p,q)=-\\sum_xp(x)logq(x)$</p>\n<p>$H(p,q)=H(p)+D_{KL}(p||q)$</p>\n</blockquote>\n<p>熵与方差的关系(在大部分分布的情况下正相关？)</p>\n<p><strong>信息增益</strong>：熵-条件熵</p>\n<p><strong>互信息</strong>：联合分布于乘积分布之间的相对熵，熵-条件熵</p>\n<blockquote>\n<p>$I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$</p>\n</blockquote>\n</blockquote>\n<p>二分类的label，数据如何分布熵最大？</p>\n<blockquote>\n<p>一半一半，均匀分布的时候</p>\n</blockquote>\n<p>Bootstrap是什么？</p>\n<blockquote>\n<p>有放回抽样?</p>\n</blockquote>\n<p>Bagging和Boosting区别、Stacking？</p>\n<blockquote>\n<p>bagging：如果各个单独的模型产生的误差是不相关的，那么bagging后的平均误差可以仅仅通过M个版本求平均的方法减小M倍，但是实际应用中，误差通常是高度相关的。</p>\n<p>boosting：基分类器是顺序训练的，每个基分类器使用数据集的一个加权形式进行训练，其中与每个数据点相关的权系数依赖于前一个分类器的表现。被一个基分类器误分类的点在训练序列的下一个分类器时会被赋予更高的权重。Adaboost训练完毕后通过加权投票的方法进行组合。</p>\n</blockquote>\n<p>协方差矩阵？</p>\n<blockquote>\n<p>标准差和方差都是用来描述一维数据，协方差是一种用来度量两个随机变量关系的统计量，是一个对称的方阵，对角线上的因子就是变量的方差。</p>\n</blockquote>\n<p>pearson相关系数(如何定义)？</p>\n<blockquote>\n<p>协方差/标准差乘积</p>\n</blockquote>\n<p>评价指标有哪些(分类、回归)？</p>\n<ul>\n<li><p>R-Squared：$R^2 = 1 - \\sum(y-\\hat{y})^2/\\sum(y-\\bar{y})^2$，衡量回归方程与真实样本输出之间的相似程度。</p>\n<p>反映的是大概有多准，因为随着样本数增加R-Squared必然增加，无法真正定量说明准确程度。单独看R-Square并不能推断出特征是否有意义。应该使用校正决定系数（Adjusted R-Squared）</p>\n</li>\n</ul>\n<p>AUC怎么计算？ROC曲线怎么画？</p>\n<p>降维的方法有哪些？</p>\n<blockquote>\n<p>缺失比例过滤</p>\n<p>低方差滤波（方差与信息熵关系）</p>\n<p>高相关滤波（注意保留与目标变量存在高相关性的列，高相关性的特征会使得线性回归逻辑回归的效果变差）</p>\n<p>树模型特征重要性</p>\n<p>前向特征选择，反向特征消除（加减特征看效果。。）</p>\n<p>因子分析（按相关性分组）</p>\n<p>PCA、ICA、IOSMAP、t-SNE、UMAP</p>\n<p>AutoEncoder、Word2Vec</p>\n</blockquote>\n<p>如何做异常检测？</p>\n<p>如何判断一个特征是否有用？</p>\n<p>如何判断数据是线性的？</p>\n<blockquote>\n<p>线性分类模型是指决策面是输入向量X的线性函数。定义为D维输入空间的D-1维超平面。如果数据集可以被线性决策面精确地分类，该数据集是线性可分的。</p>\n<p>判断数据集是否线性可分：低维直接画图判断，高维检查凸包是否相交。</p>\n</blockquote>\n<p>线性模型和非线性模型的区别？</p>\n<blockquote>\n<p>决策边界是线性，自变量（单变量时）x是否只受一个w影响，是w的线性函数，特征交叉是非线性模型（基函数非线性）。</p>\n</blockquote>\n<p>CTR预估中如何处理样本不平衡的问题？</p>\n<p>如何判断采样是否有效？</p>\n<p>TextCNN原理？</p>\n<p>Word2Vec原理？</p>\n<p>FastText原理？</p>\n<p>TFIDF，怎么计算，怎么改进？</p>\n<p>TFIDF，有什么缺点？</p>\n<blockquote>\n<p>优点：简单快速，容易理解。缺点：用词频来衡量文章中的一个词的重要性不够全面，有时候重要的词出现的不够多，而且这种计算无法体现位置信息，无法体现词在上下文中的重要性。如需体现词的上下文结构，需要使用Word2Vec。</p>\n</blockquote>\n<p>N-gram怎么平滑？</p>\n<p>拉普拉斯平滑？贝叶斯平滑？</p>\n<p>聚类算法？硬核聚类软核聚类？</p>\n<blockquote>\n<p>只能有一个类别的叫硬核聚类，kmeans是硬核，GMM是软核</p>\n</blockquote>\n<p>广义线性模型的理解？</p>\n<blockquote>\n<p>符合指数分布族的一般模型</p>\n</blockquote>\n<p>最小二乘和最大似然的关系？</p>\n<blockquote>\n<p>最小二乘：找到一组估计值，使得实际值与估计值距离最小                                                </p>\n<p>最大似然：寻找一组参数估计值，使得已发生的样本概率最大</p>\n<p>最小二乘是高斯噪声模型假设下的最大似然解？</p>\n<p>对于二分类问题，不适宜用最小平方法，</p>\n</blockquote>\n<p>激活函数有哪些？ReLU和Sigmoid的区别有哪些？</p>\n<p>参数化方法和非参数化方法？</p>\n<blockquote>\n<p>线性回归是参数化的，kNN是非参数化的（基于记忆的方法）</p>\n</blockquote>\n<p>逻辑回归为什么不用squareloss？</p>\n<blockquote>\n</blockquote>\n<p>各种范数？</p>\n<blockquote>\n<p>$L_p$范数：向量各个元素绝对值的$p$次方求和，然后求$1/p$次方。</p>\n<p>$L_1$、$L_2$:向量各个元素绝对值之和，平方和然后求平方根。</p>\n</blockquote>\n<p>各种距离？</p>\n<blockquote>\n<p>曼哈顿距离、欧式距离、余弦距离、明式距离、pearson相关系数、</p>\n</blockquote>\n<p>SVM数据量大时为什么速度慢？</p>\n<blockquote>\n<p>大量的非支持向量参与训练过程，从而进行了大量的二次规划计算，导致分类计算量大、分类速度慢</p>\n</blockquote>\n<p>SVM核函数如何选择？</p>\n<blockquote>\n<p>1、样本特征很多时，特征的维数很高，往往可能线性可分，可以考虑线性核函数</p>\n<p>2、样本数量很多，特征较少时，可以手动添加一些特征，在考虑线性核函数</p>\n<p>3、样本特征维度不高，样本数量也不多，考虑高斯核函数（RBF核（指数核函数，拉普拉斯核函数）的一种）</p>\n</blockquote>\n<h4 id=\"手推公式\"><a href=\"#手推公式\" class=\"headerlink\" title=\"手推公式\"></a>手推公式</h4><p>LR</p>\n<p>SVM(适用于特征维度多于样本数的情况？)</p>\n<p>PCA</p>\n<p>XGB</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h5 id=\"SQL题\"><a href=\"#SQL题\" class=\"headerlink\" title=\"SQL题\"></a>SQL题</h5><p>一个表包含Name，Subject，Score三个字段，输出总分前十名的同学</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">Name</span>,<span class=\"keyword\">sum</span>(Score) <span class=\"keyword\">as</span> SumScore <span class=\"keyword\">from</span> A <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">Name</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> SumScore <span class=\"keyword\">limit</span> <span class=\"number\">10</span>; ?</span><br></pre></td></tr></table></figure>\n<h5 id=\"编程语言题\"><a href=\"#编程语言题\" class=\"headerlink\" title=\"编程语言题\"></a>编程语言题</h5><p>Python dict排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sorted(d.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">0</span>])</span><br><span class=\"line\">sorted(d.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">1</span>],reverse=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>Python 有哪些数据类型结构？List和Dict的区别？</p>\n<blockquote>\n<p>list,dict,set,tuple</p>\n<p>collections(defaultdict、counter、deque、namedtuple、enum.Enum)</p>\n<p><a href=\"https://eastlakeside.gitbooks.io/interpy-zh/content/collections/collections.html\" target=\"_blank\" rel=\"noopener\">pythonGitbook</a></p>\n</blockquote>\n<blockquote>\n<p>dict:</p>\n<ul>\n<li>查找和插入速度极快，且不会随着key的增加而增加</li>\n<li>占用大量内存</li>\n</ul>\n<p>list：</p>\n<ul>\n<li>查找和插入时间随着元素的增加而增加</li>\n<li>占用空间小，浪费内存少</li>\n</ul>\n<blockquote>\n<p>dict的key必须是不可变对象，dict根据key计算value的存储位置（hash算法）</p>\n</blockquote>\n</blockquote>\n<p>Python异常捕获？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    xxx</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> Exception</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(type(e))  <span class=\"comment\">##捕捉到异常对象执行</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\tprint(<span class=\"number\">1</span>) <span class=\"comment\">##不抛出异常执行    </span></span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    print(<span class=\"number\">2</span>)  <span class=\"comment\">##无论如何都执行</span></span><br></pre></td></tr></table></figure>\n<p>Python生成器？</p>\n<blockquote>\n<p>变循环，边计算的结构，节省空间（如果使用列表内存占用太大）</p>\n</blockquote>\n<p>Python map、reduce函数？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">char2num</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"string\">'0'</span>: <span class=\"number\">0</span>, <span class=\"string\">'1'</span>: <span class=\"number\">1</span>, <span class=\"string\">'2'</span>: <span class=\"number\">2</span>, <span class=\"string\">'3'</span>: <span class=\"number\">3</span>, <span class=\"string\">'4'</span>: <span class=\"number\">4</span>, <span class=\"string\">'5'</span>: <span class=\"number\">5</span>, <span class=\"string\">'6'</span>: <span class=\"number\">6</span>, <span class=\"string\">'7'</span>: <span class=\"number\">7</span>, <span class=\"string\">'8'</span>: <span class=\"number\">8</span>, <span class=\"string\">'9'</span>: <span class=\"number\">9</span>&#125;[s]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">str2int</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x,y:x*<span class=\"number\">10</span>+y,map(char2num,s))</span><br><span class=\"line\"><span class=\"comment\">#map</span></span><br><span class=\"line\"><span class=\"comment\">#reduce 把结果继续和下一个元素做累积运算</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"大数据相关题\"><a href=\"#大数据相关题\" class=\"headerlink\" title=\"大数据相关题\"></a>大数据相关题</h5><p>介绍下HDFS？</p>\n<p>说下MapReduce原理？</p>\n<p>高可用机制和联邦机制是什么？</p>\n<p>高可用机制的备用是冷的还是热的？为什么？</p>\n<p>如何对大文件中的数字排序？(文件很大机器内存有限)</p>\n<p>爬取大量URL时，如何判断这个URL是否已经爬过？（set？布隆过滤器？）</p>\n","site":{"data":{}},"excerpt":"<p>不同面试官的侧重点不一样，有的比较看重基础，有的比较看重项目经验，你的xxx还是不错的。。</p>\n<p>今天我们就聊到这里。。。你先回去等通知。。</p>","more":"<h3 id=\"关于数据结构\"><a href=\"#关于数据结构\" class=\"headerlink\" title=\"关于数据结构\"></a>关于数据结构</h3><p>二分查找</p>\n<p>给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数</p>\n<p>判断一棵树是否是另一棵树的子树</p>\n<p>链表反转</p>\n<p>归并排序</p>\n<p>String To Int</p>\n<p>考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index&lt;s.length()</p>\n<p>求第k大的数(复杂度是多少？时间复杂度O(n)，空间复杂度O(1))</p>\n<h3 id=\"关于算法\"><a href=\"#关于算法\" class=\"headerlink\" title=\"关于算法\"></a>关于算法</h3><h4 id=\"算法原理：\"><a href=\"#算法原理：\" class=\"headerlink\" title=\"算法原理：\"></a>算法原理：</h4><p>XGBoost原理(如何并行)？</p>\n<p>XGBoost和LightGBM区别、和RF区别？</p>\n<p>RF原理？</p>\n<p>SVM的核函数有哪些？</p>\n<blockquote>\n<p>线性核、多项式核、径向基核（RBF）、傅里叶核、样条核、Sigmoid核</p>\n</blockquote>\n<p>树如何分裂？分裂后熵应该变大还是变小？</p>\n<p>熵的定义和意义、怎么计算熵？</p>\n<blockquote>\n<p>我们一般使用<strong>信息量</strong>来进行<strong>不确定性</strong>的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。</p>\n<blockquote>\n<p>对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。</p>\n</blockquote>\n<p><strong>(信息)熵</strong>定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。</p>\n<blockquote>\n<p>1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$</p>\n<p>多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$</p>\n<blockquote>\n<p>随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0&lt;H(X)&lt;log(n)$)</p>\n</blockquote>\n</blockquote>\n<p><strong>条件熵</strong>：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。</p>\n<blockquote>\n<p>$H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$</p>\n<p>$H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$</p>\n<p>$H(Y|X)=H(X,Y)-H(X)$</p>\n</blockquote>\n<p><strong>相对熵</strong>（KL散度）：两个概率分布之间的差异。</p>\n<blockquote>\n<p>$D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)</p>\n</blockquote>\n<p><strong>交叉熵</strong>：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。</p>\n<blockquote>\n<p>$H(p,q)=-\\sum_xp(x)logq(x)$</p>\n<p>$H(p,q)=H(p)+D_{KL}(p||q)$</p>\n</blockquote>\n<p>熵与方差的关系(在大部分分布的情况下正相关？)</p>\n<p><strong>信息增益</strong>：熵-条件熵</p>\n<p><strong>互信息</strong>：联合分布于乘积分布之间的相对熵，熵-条件熵</p>\n<blockquote>\n<p>$I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$</p>\n</blockquote>\n</blockquote>\n<p>二分类的label，数据如何分布熵最大？</p>\n<blockquote>\n<p>一半一半，均匀分布的时候</p>\n</blockquote>\n<p>Bootstrap是什么？</p>\n<blockquote>\n<p>有放回抽样?</p>\n</blockquote>\n<p>Bagging和Boosting区别、Stacking？</p>\n<blockquote>\n<p>bagging：如果各个单独的模型产生的误差是不相关的，那么bagging后的平均误差可以仅仅通过M个版本求平均的方法减小M倍，但是实际应用中，误差通常是高度相关的。</p>\n<p>boosting：基分类器是顺序训练的，每个基分类器使用数据集的一个加权形式进行训练，其中与每个数据点相关的权系数依赖于前一个分类器的表现。被一个基分类器误分类的点在训练序列的下一个分类器时会被赋予更高的权重。Adaboost训练完毕后通过加权投票的方法进行组合。</p>\n</blockquote>\n<p>协方差矩阵？</p>\n<blockquote>\n<p>标准差和方差都是用来描述一维数据，协方差是一种用来度量两个随机变量关系的统计量，是一个对称的方阵，对角线上的因子就是变量的方差。</p>\n</blockquote>\n<p>pearson相关系数(如何定义)？</p>\n<blockquote>\n<p>协方差/标准差乘积</p>\n</blockquote>\n<p>评价指标有哪些(分类、回归)？</p>\n<ul>\n<li><p>R-Squared：$R^2 = 1 - \\sum(y-\\hat{y})^2/\\sum(y-\\bar{y})^2$，衡量回归方程与真实样本输出之间的相似程度。</p>\n<p>反映的是大概有多准，因为随着样本数增加R-Squared必然增加，无法真正定量说明准确程度。单独看R-Square并不能推断出特征是否有意义。应该使用校正决定系数（Adjusted R-Squared）</p>\n</li>\n</ul>\n<p>AUC怎么计算？ROC曲线怎么画？</p>\n<p>降维的方法有哪些？</p>\n<blockquote>\n<p>缺失比例过滤</p>\n<p>低方差滤波（方差与信息熵关系）</p>\n<p>高相关滤波（注意保留与目标变量存在高相关性的列，高相关性的特征会使得线性回归逻辑回归的效果变差）</p>\n<p>树模型特征重要性</p>\n<p>前向特征选择，反向特征消除（加减特征看效果。。）</p>\n<p>因子分析（按相关性分组）</p>\n<p>PCA、ICA、IOSMAP、t-SNE、UMAP</p>\n<p>AutoEncoder、Word2Vec</p>\n</blockquote>\n<p>如何做异常检测？</p>\n<p>如何判断一个特征是否有用？</p>\n<p>如何判断数据是线性的？</p>\n<blockquote>\n<p>线性分类模型是指决策面是输入向量X的线性函数。定义为D维输入空间的D-1维超平面。如果数据集可以被线性决策面精确地分类，该数据集是线性可分的。</p>\n<p>判断数据集是否线性可分：低维直接画图判断，高维检查凸包是否相交。</p>\n</blockquote>\n<p>线性模型和非线性模型的区别？</p>\n<blockquote>\n<p>决策边界是线性，自变量（单变量时）x是否只受一个w影响，是w的线性函数，特征交叉是非线性模型（基函数非线性）。</p>\n</blockquote>\n<p>CTR预估中如何处理样本不平衡的问题？</p>\n<p>如何判断采样是否有效？</p>\n<p>TextCNN原理？</p>\n<p>Word2Vec原理？</p>\n<p>FastText原理？</p>\n<p>TFIDF，怎么计算，怎么改进？</p>\n<p>TFIDF，有什么缺点？</p>\n<blockquote>\n<p>优点：简单快速，容易理解。缺点：用词频来衡量文章中的一个词的重要性不够全面，有时候重要的词出现的不够多，而且这种计算无法体现位置信息，无法体现词在上下文中的重要性。如需体现词的上下文结构，需要使用Word2Vec。</p>\n</blockquote>\n<p>N-gram怎么平滑？</p>\n<p>拉普拉斯平滑？贝叶斯平滑？</p>\n<p>聚类算法？硬核聚类软核聚类？</p>\n<blockquote>\n<p>只能有一个类别的叫硬核聚类，kmeans是硬核，GMM是软核</p>\n</blockquote>\n<p>广义线性模型的理解？</p>\n<blockquote>\n<p>符合指数分布族的一般模型</p>\n</blockquote>\n<p>最小二乘和最大似然的关系？</p>\n<blockquote>\n<p>最小二乘：找到一组估计值，使得实际值与估计值距离最小                                                </p>\n<p>最大似然：寻找一组参数估计值，使得已发生的样本概率最大</p>\n<p>最小二乘是高斯噪声模型假设下的最大似然解？</p>\n<p>对于二分类问题，不适宜用最小平方法，</p>\n</blockquote>\n<p>激活函数有哪些？ReLU和Sigmoid的区别有哪些？</p>\n<p>参数化方法和非参数化方法？</p>\n<blockquote>\n<p>线性回归是参数化的，kNN是非参数化的（基于记忆的方法）</p>\n</blockquote>\n<p>逻辑回归为什么不用squareloss？</p>\n<blockquote>\n</blockquote>\n<p>各种范数？</p>\n<blockquote>\n<p>$L_p$范数：向量各个元素绝对值的$p$次方求和，然后求$1/p$次方。</p>\n<p>$L_1$、$L_2$:向量各个元素绝对值之和，平方和然后求平方根。</p>\n</blockquote>\n<p>各种距离？</p>\n<blockquote>\n<p>曼哈顿距离、欧式距离、余弦距离、明式距离、pearson相关系数、</p>\n</blockquote>\n<p>SVM数据量大时为什么速度慢？</p>\n<blockquote>\n<p>大量的非支持向量参与训练过程，从而进行了大量的二次规划计算，导致分类计算量大、分类速度慢</p>\n</blockquote>\n<p>SVM核函数如何选择？</p>\n<blockquote>\n<p>1、样本特征很多时，特征的维数很高，往往可能线性可分，可以考虑线性核函数</p>\n<p>2、样本数量很多，特征较少时，可以手动添加一些特征，在考虑线性核函数</p>\n<p>3、样本特征维度不高，样本数量也不多，考虑高斯核函数（RBF核（指数核函数，拉普拉斯核函数）的一种）</p>\n</blockquote>\n<h4 id=\"手推公式\"><a href=\"#手推公式\" class=\"headerlink\" title=\"手推公式\"></a>手推公式</h4><p>LR</p>\n<p>SVM(适用于特征维度多于样本数的情况？)</p>\n<p>PCA</p>\n<p>XGB</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h5 id=\"SQL题\"><a href=\"#SQL题\" class=\"headerlink\" title=\"SQL题\"></a>SQL题</h5><p>一个表包含Name，Subject，Score三个字段，输出总分前十名的同学</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">Name</span>,<span class=\"keyword\">sum</span>(Score) <span class=\"keyword\">as</span> SumScore <span class=\"keyword\">from</span> A <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">Name</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> SumScore <span class=\"keyword\">limit</span> <span class=\"number\">10</span>; ?</span><br></pre></td></tr></table></figure>\n<h5 id=\"编程语言题\"><a href=\"#编程语言题\" class=\"headerlink\" title=\"编程语言题\"></a>编程语言题</h5><p>Python dict排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sorted(d.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">0</span>])</span><br><span class=\"line\">sorted(d.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">1</span>],reverse=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>Python 有哪些数据类型结构？List和Dict的区别？</p>\n<blockquote>\n<p>list,dict,set,tuple</p>\n<p>collections(defaultdict、counter、deque、namedtuple、enum.Enum)</p>\n<p><a href=\"https://eastlakeside.gitbooks.io/interpy-zh/content/collections/collections.html\" target=\"_blank\" rel=\"noopener\">pythonGitbook</a></p>\n</blockquote>\n<blockquote>\n<p>dict:</p>\n<ul>\n<li>查找和插入速度极快，且不会随着key的增加而增加</li>\n<li>占用大量内存</li>\n</ul>\n<p>list：</p>\n<ul>\n<li>查找和插入时间随着元素的增加而增加</li>\n<li>占用空间小，浪费内存少</li>\n</ul>\n<blockquote>\n<p>dict的key必须是不可变对象，dict根据key计算value的存储位置（hash算法）</p>\n</blockquote>\n</blockquote>\n<p>Python异常捕获？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    xxx</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> Exception</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(type(e))  <span class=\"comment\">##捕捉到异常对象执行</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\tprint(<span class=\"number\">1</span>) <span class=\"comment\">##不抛出异常执行    </span></span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    print(<span class=\"number\">2</span>)  <span class=\"comment\">##无论如何都执行</span></span><br></pre></td></tr></table></figure>\n<p>Python生成器？</p>\n<blockquote>\n<p>变循环，边计算的结构，节省空间（如果使用列表内存占用太大）</p>\n</blockquote>\n<p>Python map、reduce函数？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">char2num</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"string\">'0'</span>: <span class=\"number\">0</span>, <span class=\"string\">'1'</span>: <span class=\"number\">1</span>, <span class=\"string\">'2'</span>: <span class=\"number\">2</span>, <span class=\"string\">'3'</span>: <span class=\"number\">3</span>, <span class=\"string\">'4'</span>: <span class=\"number\">4</span>, <span class=\"string\">'5'</span>: <span class=\"number\">5</span>, <span class=\"string\">'6'</span>: <span class=\"number\">6</span>, <span class=\"string\">'7'</span>: <span class=\"number\">7</span>, <span class=\"string\">'8'</span>: <span class=\"number\">8</span>, <span class=\"string\">'9'</span>: <span class=\"number\">9</span>&#125;[s]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">str2int</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x,y:x*<span class=\"number\">10</span>+y,map(char2num,s))</span><br><span class=\"line\"><span class=\"comment\">#map</span></span><br><span class=\"line\"><span class=\"comment\">#reduce 把结果继续和下一个元素做累积运算</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"大数据相关题\"><a href=\"#大数据相关题\" class=\"headerlink\" title=\"大数据相关题\"></a>大数据相关题</h5><p>介绍下HDFS？</p>\n<p>说下MapReduce原理？</p>\n<p>高可用机制和联邦机制是什么？</p>\n<p>高可用机制的备用是冷的还是热的？为什么？</p>\n<p>如何对大文件中的数字排序？(文件很大机器内存有限)</p>\n<p>爬取大量URL时，如何判断这个URL是否已经爬过？（set？布隆过滤器？）</p>"},{"title":"排序算法","date":"2018-08-17T07:28:22.000Z","_content":"\n​\t在Java中，待排序的元素需要实现Comparable接口，该接口中有compareTo方法，可以用来判断两个元素的大小关系。排序算法的成本主要是比较和交换的次数，一个排序算法可以定义为如下形式：\n\n```java\npublic abstract class Sort<T extends Comparable>{\n    public abstract void sort(T[] obs);\n    protected boolean less(T a,T b){return a.compareTo(b)<0;};\n    protected void swap(T[] obs,int i,int j){\n        T tmp = obs[i];\n        obs[i] = obs[j];\n        obs[j] = tmp;\n    }\n}\n```\n\n\n\n<!--more-->\n\n#### 选择排序\n\n**基本思想**：选择数组中最小的元素，与数组的第一个元素交换位置。后续每第n步都选择剩余数组中最小的元素与第n个元素交换位置。每一步排好一个数。\n\n无论输入如何，都会进行同样的比较和交换，运行时间和输入无关。\n\nJava:\n\n```java\npublic class SlectionSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        int N = nums.length;\n        for(int i=0;i<N;i++){\n            min = i;\n            for(int j=i+1;j<N;j++){\n                if(less(nums[j],nums[min]))\n                    min = j;\n            }\n            swap(nums,i,min);\n        }\n    }\n    private void swap(T[] nums,int i,int j){\n        T tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    private boolean less(T a,T b){\n        return a.compareTo(b) < 0;\n    }\n}\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 冒泡排序\n\n**基本思想**：从左到右不断交换相邻逆序的元素，一轮循环后可以将最大元素上浮至右侧。\n\n如果一轮循环中没有发生交换，则数组有序，退出循环。\n\nJava:\n\n```java\npublic class BubbleSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        int N = nums.length;\n        boolean isSorted = false;\n        for(int i=N-1;i>0 && !isSorted;i--){\n            isSorted = true;\n            for(int j=0;j<i;j++){\n                if(less(nums[j+1],nums[j])){\n                    isSorted = false;\n                    swap(nums,j,j+1);\n                }\n            }\n        }\n    }\n}\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 插入排序\n\n**基本思想**：每次将元素插入到左侧已经排序的数组中，使得左侧数组依然有序。\n\n每一次只交换相邻元素，只能使逆序减少1，因此逆序越少（本身已部分有序）的数组插入排序越快。大规模数组插入排序非常慢。\n\nJava:\n\n```java\npublic class InsertionSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        for(int i = 1;i < N; i++)\n            for(int j = i; j > 0 && less(nums[j],nums[j-1]);j--)\n                swap(nums,j,j-1)\n    } \n}\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 希尔排序\n\n**基本思想**：改进插入排序每次只能使逆序减少1的局限性，通过交换不相邻元素，使得每一步减少的逆序数量大于1。\n\nJava:\n\n```\nTODO\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 归并排序\n\n**基本思想**：将序列拆分为排序好的两个子序列，然后归并起来，经典的分治思想。\n\n**归并**：将两个已经有序的子序列合并成一个有序序列。i，j分别为两个子序列的起始指针位置，从起始位置开始比较i ，j元素的大小。复制一份当前整个序列作为辅助序列，比较两个子序列i，j位置的元素，较小的存入最终结果序列。当其中一个子序列指针移到末尾，将另一个子序列的剩余元素放入结果序列末尾。详情见下Java代码。\n\n归并排序是稳定的排序，最好最坏的时间复杂度都为O(nlogn)。\n\nJava:\n\n```java\nimport java.util.Arrays;\npublic class MergeSort<T[] extends Comparable<T>>{\n    T[] tmp;\n    public void sort(T[] nums){\n        tmp = (T[]) new Comparable[nums.length];\n        sort(nums,0,nums.length-1)\n    }\n    private void sort(T[] nums,int l,int h){\n        if(h<=l)\n            return;\n        int mid = l + (h - l) / 2;\n        sort(nums,l,mid);\n        sort(nums,mid+1,h);\n        merge(nums,l,mid,h);\n    }\n    private void merge(int[] nums,int l,int m,int h){\n        int i = l,j = m + 1;\n        for(int k=l;k<=h;k++)\n            tmp[k] = nums[k];\n        for(int k=l;k<=h;k++){\n            if(i > m)\n                nums[k] = tmp[j++];\n            else if(j > h)\n                nums[k] = tmp[i++];\n            else if(tmp[i].compareTo(nums[j])<0)\n                nums[k] = tmp[i++];\n            else\n                nums[k] = tmp[j++];\n        }\n    }\n    public static void main(String[] args){\n        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};\n        MergeSort ms = new MergeSort();\n        ms.sort();\n        System.out.println(Arrays.toString(nums));\n    }\n}\n//输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nPython:\n\n```python\nclass MergeSort(object):\n    def __init__(self):\n        pass\n    def merge_sort(self,lists):\n        if len(lists) <= 1:\n            return lists\n        mid = int(len(lists)/2)\n        left = self.merge_sort(lists[:mid])\n        right = self.merge_sort(lists[mid:])\n        return merge(left,right)\n    def merge(self,left,right):\n        i,j = 0,0\n        result = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\nif __name__ == \"__main__\":\n    lists = [6,5,8,7,1,4,2,3]\n    ms = MergeSort()\n    result = ms.sort(lists)\n    print(result)\n#输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n自顶向下：\n\n自底向上：\n\n\n\n---\n\n#### 快速排序\n\n**基本思想**：通过一个切分元素把数组分为两个子数组，左边子数组小于等于切分元素，右边子数组大于等于切分元素。将两个子数组排序则整体有序了。\n\n**切分元素**：选定位置，如：数组第一个元素，作为切分元素。指针i从左往右寻找第一个大于它的元素，指针j从右往左寻找第一个小于它的元素，交换这两个元素。不断进行该过程，指针i左边的元素都不大于切分元素，指针j右边的元素都大于切分元素，当i==j时，将切分元素交换到j位置。\n\n快速排序是原地排序，不需要额外的辅助数组（但是递归调用需要辅助栈）。最好情况：每次都将数组对半分，O(nlogn)。最坏情况：数组本来就是有序的，O(n^2^)。所以为了防止这种最坏的情况出现，排序前先把数组shuffle一下。\n\nJava:\n\n```java\npublic class QuickSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        shuffle(nums);\n        sort(nums,0,nums.length-1);\n    }\n    private void sort(T[] nums,int l,int h){\n        if(l>=h)\n            return;\n        int j = partition(nums,l,h);\n        sort(nums,l,j-1);\n        sort(nums,j+1,h);\n    }\n    private int partition(T[] nums,int l,int h){\n        int i = l,j = h + 1;\n        T b = nums[l];\n        while(true){\n            while(less(nums[++i],b) && i != h);\n            while(less(b,nums[--j]) && j != l);\n            if(i >= j)\n                break;\n            swap(nums,i,j);\n        }\n        swap(nums,l,j);\n        return j;\n    }\n    private void shuffle(T[] nums){\n        List<Comparable> list = Arrays.asList(nums);\n        Collections.shuffle(list);\n        list.toArray(nums);\n    }\n    private void swap(T[] nums,int i,int j){\n        T tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    private boolean less(T a,T b){\n        return a.compareTo(b) < 0;\n    }\n    \n    public static void main(String[] args){\n        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};\n        QuickSort qs = new QuickSort();\n        qs.sort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n}\n//输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nPython:\n\n```python\nclass QuickSort(object):\n    def __init__(self):\n        pass\n    def sort(self,lists):\n        return self.quick_sort(lists,0,len(lists)-1)\n    def quick_sort(self,lists,left,right):\n        if left >= right:\n            return lists\n        key = lists[left]\n        low = left\n        high = right\n        while left < right:\n            while left < right and lists[right] >= key:\n                right -= 1\n            lists[left] = lists[right]\n            while left < right and lists[left] <= key:\n                left += 1\n            lists[right] = lists[left]\n        lists[right] = lists[key]\n        self.quick_sort(lists,low,left-1)\n        self.quick_sort(lists,left+1,high)\n        return lists\nif __name__ == \"__main__\":\n    nums = [6,5,8,7,1,4,2,3]\n    qs = QuickSort()\n    qs.sort(nums)\n    print(nums)\n#输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n**算法改进**：\n\n1、小数组切换到插入排序，因为插入排序在数组较小时效率较高，快速排序因为会递归调用自己所以小数组时性能一般。\n\n2、三数取中，效果最好的切分元素为中位数。\n\n3、三向切分\n\n**快速选择算法**：利用partition函数，得到第K大元素。\n\n---\n\n#### 堆排序\n\n**基本思想**：堆的某个节点的值总是大于其子节点的值，并且是一颗完全二叉树，可以很容易存储在数组中。堆可以很容易地每次得到最大值，如果每次把最大元素和堆中数组的最后一个位置交换，可以得到一个有序序列。\n\n堆排序是原地排序，不占用额外空间。\n\nJava:\n\n```Java\npublic class Heap<T extends Comparable<T>>{\n    private T[] heap;\n    private int N = 0;\n    public Heap(int maxN){\n        this.heap = (T[]) new Comparable[maxN+1];\n    }\n    public isEmpty(){\n        return N == 0;\n    }\n    public int size(){\n        return N;\n    }\n    private boolean less(int i,int j){\n        return heap[i].compareTo(heap[j]) < 0;\n    }\n    private boolean swap(int i,int j){\n        T tmp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = tmp;\n    }\n    private swim(int k){\n        while(k > 1 && less(k/2,k)){\n            swap(k/2,k);\n            k = k/2;\n        }\n    }\n    private sink(int k){\n        while(2*k < N){\n            int j = 2*k;\n            if(j < N && less(j,j+1))\n                j++;\n            if(!less(k,j))\n                break;\n            swap(k,j);\n            k = j;\n        }\n    }\n    public void insert(T v){\n        heap[++N] = v;\n        swim(N);\n    }\n    public T delMax(){\n        T max = heap[1];\n        swap(1,N--);\n        heap[N+1] == null;\n        sink(1);\n        return max;\n    }\n}\n//第0个位置不存元素，第0个元素开始的见下\n```\n\n\n\n```java\nimport java.util.Arrays;\npublic class HeapSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        //构建堆\n        int N = nums.length - 1;\n        for(int k = N/2 - 1;k >= 0;k--)\n            sink(nums,k,N);\n        //把堆顶元素交换到末尾，并下沉维持剩余堆元素的有序状态\n        while (N > 0){\n            swap(nums,0,N--);\n            sink(nums,0,N);\n        }\n    }\n    public void sink(T[] nums,int k,int N){\n        while (2*k + 1 <= N){\n            int j = 2*k + 1;\n            if(j < N && less(nums,j,j+1))\n                j++;\n            if(!less(nums,k,j))\n                break;\n            swap(nums,k,j);\n            k = j;\n        }\n    }\n    public void swap(T[] nums,int i,int j){\n        T tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    public boolean less(nums,int i,int j){\n        return nums[i].compareTo(nums[j]) < 0;\n    }\n    public static void main(String[] args){\n        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};\n        HeapSort hs = new HeapSort();\n        hs.sort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n}\n//输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 基数排序\n\n**基本思想**：\n\nJava:\n\n```\nTODO\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n参考：[csNotes](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95.md)\n\n\n\n","source":"_posts/排序算法.md","raw":"---\ntitle: 排序算法\ndate: 2018-08-17 15:28:22\ntags: [coding,Java,Python,排序算法]\n---\n\n​\t在Java中，待排序的元素需要实现Comparable接口，该接口中有compareTo方法，可以用来判断两个元素的大小关系。排序算法的成本主要是比较和交换的次数，一个排序算法可以定义为如下形式：\n\n```java\npublic abstract class Sort<T extends Comparable>{\n    public abstract void sort(T[] obs);\n    protected boolean less(T a,T b){return a.compareTo(b)<0;};\n    protected void swap(T[] obs,int i,int j){\n        T tmp = obs[i];\n        obs[i] = obs[j];\n        obs[j] = tmp;\n    }\n}\n```\n\n\n\n<!--more-->\n\n#### 选择排序\n\n**基本思想**：选择数组中最小的元素，与数组的第一个元素交换位置。后续每第n步都选择剩余数组中最小的元素与第n个元素交换位置。每一步排好一个数。\n\n无论输入如何，都会进行同样的比较和交换，运行时间和输入无关。\n\nJava:\n\n```java\npublic class SlectionSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        int N = nums.length;\n        for(int i=0;i<N;i++){\n            min = i;\n            for(int j=i+1;j<N;j++){\n                if(less(nums[j],nums[min]))\n                    min = j;\n            }\n            swap(nums,i,min);\n        }\n    }\n    private void swap(T[] nums,int i,int j){\n        T tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    private boolean less(T a,T b){\n        return a.compareTo(b) < 0;\n    }\n}\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 冒泡排序\n\n**基本思想**：从左到右不断交换相邻逆序的元素，一轮循环后可以将最大元素上浮至右侧。\n\n如果一轮循环中没有发生交换，则数组有序，退出循环。\n\nJava:\n\n```java\npublic class BubbleSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        int N = nums.length;\n        boolean isSorted = false;\n        for(int i=N-1;i>0 && !isSorted;i--){\n            isSorted = true;\n            for(int j=0;j<i;j++){\n                if(less(nums[j+1],nums[j])){\n                    isSorted = false;\n                    swap(nums,j,j+1);\n                }\n            }\n        }\n    }\n}\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 插入排序\n\n**基本思想**：每次将元素插入到左侧已经排序的数组中，使得左侧数组依然有序。\n\n每一次只交换相邻元素，只能使逆序减少1，因此逆序越少（本身已部分有序）的数组插入排序越快。大规模数组插入排序非常慢。\n\nJava:\n\n```java\npublic class InsertionSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        for(int i = 1;i < N; i++)\n            for(int j = i; j > 0 && less(nums[j],nums[j-1]);j--)\n                swap(nums,j,j-1)\n    } \n}\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 希尔排序\n\n**基本思想**：改进插入排序每次只能使逆序减少1的局限性，通过交换不相邻元素，使得每一步减少的逆序数量大于1。\n\nJava:\n\n```\nTODO\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 归并排序\n\n**基本思想**：将序列拆分为排序好的两个子序列，然后归并起来，经典的分治思想。\n\n**归并**：将两个已经有序的子序列合并成一个有序序列。i，j分别为两个子序列的起始指针位置，从起始位置开始比较i ，j元素的大小。复制一份当前整个序列作为辅助序列，比较两个子序列i，j位置的元素，较小的存入最终结果序列。当其中一个子序列指针移到末尾，将另一个子序列的剩余元素放入结果序列末尾。详情见下Java代码。\n\n归并排序是稳定的排序，最好最坏的时间复杂度都为O(nlogn)。\n\nJava:\n\n```java\nimport java.util.Arrays;\npublic class MergeSort<T[] extends Comparable<T>>{\n    T[] tmp;\n    public void sort(T[] nums){\n        tmp = (T[]) new Comparable[nums.length];\n        sort(nums,0,nums.length-1)\n    }\n    private void sort(T[] nums,int l,int h){\n        if(h<=l)\n            return;\n        int mid = l + (h - l) / 2;\n        sort(nums,l,mid);\n        sort(nums,mid+1,h);\n        merge(nums,l,mid,h);\n    }\n    private void merge(int[] nums,int l,int m,int h){\n        int i = l,j = m + 1;\n        for(int k=l;k<=h;k++)\n            tmp[k] = nums[k];\n        for(int k=l;k<=h;k++){\n            if(i > m)\n                nums[k] = tmp[j++];\n            else if(j > h)\n                nums[k] = tmp[i++];\n            else if(tmp[i].compareTo(nums[j])<0)\n                nums[k] = tmp[i++];\n            else\n                nums[k] = tmp[j++];\n        }\n    }\n    public static void main(String[] args){\n        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};\n        MergeSort ms = new MergeSort();\n        ms.sort();\n        System.out.println(Arrays.toString(nums));\n    }\n}\n//输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nPython:\n\n```python\nclass MergeSort(object):\n    def __init__(self):\n        pass\n    def merge_sort(self,lists):\n        if len(lists) <= 1:\n            return lists\n        mid = int(len(lists)/2)\n        left = self.merge_sort(lists[:mid])\n        right = self.merge_sort(lists[mid:])\n        return merge(left,right)\n    def merge(self,left,right):\n        i,j = 0,0\n        result = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\nif __name__ == \"__main__\":\n    lists = [6,5,8,7,1,4,2,3]\n    ms = MergeSort()\n    result = ms.sort(lists)\n    print(result)\n#输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n自顶向下：\n\n自底向上：\n\n\n\n---\n\n#### 快速排序\n\n**基本思想**：通过一个切分元素把数组分为两个子数组，左边子数组小于等于切分元素，右边子数组大于等于切分元素。将两个子数组排序则整体有序了。\n\n**切分元素**：选定位置，如：数组第一个元素，作为切分元素。指针i从左往右寻找第一个大于它的元素，指针j从右往左寻找第一个小于它的元素，交换这两个元素。不断进行该过程，指针i左边的元素都不大于切分元素，指针j右边的元素都大于切分元素，当i==j时，将切分元素交换到j位置。\n\n快速排序是原地排序，不需要额外的辅助数组（但是递归调用需要辅助栈）。最好情况：每次都将数组对半分，O(nlogn)。最坏情况：数组本来就是有序的，O(n^2^)。所以为了防止这种最坏的情况出现，排序前先把数组shuffle一下。\n\nJava:\n\n```java\npublic class QuickSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        shuffle(nums);\n        sort(nums,0,nums.length-1);\n    }\n    private void sort(T[] nums,int l,int h){\n        if(l>=h)\n            return;\n        int j = partition(nums,l,h);\n        sort(nums,l,j-1);\n        sort(nums,j+1,h);\n    }\n    private int partition(T[] nums,int l,int h){\n        int i = l,j = h + 1;\n        T b = nums[l];\n        while(true){\n            while(less(nums[++i],b) && i != h);\n            while(less(b,nums[--j]) && j != l);\n            if(i >= j)\n                break;\n            swap(nums,i,j);\n        }\n        swap(nums,l,j);\n        return j;\n    }\n    private void shuffle(T[] nums){\n        List<Comparable> list = Arrays.asList(nums);\n        Collections.shuffle(list);\n        list.toArray(nums);\n    }\n    private void swap(T[] nums,int i,int j){\n        T tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    private boolean less(T a,T b){\n        return a.compareTo(b) < 0;\n    }\n    \n    public static void main(String[] args){\n        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};\n        QuickSort qs = new QuickSort();\n        qs.sort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n}\n//输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nPython:\n\n```python\nclass QuickSort(object):\n    def __init__(self):\n        pass\n    def sort(self,lists):\n        return self.quick_sort(lists,0,len(lists)-1)\n    def quick_sort(self,lists,left,right):\n        if left >= right:\n            return lists\n        key = lists[left]\n        low = left\n        high = right\n        while left < right:\n            while left < right and lists[right] >= key:\n                right -= 1\n            lists[left] = lists[right]\n            while left < right and lists[left] <= key:\n                left += 1\n            lists[right] = lists[left]\n        lists[right] = lists[key]\n        self.quick_sort(lists,low,left-1)\n        self.quick_sort(lists,left+1,high)\n        return lists\nif __name__ == \"__main__\":\n    nums = [6,5,8,7,1,4,2,3]\n    qs = QuickSort()\n    qs.sort(nums)\n    print(nums)\n#输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n**算法改进**：\n\n1、小数组切换到插入排序，因为插入排序在数组较小时效率较高，快速排序因为会递归调用自己所以小数组时性能一般。\n\n2、三数取中，效果最好的切分元素为中位数。\n\n3、三向切分\n\n**快速选择算法**：利用partition函数，得到第K大元素。\n\n---\n\n#### 堆排序\n\n**基本思想**：堆的某个节点的值总是大于其子节点的值，并且是一颗完全二叉树，可以很容易存储在数组中。堆可以很容易地每次得到最大值，如果每次把最大元素和堆中数组的最后一个位置交换，可以得到一个有序序列。\n\n堆排序是原地排序，不占用额外空间。\n\nJava:\n\n```Java\npublic class Heap<T extends Comparable<T>>{\n    private T[] heap;\n    private int N = 0;\n    public Heap(int maxN){\n        this.heap = (T[]) new Comparable[maxN+1];\n    }\n    public isEmpty(){\n        return N == 0;\n    }\n    public int size(){\n        return N;\n    }\n    private boolean less(int i,int j){\n        return heap[i].compareTo(heap[j]) < 0;\n    }\n    private boolean swap(int i,int j){\n        T tmp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = tmp;\n    }\n    private swim(int k){\n        while(k > 1 && less(k/2,k)){\n            swap(k/2,k);\n            k = k/2;\n        }\n    }\n    private sink(int k){\n        while(2*k < N){\n            int j = 2*k;\n            if(j < N && less(j,j+1))\n                j++;\n            if(!less(k,j))\n                break;\n            swap(k,j);\n            k = j;\n        }\n    }\n    public void insert(T v){\n        heap[++N] = v;\n        swim(N);\n    }\n    public T delMax(){\n        T max = heap[1];\n        swap(1,N--);\n        heap[N+1] == null;\n        sink(1);\n        return max;\n    }\n}\n//第0个位置不存元素，第0个元素开始的见下\n```\n\n\n\n```java\nimport java.util.Arrays;\npublic class HeapSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        //构建堆\n        int N = nums.length - 1;\n        for(int k = N/2 - 1;k >= 0;k--)\n            sink(nums,k,N);\n        //把堆顶元素交换到末尾，并下沉维持剩余堆元素的有序状态\n        while (N > 0){\n            swap(nums,0,N--);\n            sink(nums,0,N);\n        }\n    }\n    public void sink(T[] nums,int k,int N){\n        while (2*k + 1 <= N){\n            int j = 2*k + 1;\n            if(j < N && less(nums,j,j+1))\n                j++;\n            if(!less(nums,k,j))\n                break;\n            swap(nums,k,j);\n            k = j;\n        }\n    }\n    public void swap(T[] nums,int i,int j){\n        T tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    public boolean less(nums,int i,int j){\n        return nums[i].compareTo(nums[j]) < 0;\n    }\n    public static void main(String[] args){\n        Integer[] nums = new Integer[]{6,5,8,7,1,4,2,3};\n        HeapSort hs = new HeapSort();\n        hs.sort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n}\n//输出：[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n#### 基数排序\n\n**基本思想**：\n\nJava:\n\n```\nTODO\n```\n\nPython:\n\n```\nTODO\n```\n\n\n\n---\n\n参考：[csNotes](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95.md)\n\n\n\n","slug":"排序算法","published":1,"updated":"2018-09-27T16:14:53.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2rc000iqsez8mjplmlg","content":"<p>​    在Java中，待排序的元素需要实现Comparable接口，该接口中有compareTo方法，可以用来判断两个元素的大小关系。排序算法的成本主要是比较和交换的次数，一个排序算法可以定义为如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] obs)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(T a,T b)</span></span>&#123;<span class=\"keyword\">return</span> a.compareTo(b)&lt;<span class=\"number\">0</span>;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] obs,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = obs[i];</span><br><span class=\"line\">        obs[i] = obs[j];</span><br><span class=\"line\">        obs[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p><strong>基本思想</strong>：选择数组中最小的元素，与数组的第一个元素交换位置。后续每第n步都选择剩余数组中最小的元素与第n个元素交换位置。每一步排好一个数。</p>\n<p>无论输入如何，都会进行同样的比较和交换，运行时间和输入无关。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SlectionSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">            min = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;N;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(less(nums[j],nums[min]))</span><br><span class=\"line\">                    min = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(nums,i,min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(T a,T b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.compareTo(b) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><strong>基本思想</strong>：从左到右不断交换相邻逆序的元素，一轮循环后可以将最大元素上浮至右侧。</p>\n<p>如果一轮循环中没有发生交换，则数组有序，退出循环。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BubbleSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isSorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=N-<span class=\"number\">1</span>;i&gt;<span class=\"number\">0</span> &amp;&amp; !isSorted;i--)&#123;</span><br><span class=\"line\">            isSorted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(less(nums[j+<span class=\"number\">1</span>],nums[j]))&#123;</span><br><span class=\"line\">                    isSorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    swap(nums,j,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p><strong>基本思想</strong>：每次将元素插入到左侧已经排序的数组中，使得左侧数组依然有序。</p>\n<p>每一次只交换相邻元素，只能使逆序减少1，因此逆序越少（本身已部分有序）的数组插入排序越快。大规模数组插入排序非常慢。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsertionSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; N; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span> &amp;&amp; less(nums[j],nums[j-<span class=\"number\">1</span>]);j--)</span><br><span class=\"line\">                swap(nums,j,j-<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p><strong>基本思想</strong>：改进插入排序每次只能使逆序减少1的局限性，通过交换不相邻元素，使得每一步减少的逆序数量大于1。</p>\n<p>Java:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><p><strong>基本思想</strong>：将序列拆分为排序好的两个子序列，然后归并起来，经典的分治思想。</p>\n<p><strong>归并</strong>：将两个已经有序的子序列合并成一个有序序列。i，j分别为两个子序列的起始指针位置，从起始位置开始比较i ，j元素的大小。复制一份当前整个序列作为辅助序列，比较两个子序列i，j位置的元素，较小的存入最终结果序列。当其中一个子序列指针移到末尾，将另一个子序列的剩余元素放入结果序列末尾。详情见下Java代码。</p>\n<p>归并排序是稳定的排序，最好最坏的时间复杂度都为O(nlogn)。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\">public class MergeSort&lt;T[] extends Comparable&lt;T&gt;&gt;&#123;</span><br><span class=\"line\">    T[] tmp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        tmp = (T[]) <span class=\"keyword\">new</span> Comparable[nums.length];</span><br><span class=\"line\">        sort(nums,<span class=\"number\">0</span>,nums.length-<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(h&lt;=l)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = l + (h - l) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        sort(nums,l,mid);</span><br><span class=\"line\">        sort(nums,mid+<span class=\"number\">1</span>,h);</span><br><span class=\"line\">        merge(nums,l,mid,h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l,j = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;=h;k++)</span><br><span class=\"line\">            tmp[k] = nums[k];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;=h;k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; m)</span><br><span class=\"line\">                nums[k] = tmp[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &gt; h)</span><br><span class=\"line\">                nums[k] = tmp[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp[i].compareTo(nums[j])&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">                nums[k] = tmp[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                nums[k] = tmp[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Integer[] nums = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        MergeSort ms = <span class=\"keyword\">new</span> MergeSort();</span><br><span class=\"line\">        ms.sort();</span><br><span class=\"line\">        System.out.println(Arrays.toString(nums));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergeSort</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(self,lists)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(lists) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">        mid = int(len(lists)/<span class=\"number\">2</span>)</span><br><span class=\"line\">        left = self.merge_sort(lists[:mid])</span><br><span class=\"line\">        right = self.merge_sort(lists[mid:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(left,right)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self,left,right)</span>:</span></span><br><span class=\"line\">        i,j = <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(left) <span class=\"keyword\">and</span> j &lt; len(right):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left[i] &lt;= right[j]:</span><br><span class=\"line\">                result.append(left[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result.append(right[j])</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">        result += left[i:]</span><br><span class=\"line\">        result += right[j:]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    lists = [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    ms = MergeSort()</span><br><span class=\"line\">    result = ms.sort(lists)</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"><span class=\"comment\">#输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>自顶向下：</p>\n<p>自底向上：</p>\n<hr>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p><strong>基本思想</strong>：通过一个切分元素把数组分为两个子数组，左边子数组小于等于切分元素，右边子数组大于等于切分元素。将两个子数组排序则整体有序了。</p>\n<p><strong>切分元素</strong>：选定位置，如：数组第一个元素，作为切分元素。指针i从左往右寻找第一个大于它的元素，指针j从右往左寻找第一个小于它的元素，交换这两个元素。不断进行该过程，指针i左边的元素都不大于切分元素，指针j右边的元素都大于切分元素，当i==j时，将切分元素交换到j位置。</p>\n<p>快速排序是原地排序，不需要额外的辅助数组（但是递归调用需要辅助栈）。最好情况：每次都将数组对半分，O(nlogn)。最坏情况：数组本来就是有序的，O(n^2^)。所以为了防止这种最坏的情况出现，排序前先把数组shuffle一下。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        shuffle(nums);</span><br><span class=\"line\">        sort(nums,<span class=\"number\">0</span>,nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&gt;=h)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = partition(nums,l,h);</span><br><span class=\"line\">        sort(nums,l,j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        sort(nums,j+<span class=\"number\">1</span>,h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l,j = h + <span class=\"number\">1</span>;</span><br><span class=\"line\">        T b = nums[l];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(less(nums[++i],b) &amp;&amp; i != h);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(less(b,nums[--j]) &amp;&amp; j != l);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= j)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(nums,i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums,l,j);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        List&lt;Comparable&gt; list = Arrays.asList(nums);</span><br><span class=\"line\">        Collections.shuffle(list);</span><br><span class=\"line\">        list.toArray(nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(T a,T b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.compareTo(b) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Integer[] nums = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        QuickSort qs = <span class=\"keyword\">new</span> QuickSort();</span><br><span class=\"line\">        qs.sort(nums);</span><br><span class=\"line\">        System.out.println(Arrays.toString(nums));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sort</span><span class=\"params\">(self,lists)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.quick_sort(lists,<span class=\"number\">0</span>,len(lists)<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(self,lists,left,right)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">        key = lists[left]</span><br><span class=\"line\">        low = left</span><br><span class=\"line\">        high = right</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[right] &gt;= key:</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">            lists[left] = lists[right]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[left] &lt;= key:</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            lists[right] = lists[left]</span><br><span class=\"line\">        lists[right] = lists[key]</span><br><span class=\"line\">        self.quick_sort(lists,low,left<span class=\"number\">-1</span>)</span><br><span class=\"line\">        self.quick_sort(lists,left+<span class=\"number\">1</span>,high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lists</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    nums = [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    qs = QuickSort()</span><br><span class=\"line\">    qs.sort(nums)</span><br><span class=\"line\">    print(nums)</span><br><span class=\"line\"><span class=\"comment\">#输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p><strong>算法改进</strong>：</p>\n<p>1、小数组切换到插入排序，因为插入排序在数组较小时效率较高，快速排序因为会递归调用自己所以小数组时性能一般。</p>\n<p>2、三数取中，效果最好的切分元素为中位数。</p>\n<p>3、三向切分</p>\n<p><strong>快速选择算法</strong>：利用partition函数，得到第K大元素。</p>\n<hr>\n<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><p><strong>基本思想</strong>：堆的某个节点的值总是大于其子节点的值，并且是一颗完全二叉树，可以很容易存储在数组中。堆可以很容易地每次得到最大值，如果每次把最大元素和堆中数组的最后一个位置交换，可以得到一个有序序列。</p>\n<p>堆排序是原地排序，不占用额外空间。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Heap</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T[] heap;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> N = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Heap</span><span class=\"params\">(<span class=\"keyword\">int</span> maxN)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.heap = (T[]) <span class=\"keyword\">new</span> Comparable[maxN+<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> heap[i].compareTo(heap[j]) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = heap[i];</span><br><span class=\"line\">        heap[i] = heap[j];</span><br><span class=\"line\">        heap[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">swim</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k &gt; <span class=\"number\">1</span> &amp;&amp; less(k/<span class=\"number\">2</span>,k))&#123;</span><br><span class=\"line\">            swap(k/<span class=\"number\">2</span>,k);</span><br><span class=\"line\">            k = k/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">sink</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">2</span>*k &lt; N)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">2</span>*k;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j &lt; N &amp;&amp; less(j,j+<span class=\"number\">1</span>))</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!less(k,j))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(k,j);</span><br><span class=\"line\">            k = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(T v)</span></span>&#123;</span><br><span class=\"line\">        heap[++N] = v;</span><br><span class=\"line\">        swim(N);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">delMax</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        T max = heap[<span class=\"number\">1</span>];</span><br><span class=\"line\">        swap(<span class=\"number\">1</span>,N--);</span><br><span class=\"line\">        heap[N+<span class=\"number\">1</span>] == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sink(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第0个位置不存元素，第0个元素开始的见下</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = N/<span class=\"number\">2</span> - <span class=\"number\">1</span>;k &gt;= <span class=\"number\">0</span>;k--)</span><br><span class=\"line\">            sink(nums,k,N);</span><br><span class=\"line\">        <span class=\"comment\">//把堆顶元素交换到末尾，并下沉维持剩余堆元素的有序状态</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (N &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            swap(nums,<span class=\"number\">0</span>,N--);</span><br><span class=\"line\">            sink(nums,<span class=\"number\">0</span>,N);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sink</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> N)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"number\">2</span>*k + <span class=\"number\">1</span> &lt;= N)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">2</span>*k + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j &lt; N &amp;&amp; less(nums,j,j+<span class=\"number\">1</span>))</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!less(nums,k,j))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(nums,k,j);</span><br><span class=\"line\">            k = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[i].compareTo(nums[j]) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Integer[] nums = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        HeapSort hs = <span class=\"keyword\">new</span> HeapSort();</span><br><span class=\"line\">        hs.sort(nums);</span><br><span class=\"line\">        System.out.println(Arrays.toString(nums));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><p><strong>基本思想</strong>：</p>\n<p>Java:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<p>参考：<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95.md\" target=\"_blank\" rel=\"noopener\">csNotes</a></p>\n","site":{"data":{}},"excerpt":"<p>​    在Java中，待排序的元素需要实现Comparable接口，该接口中有compareTo方法，可以用来判断两个元素的大小关系。排序算法的成本主要是比较和交换的次数，一个排序算法可以定义为如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] obs)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(T a,T b)</span></span>&#123;<span class=\"keyword\">return</span> a.compareTo(b)&lt;<span class=\"number\">0</span>;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] obs,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = obs[i];</span><br><span class=\"line\">        obs[i] = obs[j];</span><br><span class=\"line\">        obs[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p><strong>基本思想</strong>：选择数组中最小的元素，与数组的第一个元素交换位置。后续每第n步都选择剩余数组中最小的元素与第n个元素交换位置。每一步排好一个数。</p>\n<p>无论输入如何，都会进行同样的比较和交换，运行时间和输入无关。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SlectionSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;i++)&#123;</span><br><span class=\"line\">            min = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;N;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(less(nums[j],nums[min]))</span><br><span class=\"line\">                    min = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(nums,i,min);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(T a,T b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.compareTo(b) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p><strong>基本思想</strong>：从左到右不断交换相邻逆序的元素，一轮循环后可以将最大元素上浮至右侧。</p>\n<p>如果一轮循环中没有发生交换，则数组有序，退出循环。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BubbleSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isSorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=N-<span class=\"number\">1</span>;i&gt;<span class=\"number\">0</span> &amp;&amp; !isSorted;i--)&#123;</span><br><span class=\"line\">            isSorted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(less(nums[j+<span class=\"number\">1</span>],nums[j]))&#123;</span><br><span class=\"line\">                    isSorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    swap(nums,j,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p><strong>基本思想</strong>：每次将元素插入到左侧已经排序的数组中，使得左侧数组依然有序。</p>\n<p>每一次只交换相邻元素，只能使逆序减少1，因此逆序越少（本身已部分有序）的数组插入排序越快。大规模数组插入排序非常慢。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsertionSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt; N; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span> &amp;&amp; less(nums[j],nums[j-<span class=\"number\">1</span>]);j--)</span><br><span class=\"line\">                swap(nums,j,j-<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p><strong>基本思想</strong>：改进插入排序每次只能使逆序减少1的局限性，通过交换不相邻元素，使得每一步减少的逆序数量大于1。</p>\n<p>Java:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><p><strong>基本思想</strong>：将序列拆分为排序好的两个子序列，然后归并起来，经典的分治思想。</p>\n<p><strong>归并</strong>：将两个已经有序的子序列合并成一个有序序列。i，j分别为两个子序列的起始指针位置，从起始位置开始比较i ，j元素的大小。复制一份当前整个序列作为辅助序列，比较两个子序列i，j位置的元素，较小的存入最终结果序列。当其中一个子序列指针移到末尾，将另一个子序列的剩余元素放入结果序列末尾。详情见下Java代码。</p>\n<p>归并排序是稳定的排序，最好最坏的时间复杂度都为O(nlogn)。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\">public class MergeSort&lt;T[] extends Comparable&lt;T&gt;&gt;&#123;</span><br><span class=\"line\">    T[] tmp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        tmp = (T[]) <span class=\"keyword\">new</span> Comparable[nums.length];</span><br><span class=\"line\">        sort(nums,<span class=\"number\">0</span>,nums.length-<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(h&lt;=l)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = l + (h - l) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        sort(nums,l,mid);</span><br><span class=\"line\">        sort(nums,mid+<span class=\"number\">1</span>,h);</span><br><span class=\"line\">        merge(nums,l,mid,h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l,j = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;=h;k++)</span><br><span class=\"line\">            tmp[k] = nums[k];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;=h;k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; m)</span><br><span class=\"line\">                nums[k] = tmp[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &gt; h)</span><br><span class=\"line\">                nums[k] = tmp[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(tmp[i].compareTo(nums[j])&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">                nums[k] = tmp[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                nums[k] = tmp[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Integer[] nums = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        MergeSort ms = <span class=\"keyword\">new</span> MergeSort();</span><br><span class=\"line\">        ms.sort();</span><br><span class=\"line\">        System.out.println(Arrays.toString(nums));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergeSort</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span><span class=\"params\">(self,lists)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(lists) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">        mid = int(len(lists)/<span class=\"number\">2</span>)</span><br><span class=\"line\">        left = self.merge_sort(lists[:mid])</span><br><span class=\"line\">        right = self.merge_sort(lists[mid:])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(left,right)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(self,left,right)</span>:</span></span><br><span class=\"line\">        i,j = <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">        result = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; len(left) <span class=\"keyword\">and</span> j &lt; len(right):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left[i] &lt;= right[j]:</span><br><span class=\"line\">                result.append(left[i])</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                result.append(right[j])</span><br><span class=\"line\">                j += <span class=\"number\">1</span></span><br><span class=\"line\">        result += left[i:]</span><br><span class=\"line\">        result += right[j:]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    lists = [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    ms = MergeSort()</span><br><span class=\"line\">    result = ms.sort(lists)</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"><span class=\"comment\">#输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>自顶向下：</p>\n<p>自底向上：</p>\n<hr>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p><strong>基本思想</strong>：通过一个切分元素把数组分为两个子数组，左边子数组小于等于切分元素，右边子数组大于等于切分元素。将两个子数组排序则整体有序了。</p>\n<p><strong>切分元素</strong>：选定位置，如：数组第一个元素，作为切分元素。指针i从左往右寻找第一个大于它的元素，指针j从右往左寻找第一个小于它的元素，交换这两个元素。不断进行该过程，指针i左边的元素都不大于切分元素，指针j右边的元素都大于切分元素，当i==j时，将切分元素交换到j位置。</p>\n<p>快速排序是原地排序，不需要额外的辅助数组（但是递归调用需要辅助栈）。最好情况：每次都将数组对半分，O(nlogn)。最坏情况：数组本来就是有序的，O(n^2^)。所以为了防止这种最坏的情况出现，排序前先把数组shuffle一下。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        shuffle(nums);</span><br><span class=\"line\">        sort(nums,<span class=\"number\">0</span>,nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&gt;=h)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = partition(nums,l,h);</span><br><span class=\"line\">        sort(nums,l,j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        sort(nums,j+<span class=\"number\">1</span>,h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = l,j = h + <span class=\"number\">1</span>;</span><br><span class=\"line\">        T b = nums[l];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(less(nums[++i],b) &amp;&amp; i != h);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(less(b,nums[--j]) &amp;&amp; j != l);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= j)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(nums,i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums,l,j);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        List&lt;Comparable&gt; list = Arrays.asList(nums);</span><br><span class=\"line\">        Collections.shuffle(list);</span><br><span class=\"line\">        list.toArray(nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(T a,T b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.compareTo(b) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Integer[] nums = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        QuickSort qs = <span class=\"keyword\">new</span> QuickSort();</span><br><span class=\"line\">        qs.sort(nums);</span><br><span class=\"line\">        System.out.println(Arrays.toString(nums));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sort</span><span class=\"params\">(self,lists)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.quick_sort(lists,<span class=\"number\">0</span>,len(lists)<span class=\"number\">-1</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span><span class=\"params\">(self,lists,left,right)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists</span><br><span class=\"line\">        key = lists[left]</span><br><span class=\"line\">        low = left</span><br><span class=\"line\">        high = right</span><br><span class=\"line\">        <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[right] &gt;= key:</span><br><span class=\"line\">                right -= <span class=\"number\">1</span></span><br><span class=\"line\">            lists[left] = lists[right]</span><br><span class=\"line\">            <span class=\"keyword\">while</span> left &lt; right <span class=\"keyword\">and</span> lists[left] &lt;= key:</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">            lists[right] = lists[left]</span><br><span class=\"line\">        lists[right] = lists[key]</span><br><span class=\"line\">        self.quick_sort(lists,low,left<span class=\"number\">-1</span>)</span><br><span class=\"line\">        self.quick_sort(lists,left+<span class=\"number\">1</span>,high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lists</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    nums = [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    qs = QuickSort()</span><br><span class=\"line\">    qs.sort(nums)</span><br><span class=\"line\">    print(nums)</span><br><span class=\"line\"><span class=\"comment\">#输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p><strong>算法改进</strong>：</p>\n<p>1、小数组切换到插入排序，因为插入排序在数组较小时效率较高，快速排序因为会递归调用自己所以小数组时性能一般。</p>\n<p>2、三数取中，效果最好的切分元素为中位数。</p>\n<p>3、三向切分</p>\n<p><strong>快速选择算法</strong>：利用partition函数，得到第K大元素。</p>\n<hr>\n<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><p><strong>基本思想</strong>：堆的某个节点的值总是大于其子节点的值，并且是一颗完全二叉树，可以很容易存储在数组中。堆可以很容易地每次得到最大值，如果每次把最大元素和堆中数组的最后一个位置交换，可以得到一个有序序列。</p>\n<p>堆排序是原地排序，不占用额外空间。</p>\n<p>Java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Heap</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T[] heap;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> N = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Heap</span><span class=\"params\">(<span class=\"keyword\">int</span> maxN)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.heap = (T[]) <span class=\"keyword\">new</span> Comparable[maxN+<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> N;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> heap[i].compareTo(heap[j]) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = heap[i];</span><br><span class=\"line\">        heap[i] = heap[j];</span><br><span class=\"line\">        heap[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">swim</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(k &gt; <span class=\"number\">1</span> &amp;&amp; less(k/<span class=\"number\">2</span>,k))&#123;</span><br><span class=\"line\">            swap(k/<span class=\"number\">2</span>,k);</span><br><span class=\"line\">            k = k/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">sink</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">2</span>*k &lt; N)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">2</span>*k;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j &lt; N &amp;&amp; less(j,j+<span class=\"number\">1</span>))</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!less(k,j))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(k,j);</span><br><span class=\"line\">            k = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(T v)</span></span>&#123;</span><br><span class=\"line\">        heap[++N] = v;</span><br><span class=\"line\">        swim(N);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">delMax</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        T max = heap[<span class=\"number\">1</span>];</span><br><span class=\"line\">        swap(<span class=\"number\">1</span>,N--);</span><br><span class=\"line\">        heap[N+<span class=\"number\">1</span>] == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        sink(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第0个位置不存元素，第0个元素开始的见下</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建堆</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = N/<span class=\"number\">2</span> - <span class=\"number\">1</span>;k &gt;= <span class=\"number\">0</span>;k--)</span><br><span class=\"line\">            sink(nums,k,N);</span><br><span class=\"line\">        <span class=\"comment\">//把堆顶元素交换到末尾，并下沉维持剩余堆元素的有序状态</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (N &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            swap(nums,<span class=\"number\">0</span>,N--);</span><br><span class=\"line\">            sink(nums,<span class=\"number\">0</span>,N);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sink</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> N)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"number\">2</span>*k + <span class=\"number\">1</span> &lt;= N)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">2</span>*k + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j &lt; N &amp;&amp; less(nums,j,j+<span class=\"number\">1</span>))</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!less(nums,k,j))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(nums,k,j);</span><br><span class=\"line\">            k = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        T tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[i].compareTo(nums[j]) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Integer[] nums = <span class=\"keyword\">new</span> Integer[]&#123;<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        HeapSort hs = <span class=\"keyword\">new</span> HeapSort();</span><br><span class=\"line\">        hs.sort(nums);</span><br><span class=\"line\">        System.out.println(Arrays.toString(nums));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出：[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><p><strong>基本思想</strong>：</p>\n<p>Java:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<p>Python:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br></pre></td></tr></table></figure>\n<hr>\n<p>参考：<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95.md\" target=\"_blank\" rel=\"noopener\">csNotes</a></p>"},{"title":"刷题总结DayANight","date":"2018-08-30T16:32:30.000Z","_content":"\nRT!\n\n<!--more-->\n\n```c\n//孪生素数\n//在定义变量时，*定义的是指针，&定义的是引用\n//在使用时，*是解指针，&是取地址\n#include \"stdio.h\"\nint isPrime(int n)\n{\n    int i;\n    if(n < 2)\n        return 0;\n    for(i=2;i*i<=n;i++)\n        if(n%i==0)\n            return 0;\n    return 1;\n}\nint main()\n{\n    int a,b,flag=1;\n    scanf(\"%d %d\",&a,&b);\n    for(;a+2<=b;a++)\n        if(isPrime(a&&isPrime(a+2)))\n            flag=0,printf(%d,%d\\n,a,a+2);\n    if(flag)\n        printf(\"-1\\n\");\n    return 0;\n}\n```\n\n\n\n\n\n```c\n//A+B\n#define INT_MAX 2147483647\n#define INT_MIN (-INT_MAX-1)\n\nint reverseInt(int x){\n    int result = 0;\n    while(x != 0){\n        int tmp = x % 10;\n        if(result > INT_MAX/10 || result < INT_MIN/10) return 0;\n        result = result*10 + tmp;    \n    }\n    return result;\n}\n```\n\n### 树\n\n```java\npublic class TreeNode{\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val){\n        this.val = val;\n    }\n}\n```\n\n前序遍历\n\n```java\npublic List<Integer> preorderTraversal(TreeNode root){\n    ArrayList<Integer> res = new ArrayList<>();\n    if(root == null) return res;\n    Stack<TreeNode> stack = new Stack<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        root = stack.pop();\n        res.add(root.val);\n        if(root.right != null) stack.push(root.right);\n        if(root.left != null) stack.push(root.left);\n    }\n    return res;\n}\n```\n\n中序遍历\n\n```java\npublic List<Integer> inorderTraversal(TreeNode root){\n    ArrayList<Integer> res = new ArrayList<>();\n    if(root == null) return res;\n    Stack<TreeNode> stack = new Stack<>();\n    while(root != null || !stack.isEmpty()){\n        while(root.left != null){\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        res.add(root.val);\n        root = root.right;\n    }\n    return res;\n}\n```\n\n后序遍历\n\n```java\npublic List<Integer> postorderTraversal(TreeNode root){\n    LinkedList<Integer> res = new LinkedList<>();\n    if(root == null) return res;\n    Stack<TreeNode> stack = new Stack<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        root = stack.pop();\n        //链表擅长增删\n        res.addFirst(root.val);\n        if(root.left == null) stack.push(root.left);\n        if(root.right == null) stack.push(root.right);\n    }\n    return res;\n}\n```\n\n层序遍历\n\n```java\npublic List<List<Integer>> levelorderTraversal(TreeNode root){\n    List<List<Integer>> res = new ArrayList<>();\n    if(root == null) return res;\n    Queue<TreeNode> q = new LinkedList<>();\n    q.add(root);\n    while(!queue.isEmpty()){\n        int cnt = q.size();\n        List<Integer> sub = new ArrayList<>();\n        while(cnt -- > 0){\n            TreeNode tmp = q.poll();\n            if(tmp.left != null) q.add(tmp.left);\n            if(tmp.right != null) q.add(tmp.right);\n            sub.add(tmp.val);\n        }\n        res.add(sub);\n    }\n    return res;\n}\n/*\n队列的方法：\nadd offer\nremove poll\nelement peek\n区别：为空或者已满时是否抛出异常\n* */\n```\n\n二分查找\n\n```java\npublic class BinarySearch{\n    public int binarySearch(int[] nums,int target){\n        if(nums == null || nums.length == 0) return -1;\n        int left=0,right=nums.length-1;\n        while(left <= right){\n            int mid = left+(right-left)/2;\n            if(nums[mid]==target)\n                return mid;\n            else if(nums[mid] > target)\n                right = mid - 1;\n            else\n                left = mid + 1;\n        }\n        return -1;\n    }\n}\n```\n\n给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数\n\n```java\npublic void findNumsAppearedOnce(int[] nums,int num1[],int num2[]){\n\tint diff = 0;\n    for(int val:nums)\n        diff ^= val;\n    diff &= -diff;    //取出最右边两个不同的数的不同位\n    for(int val:nums){  //分成两组，两个不同的数字在不同组\n        if((val & diff) == 0)\n            num1[0] ^= val;\n        else\n            num2[0] ^= val;\n    }\n}\n```\n\n判断一棵树是否是另一棵树的子树\n\n```java\npublic class IsSubTree{\n    //t是否是s的子树\n    public boolean isSubTree(TreeNode s,TreeNode t){\n        if(s == null) return false;\n        if(isSameTree(s,t)) return true;\n        return isSubTree(s.left,t) || isSubTree(s.right,t);\n    }\n    private boolean isSameTree(TreeNode p,TreeNode q){\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val == q.val)\n            return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n}\n```\n\n归并排序\n\n```java\npublic class MergeSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        sort(nums,0.nums.length-1);\n    }\n    public void sort(T[] nums,int l,int h){\n        if(h < l) return;\n        int m = l + (h-l)/2;\n        sort(nums,l,m);\n        sort(nums,m+1,h);\n        merge(nums,l,m,h);\n    }\n    public void merge(T[] nums,int l,int m,int h){\n        T[] tmp = (T[]) new Comparable[nums.length];\n        for(int k=l;k<h;k++)\n            tmp[k] = nums[k];\n        int i=l,j=m+1;\n        for(int k=l;k<h;k++){\n            if(i>m)\n                nums[k] = nums[j++];\n            else if(j > h)\n                nums[k] = nums[i++];\n            else if(nums[i].compareTo(nums[j]) < 0)\n                nums[k] = nums[i++];\n            else\n                nums[k] = nums[j++];\n        }\n    }\n}\n```\n\nString To Int\n\n考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index<s.length()\n\n```java\npublic class Atoi{\n    public int myAtoi(String s){\n        int index = 0;\n        int sign = 1;\n        int total = 0;\n        //空串\n        if(s.length() == 0) return 0;\n        //空格\n        while(index < s.length() && s.charAt(index) == ' ')\n            index ++;\n        //符号\n        if(index < s.length() && (s.charAt(index) == '+') || s.charAt(index) == '-'){\n            sign = s.charAt(index) == '+' ? 1:-1;\n            index ++;\n        }\n        //数字\n        while(index < s.length()){\n            int digit = s.charAt(index) - '0';\n            if(digit < 0 || digit > 9) break;\n            //判断溢出\n            if(Integer.MAX_VALUE/10 < total || (Integer.MAX_VALUE/10 == total && Integer.MAX_VALUE%10 < digit))\n                return sign > 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            total = total*10 + digit;\n            index ++;\n        }\n        return sign*total;\n    }\n}\n```\n\n求第k大的数(复杂度是多少？)\n\n```java\n/*\n时间复杂度O(n)，空间复杂度O(1)\n**/\npublic class FindKthLargestElem{    \n    public int findKthLargestElem(int[] nums,int k){\n        k = nums.length - k;\n        int l=0,h=nums.length - 1;\n        while(l <= h){\n            int j = partition(nums,l,h);\n            if(j == k) break;\n            else if(j < k)\n                l = j + 1;\n            else\n                h = j - 1;\n        }\n        return nums[k];\n    }\n    private int partition(int[] nums,int l,int h){\n        int i=l,j=h+1;\n        while(true){\n            while((nums[++i] < nums[l]) && i<h);\n            while((nums[--j] > nums[l]) && j>l);\n            if(i >= j) break;\n            swap(nums,i,j);\n        }\n        swap(nums,l,j);\n        return j;\n    }\n    private void swap(int[] nums,int j,int j){\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n```java\npublic class TwoSum{\n    public int[] twoSum(int[] nums,int target){\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            int obj = target - nums[i];\n            if(map.containsKey(obj))\n                return new int[]{map.get(obj),i};\n            map.put(nums[i],i);\n        }\n        throw new IllegalArgumentException(\"No Solution!\");\n        //Throwable--Error/Exception[IllegalArgumentException]\n    }\n}\n\n//排序，二分查找\npublic class ThreeSum{\n    public List<List<Integer>> threeSum(int[] nums){\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(i>0 && nums[i]==nums[i-1])\n                continue;\n            int j=i+1,k=nums.length-1,target=-nums[i];\n            while(j<k){\n                if(nums[j]+nums[k]=target){\n                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));\n                    j++;\n                    k--;\n                    while(j<k && nums[j]==nums[j-1]) j++;\n                    while(j<k && nums[k]==nums[k+1]) k--;\n                }\n                else if(nums[j]+nums[k] < target)\n                    j++;\n                else\n                    k--;\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 链表\n\n```java\n//pre->curr->next\n//curr<-next\npublic class RverseLinkedList{\n    public ListNode reverseLinkedList(ListNode head){\n        ListNode prev = null;\n        ListNode curr = head;\n        while(curr != null){\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseNodeRecurse(ListNode head){\n        if(head = null || head.next == null) return null;\n        ListNode p = reverseNodeRecurse(head.next);\n        head.next.next = head;\n        head.next = null;\n        return p;\n    }\n}\npublic class ListNode{\n    int val;\n    ListNode next;\n    ListNode(int val){\n        this.val = val;\n    }\n}\n\n//(2->4->3)+(5->6->4)=(7->0->8)\npublic class AddTwoNum{\n    public ListNode addTwoNums(ListNode l1,ListNode l2){\n        ListNode dummyHead = new ListNode(0);\n        ListNode p=l1,q=l2,curr=dummyHead;\n        int carry = 0;\n        while(p!=null || q!=null){\n            int x = p!=null ? p.val:0;\n            int y = q!=null ? q.val:0;\n            int sum = x+y+carry;\n            carry = sum/10;\n            curr.next = new ListNode(sum%10);\n            curr = curr.next;\n            if(p!=null) p=p.next;\n            if(q!=null) q=q.next;\n        }\n        if(carry > 0)\n            curr.next = new ListNode(carry);\n        return dummyHead.next;\n    }\n}\n\npublic class GetIntersection{\n    public ListNode getIntersection(ListNode headA,ListNode headB){\n        ListNode l1=headA,l2=headB;\n        while(l1 != l2){\n            l1 = l1 != null ? l1.next:headB;\n            l2 = l2 != null ? l2.next:headA;\n        }\n        return l1;\n    }\n}\n\npublic class RemoveNthFromEnd{\n    public ListNode removeNthFromEnd(ListNode head,int n){\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        while(n-- >= 0)\n            fast = fast.next;\n        while(fast != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return dummy.next;\n    }\n}\n```\n\n### LeetCode\n\n#### 数据结构\n\n查找数在排序数组中插入位置\n\n```python\nsorted(lst + [target]).index(target)\nlen([x for x in lst if x < target])\nbisect.bisect_right(lst, target) #bisect_left\n```\n\n#### SQL\n\n执行顺序：\n\n> 1.from\n>\n> 2.on\n>\n> 3.join\n>\n> 4.where\n>\n> 5.group by\n>\n> 6.with、聚合（avg，sum）\n>\n> 7.having\n>\n> 8.select\n>\n> 9.distinct\n>\n> 10.order by\n>\n> 11.limit\n\n> 中间每一步都会生成一张虚拟表，如果需要的字段不在上一步的虚拟表中就会报错\n>\n> select中的别名不能用于select中，但是可以用于后面的步骤，比如order by\n\n- count(\\*),count(1),count(列名) \n\n> count(\\*)包含了所有的列，相当于行数，统计结果的时候不会忽略列值null*\n>\n> count(1)效果与count(*)相同\n>\n> count(列名)只包括列名那一列，统计结果的时候会忽略列值为空 null，为主键时执行快，不为主键时执行没有count(1)快 \n\n- rank,dense_rank(不跳过),row_number \n\n  窗口函数运行在having语句之后，order by之前。\n\n  ```mysql\n  select * rank() over (partition by xx order by yy desc)  as rnk from oo order by zz;\n  ```\n\n[leetcode176SecondHighestSalary](https://leetcode.com/problems/second-highest-salary/description/)\n\n- limit 1 offset 1，从第一条开始（offset1）取一条\n- limit 2,1 从第二条开始去一条，即取第二条 \n- ifnull(xx,null) as xx\n\n```mysql\nselect ifnull((select distinct Salary \nfrom Employee order by Salary desc limit 1,1),null) as SecondHighestSalary;\n```\n\n[leetcode177NthHighestSalary](https://leetcode.com/problems/nth-highest-salary/)\n\n```mysql\ncreate function getNthHighestSalary(N int) returns int\nbegin\ndeclare M int;\nset M=N-1;\n\treturn(\n        select distinct Salary from Employee order by Salary desc limit M,1\n    );\nend\n```\n\n[leetcode178:RankScore](https://leetcode.com/problems/rank-scores/)\n\n```mysql\nselect Score,\n(select count(*) from (select distinct Score s from Scores) tmp where s >= Score) Rank\nfrom Scores order by Score desc;\n```\n\n[leetcode197:Rising Temperature](https://leetcode.com/problems/rising-temperature/)\n\ndatediff函数\n\n```mysql\n#找出比前一天温度高的Id\nselect weather.Id\nfrom weather join weather w on DATEDIFF(weather.RecordDate,w.RecordDate) = 1\nand weather.Temperature > w.Temperature;\n\nselect w1.Id\nfrom Weather w1,Weather w2\nwhere w1.Temperature > w2.Temperature\nand to_days(w1.RecordDate)-to_days(w2.RecordDate)=1;\n```\n\npresto中的常用日期处理函数：\n\n```mysql\ndate_diff('day',cast(xx_time as date),cast(yy_time as date)) as zz_time\ndate_trunc('year',t1.xx_time)\nyear(xx_time)>2017\n```\n\n#### Shell\n\n[leetcode195:TenthLine](https://leetcode.com/problems/tenth-line/description/)\n\n```shell\ncnt=0\nwhile read line && [ $cnt -le 10 ];do\n\tlet 'cnt = cnt + 1'\n\tif [ $cnt -eq 10 ];then\n\t\techo $line\n\t\texit 0\n\tfi\ndone < file.txt\n\nawk 'FNR == 10 {print}' file.txt\nawk 'NR == 10' file.txt\n\nsed -n 10p file.txt\n\ntail -n+10 file.txt|head -1\n\nhead -10 file.txt | tail -1\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/刷题总结DayANight.md","raw":"---\ntitle: 刷题总结DayANight\ndate: 2018-8-31 00:32:30\ntags: [coding,Java,SQL,Shell]\n---\n\nRT!\n\n<!--more-->\n\n```c\n//孪生素数\n//在定义变量时，*定义的是指针，&定义的是引用\n//在使用时，*是解指针，&是取地址\n#include \"stdio.h\"\nint isPrime(int n)\n{\n    int i;\n    if(n < 2)\n        return 0;\n    for(i=2;i*i<=n;i++)\n        if(n%i==0)\n            return 0;\n    return 1;\n}\nint main()\n{\n    int a,b,flag=1;\n    scanf(\"%d %d\",&a,&b);\n    for(;a+2<=b;a++)\n        if(isPrime(a&&isPrime(a+2)))\n            flag=0,printf(%d,%d\\n,a,a+2);\n    if(flag)\n        printf(\"-1\\n\");\n    return 0;\n}\n```\n\n\n\n\n\n```c\n//A+B\n#define INT_MAX 2147483647\n#define INT_MIN (-INT_MAX-1)\n\nint reverseInt(int x){\n    int result = 0;\n    while(x != 0){\n        int tmp = x % 10;\n        if(result > INT_MAX/10 || result < INT_MIN/10) return 0;\n        result = result*10 + tmp;    \n    }\n    return result;\n}\n```\n\n### 树\n\n```java\npublic class TreeNode{\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val){\n        this.val = val;\n    }\n}\n```\n\n前序遍历\n\n```java\npublic List<Integer> preorderTraversal(TreeNode root){\n    ArrayList<Integer> res = new ArrayList<>();\n    if(root == null) return res;\n    Stack<TreeNode> stack = new Stack<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        root = stack.pop();\n        res.add(root.val);\n        if(root.right != null) stack.push(root.right);\n        if(root.left != null) stack.push(root.left);\n    }\n    return res;\n}\n```\n\n中序遍历\n\n```java\npublic List<Integer> inorderTraversal(TreeNode root){\n    ArrayList<Integer> res = new ArrayList<>();\n    if(root == null) return res;\n    Stack<TreeNode> stack = new Stack<>();\n    while(root != null || !stack.isEmpty()){\n        while(root.left != null){\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        res.add(root.val);\n        root = root.right;\n    }\n    return res;\n}\n```\n\n后序遍历\n\n```java\npublic List<Integer> postorderTraversal(TreeNode root){\n    LinkedList<Integer> res = new LinkedList<>();\n    if(root == null) return res;\n    Stack<TreeNode> stack = new Stack<>();\n    stack.push(root);\n    while(!stack.isEmpty()){\n        root = stack.pop();\n        //链表擅长增删\n        res.addFirst(root.val);\n        if(root.left == null) stack.push(root.left);\n        if(root.right == null) stack.push(root.right);\n    }\n    return res;\n}\n```\n\n层序遍历\n\n```java\npublic List<List<Integer>> levelorderTraversal(TreeNode root){\n    List<List<Integer>> res = new ArrayList<>();\n    if(root == null) return res;\n    Queue<TreeNode> q = new LinkedList<>();\n    q.add(root);\n    while(!queue.isEmpty()){\n        int cnt = q.size();\n        List<Integer> sub = new ArrayList<>();\n        while(cnt -- > 0){\n            TreeNode tmp = q.poll();\n            if(tmp.left != null) q.add(tmp.left);\n            if(tmp.right != null) q.add(tmp.right);\n            sub.add(tmp.val);\n        }\n        res.add(sub);\n    }\n    return res;\n}\n/*\n队列的方法：\nadd offer\nremove poll\nelement peek\n区别：为空或者已满时是否抛出异常\n* */\n```\n\n二分查找\n\n```java\npublic class BinarySearch{\n    public int binarySearch(int[] nums,int target){\n        if(nums == null || nums.length == 0) return -1;\n        int left=0,right=nums.length-1;\n        while(left <= right){\n            int mid = left+(right-left)/2;\n            if(nums[mid]==target)\n                return mid;\n            else if(nums[mid] > target)\n                right = mid - 1;\n            else\n                left = mid + 1;\n        }\n        return -1;\n    }\n}\n```\n\n给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数\n\n```java\npublic void findNumsAppearedOnce(int[] nums,int num1[],int num2[]){\n\tint diff = 0;\n    for(int val:nums)\n        diff ^= val;\n    diff &= -diff;    //取出最右边两个不同的数的不同位\n    for(int val:nums){  //分成两组，两个不同的数字在不同组\n        if((val & diff) == 0)\n            num1[0] ^= val;\n        else\n            num2[0] ^= val;\n    }\n}\n```\n\n判断一棵树是否是另一棵树的子树\n\n```java\npublic class IsSubTree{\n    //t是否是s的子树\n    public boolean isSubTree(TreeNode s,TreeNode t){\n        if(s == null) return false;\n        if(isSameTree(s,t)) return true;\n        return isSubTree(s.left,t) || isSubTree(s.right,t);\n    }\n    private boolean isSameTree(TreeNode p,TreeNode q){\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val == q.val)\n            return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n}\n```\n\n归并排序\n\n```java\npublic class MergeSort<T extends Comparable<T>>{\n    public void sort(T[] nums){\n        sort(nums,0.nums.length-1);\n    }\n    public void sort(T[] nums,int l,int h){\n        if(h < l) return;\n        int m = l + (h-l)/2;\n        sort(nums,l,m);\n        sort(nums,m+1,h);\n        merge(nums,l,m,h);\n    }\n    public void merge(T[] nums,int l,int m,int h){\n        T[] tmp = (T[]) new Comparable[nums.length];\n        for(int k=l;k<h;k++)\n            tmp[k] = nums[k];\n        int i=l,j=m+1;\n        for(int k=l;k<h;k++){\n            if(i>m)\n                nums[k] = nums[j++];\n            else if(j > h)\n                nums[k] = nums[i++];\n            else if(nums[i].compareTo(nums[j]) < 0)\n                nums[k] = nums[i++];\n            else\n                nums[k] = nums[j++];\n        }\n    }\n}\n```\n\nString To Int\n\n考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index<s.length()\n\n```java\npublic class Atoi{\n    public int myAtoi(String s){\n        int index = 0;\n        int sign = 1;\n        int total = 0;\n        //空串\n        if(s.length() == 0) return 0;\n        //空格\n        while(index < s.length() && s.charAt(index) == ' ')\n            index ++;\n        //符号\n        if(index < s.length() && (s.charAt(index) == '+') || s.charAt(index) == '-'){\n            sign = s.charAt(index) == '+' ? 1:-1;\n            index ++;\n        }\n        //数字\n        while(index < s.length()){\n            int digit = s.charAt(index) - '0';\n            if(digit < 0 || digit > 9) break;\n            //判断溢出\n            if(Integer.MAX_VALUE/10 < total || (Integer.MAX_VALUE/10 == total && Integer.MAX_VALUE%10 < digit))\n                return sign > 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            total = total*10 + digit;\n            index ++;\n        }\n        return sign*total;\n    }\n}\n```\n\n求第k大的数(复杂度是多少？)\n\n```java\n/*\n时间复杂度O(n)，空间复杂度O(1)\n**/\npublic class FindKthLargestElem{    \n    public int findKthLargestElem(int[] nums,int k){\n        k = nums.length - k;\n        int l=0,h=nums.length - 1;\n        while(l <= h){\n            int j = partition(nums,l,h);\n            if(j == k) break;\n            else if(j < k)\n                l = j + 1;\n            else\n                h = j - 1;\n        }\n        return nums[k];\n    }\n    private int partition(int[] nums,int l,int h){\n        int i=l,j=h+1;\n        while(true){\n            while((nums[++i] < nums[l]) && i<h);\n            while((nums[--j] > nums[l]) && j>l);\n            if(i >= j) break;\n            swap(nums,i,j);\n        }\n        swap(nums,l,j);\n        return j;\n    }\n    private void swap(int[] nums,int j,int j){\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n```\n```java\npublic class TwoSum{\n    public int[] twoSum(int[] nums,int target){\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            int obj = target - nums[i];\n            if(map.containsKey(obj))\n                return new int[]{map.get(obj),i};\n            map.put(nums[i],i);\n        }\n        throw new IllegalArgumentException(\"No Solution!\");\n        //Throwable--Error/Exception[IllegalArgumentException]\n    }\n}\n\n//排序，二分查找\npublic class ThreeSum{\n    public List<List<Integer>> threeSum(int[] nums){\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        for(int i=0;i<nums.length;i++){\n            if(i>0 && nums[i]==nums[i-1])\n                continue;\n            int j=i+1,k=nums.length-1,target=-nums[i];\n            while(j<k){\n                if(nums[j]+nums[k]=target){\n                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));\n                    j++;\n                    k--;\n                    while(j<k && nums[j]==nums[j-1]) j++;\n                    while(j<k && nums[k]==nums[k+1]) k--;\n                }\n                else if(nums[j]+nums[k] < target)\n                    j++;\n                else\n                    k--;\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 链表\n\n```java\n//pre->curr->next\n//curr<-next\npublic class RverseLinkedList{\n    public ListNode reverseLinkedList(ListNode head){\n        ListNode prev = null;\n        ListNode curr = head;\n        while(curr != null){\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n    public ListNode reverseNodeRecurse(ListNode head){\n        if(head = null || head.next == null) return null;\n        ListNode p = reverseNodeRecurse(head.next);\n        head.next.next = head;\n        head.next = null;\n        return p;\n    }\n}\npublic class ListNode{\n    int val;\n    ListNode next;\n    ListNode(int val){\n        this.val = val;\n    }\n}\n\n//(2->4->3)+(5->6->4)=(7->0->8)\npublic class AddTwoNum{\n    public ListNode addTwoNums(ListNode l1,ListNode l2){\n        ListNode dummyHead = new ListNode(0);\n        ListNode p=l1,q=l2,curr=dummyHead;\n        int carry = 0;\n        while(p!=null || q!=null){\n            int x = p!=null ? p.val:0;\n            int y = q!=null ? q.val:0;\n            int sum = x+y+carry;\n            carry = sum/10;\n            curr.next = new ListNode(sum%10);\n            curr = curr.next;\n            if(p!=null) p=p.next;\n            if(q!=null) q=q.next;\n        }\n        if(carry > 0)\n            curr.next = new ListNode(carry);\n        return dummyHead.next;\n    }\n}\n\npublic class GetIntersection{\n    public ListNode getIntersection(ListNode headA,ListNode headB){\n        ListNode l1=headA,l2=headB;\n        while(l1 != l2){\n            l1 = l1 != null ? l1.next:headB;\n            l2 = l2 != null ? l2.next:headA;\n        }\n        return l1;\n    }\n}\n\npublic class RemoveNthFromEnd{\n    public ListNode removeNthFromEnd(ListNode head,int n){\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        while(n-- >= 0)\n            fast = fast.next;\n        while(fast != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return dummy.next;\n    }\n}\n```\n\n### LeetCode\n\n#### 数据结构\n\n查找数在排序数组中插入位置\n\n```python\nsorted(lst + [target]).index(target)\nlen([x for x in lst if x < target])\nbisect.bisect_right(lst, target) #bisect_left\n```\n\n#### SQL\n\n执行顺序：\n\n> 1.from\n>\n> 2.on\n>\n> 3.join\n>\n> 4.where\n>\n> 5.group by\n>\n> 6.with、聚合（avg，sum）\n>\n> 7.having\n>\n> 8.select\n>\n> 9.distinct\n>\n> 10.order by\n>\n> 11.limit\n\n> 中间每一步都会生成一张虚拟表，如果需要的字段不在上一步的虚拟表中就会报错\n>\n> select中的别名不能用于select中，但是可以用于后面的步骤，比如order by\n\n- count(\\*),count(1),count(列名) \n\n> count(\\*)包含了所有的列，相当于行数，统计结果的时候不会忽略列值null*\n>\n> count(1)效果与count(*)相同\n>\n> count(列名)只包括列名那一列，统计结果的时候会忽略列值为空 null，为主键时执行快，不为主键时执行没有count(1)快 \n\n- rank,dense_rank(不跳过),row_number \n\n  窗口函数运行在having语句之后，order by之前。\n\n  ```mysql\n  select * rank() over (partition by xx order by yy desc)  as rnk from oo order by zz;\n  ```\n\n[leetcode176SecondHighestSalary](https://leetcode.com/problems/second-highest-salary/description/)\n\n- limit 1 offset 1，从第一条开始（offset1）取一条\n- limit 2,1 从第二条开始去一条，即取第二条 \n- ifnull(xx,null) as xx\n\n```mysql\nselect ifnull((select distinct Salary \nfrom Employee order by Salary desc limit 1,1),null) as SecondHighestSalary;\n```\n\n[leetcode177NthHighestSalary](https://leetcode.com/problems/nth-highest-salary/)\n\n```mysql\ncreate function getNthHighestSalary(N int) returns int\nbegin\ndeclare M int;\nset M=N-1;\n\treturn(\n        select distinct Salary from Employee order by Salary desc limit M,1\n    );\nend\n```\n\n[leetcode178:RankScore](https://leetcode.com/problems/rank-scores/)\n\n```mysql\nselect Score,\n(select count(*) from (select distinct Score s from Scores) tmp where s >= Score) Rank\nfrom Scores order by Score desc;\n```\n\n[leetcode197:Rising Temperature](https://leetcode.com/problems/rising-temperature/)\n\ndatediff函数\n\n```mysql\n#找出比前一天温度高的Id\nselect weather.Id\nfrom weather join weather w on DATEDIFF(weather.RecordDate,w.RecordDate) = 1\nand weather.Temperature > w.Temperature;\n\nselect w1.Id\nfrom Weather w1,Weather w2\nwhere w1.Temperature > w2.Temperature\nand to_days(w1.RecordDate)-to_days(w2.RecordDate)=1;\n```\n\npresto中的常用日期处理函数：\n\n```mysql\ndate_diff('day',cast(xx_time as date),cast(yy_time as date)) as zz_time\ndate_trunc('year',t1.xx_time)\nyear(xx_time)>2017\n```\n\n#### Shell\n\n[leetcode195:TenthLine](https://leetcode.com/problems/tenth-line/description/)\n\n```shell\ncnt=0\nwhile read line && [ $cnt -le 10 ];do\n\tlet 'cnt = cnt + 1'\n\tif [ $cnt -eq 10 ];then\n\t\techo $line\n\t\texit 0\n\tfi\ndone < file.txt\n\nawk 'FNR == 10 {print}' file.txt\nawk 'NR == 10' file.txt\n\nsed -n 10p file.txt\n\ntail -n+10 file.txt|head -1\n\nhead -10 file.txt | tail -1\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"刷题总结DayANight","published":1,"updated":"2019-08-01T15:33:39.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2re000kqsezpbg0ufsg","content":"<p>RT!</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//孪生素数</span></span><br><span class=\"line\"><span class=\"comment\">//在定义变量时，*定义的是指针，&amp;定义的是引用</span></span><br><span class=\"line\"><span class=\"comment\">//在使用时，*是解指针，&amp;是取地址</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>;i*i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;a+<span class=\"number\">2</span>&lt;=b;a++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isPrime(a&amp;&amp;isPrime(a+<span class=\"number\">2</span>)))</span><br><span class=\"line\">            flag=<span class=\"number\">0</span>,<span class=\"built_in\">printf</span>(%d,%d\\n,a,a+<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//A+B</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INT_MAX 2147483647</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INT_MIN (-INT_MAX-1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverseInt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result &gt; INT_MAX/<span class=\"number\">10</span> || result &lt; INT_MIN/<span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = result*<span class=\"number\">10</span> + tmp;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    TreeNode left;</span><br><span class=\"line\">    TreeNode right;</span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right != <span class=\"keyword\">null</span>) stack.push(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left != <span class=\"keyword\">null</span>) stack.push(root.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root != <span class=\"keyword\">null</span> || !stack.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            stack.push(root);</span><br><span class=\"line\">            root = root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        root = root.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; res = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        <span class=\"comment\">//链表擅长增删</span></span><br><span class=\"line\">        res.addFirst(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left == <span class=\"keyword\">null</span>) stack.push(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right == <span class=\"keyword\">null</span>) stack.push(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>层序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelorderTraversal(TreeNode root)&#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Queue&lt;TreeNode&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    q.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = q.size();</span><br><span class=\"line\">        List&lt;Integer&gt; sub = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cnt -- &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            TreeNode tmp = q.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.left != <span class=\"keyword\">null</span>) q.add(tmp.left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.right != <span class=\"keyword\">null</span>) q.add(tmp.right);</span><br><span class=\"line\">            sub.add(tmp.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.add(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">队列的方法：</span></span><br><span class=\"line\"><span class=\"comment\">add offer</span></span><br><span class=\"line\"><span class=\"comment\">remove poll</span></span><br><span class=\"line\"><span class=\"comment\">element peek</span></span><br><span class=\"line\"><span class=\"comment\">区别：为空或者已满时是否抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br></pre></td></tr></table></figure>\n<p>二分查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearch</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>,right=nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left+(right-left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid]==target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &gt; target)</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">findNumsAppearedOnce</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> num1[],<span class=\"keyword\">int</span> num2[])</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> val:nums)</span><br><span class=\"line\">        diff ^= val;</span><br><span class=\"line\">    diff &amp;= -diff;    <span class=\"comment\">//取出最右边两个不同的数的不同位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> val:nums)&#123;  <span class=\"comment\">//分成两组，两个不同的数字在不同组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((val &amp; diff) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            num1[<span class=\"number\">0</span>] ^= val;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            num2[<span class=\"number\">0</span>] ^= val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>判断一棵树是否是另一棵树的子树</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IsSubTree</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//t是否是s的子树</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubTree</span><span class=\"params\">(TreeNode s,TreeNode t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isSameTree(s,t)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSubTree(s.left,t) || isSubTree(s.right,t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.val == q.val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>归并排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergeSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        sort(nums,<span class=\"number\">0</span>.nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(h &lt; l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = l + (h-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        sort(nums,l,m);</span><br><span class=\"line\">        sort(nums,m+<span class=\"number\">1</span>,h);</span><br><span class=\"line\">        merge(nums,l,m,h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        T[] tmp = (T[]) <span class=\"keyword\">new</span> Comparable[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;h;k++)</span><br><span class=\"line\">            tmp[k] = nums[k];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=l,j=m+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;h;k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;m)</span><br><span class=\"line\">                nums[k] = nums[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &gt; h)</span><br><span class=\"line\">                nums[k] = nums[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i].compareTo(nums[j]) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                nums[k] = nums[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                nums[k] = nums[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>String To Int</p>\n<p>考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index&lt;s.length()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Atoi</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">myAtoi</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//空串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//空格</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index &lt; s.length() &amp;&amp; s.charAt(index) == <span class=\"string\">' '</span>)</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        <span class=\"comment\">//符号</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &lt; s.length() &amp;&amp; (s.charAt(index) == <span class=\"string\">'+'</span>) || s.charAt(index) == <span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">            sign = s.charAt(index) == <span class=\"string\">'+'</span> ? <span class=\"number\">1</span>:-<span class=\"number\">1</span>;</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//数字</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> digit = s.charAt(index) - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(digit &lt; <span class=\"number\">0</span> || digit &gt; <span class=\"number\">9</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">//判断溢出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Integer.MAX_VALUE/<span class=\"number\">10</span> &lt; total || (Integer.MAX_VALUE/<span class=\"number\">10</span> == total &amp;&amp; Integer.MAX_VALUE%<span class=\"number\">10</span> &lt; digit))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sign &gt; <span class=\"number\">0</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class=\"line\">            total = total*<span class=\"number\">10</span> + digit;</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sign*total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>求第k大的数(复杂度是多少？)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度O(n)，空间复杂度O(1)</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindKthLargestElem</span></span>&#123;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargestElem</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        k = nums.length - k;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l=<span class=\"number\">0</span>,h=nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= h)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = partition(nums,l,h);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j == k) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &lt; k)</span><br><span class=\"line\">                l = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                h = j - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=l,j=h+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((nums[++i] &lt; nums[l]) &amp;&amp; i&lt;h);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((nums[--j] &gt; nums[l]) &amp;&amp; j&gt;l);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(nums,i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums,l,j);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> j,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TwoSum</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> obj = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(obj))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;map.get(obj),i&#125;;</span><br><span class=\"line\">            map.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"No Solution!\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Throwable--Error/Exception[IllegalArgumentException]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//排序，二分查找</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreeSum</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums)&#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i-<span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>,k=nums.length-<span class=\"number\">1</span>,target=-nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j&lt;k)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j]+nums[k]=target)&#123;</span><br><span class=\"line\">                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                    k--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(j&lt;k &amp;&amp; nums[j]==nums[j-<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(j&lt;k &amp;&amp; nums[k]==nums[k+<span class=\"number\">1</span>]) k--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[j]+nums[k] &lt; target)</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//pre-&gt;curr-&gt;next</span></span><br><span class=\"line\"><span class=\"comment\">//curr&lt;-next</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RverseLinkedList</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseLinkedList</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">        ListNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode curr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ListNode next = curr.next;</span><br><span class=\"line\">            curr.next = prev;</span><br><span class=\"line\">            prev = curr;</span><br><span class=\"line\">            curr = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseNodeRecurse</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head = <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode p = reverseNodeRecurse(head.next);</span><br><span class=\"line\">        head.next.next = head;</span><br><span class=\"line\">        head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//(2-&gt;4-&gt;3)+(5-&gt;6-&gt;4)=(7-&gt;0-&gt;8)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddTwoNum</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNums</span><span class=\"params\">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class=\"line\">        ListNode dummyHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode p=l1,q=l2,curr=dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"keyword\">null</span> || q!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = p!=<span class=\"keyword\">null</span> ? p.val:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = q!=<span class=\"keyword\">null</span> ? q.val:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = x+y+carry;</span><br><span class=\"line\">            carry = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">            curr = curr.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p!=<span class=\"keyword\">null</span>) p=p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q!=<span class=\"keyword\">null</span>) q=q.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(carry &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetIntersection</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersection</span><span class=\"params\">(ListNode headA,ListNode headB)</span></span>&#123;</span><br><span class=\"line\">        ListNode l1=headA,l2=headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != l2)&#123;</span><br><span class=\"line\">            l1 = l1 != <span class=\"keyword\">null</span> ? l1.next:headB;</span><br><span class=\"line\">            l2 = l2 != <span class=\"keyword\">null</span> ? l2.next:headA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RemoveNthFromEnd</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode fast = dummy;</span><br><span class=\"line\">        ListNode slow = dummy;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow.next = slow.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode\"><a href=\"#LeetCode\" class=\"headerlink\" title=\"LeetCode\"></a>LeetCode</h3><h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><p>查找数在排序数组中插入位置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sorted(lst + [target]).index(target)</span><br><span class=\"line\">len([x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> lst <span class=\"keyword\">if</span> x &lt; target])</span><br><span class=\"line\">bisect.bisect_right(lst, target) <span class=\"comment\">#bisect_left</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h4><p>执行顺序：</p>\n<blockquote>\n<p>1.from</p>\n<p>2.on</p>\n<p>3.join</p>\n<p>4.where</p>\n<p>5.group by</p>\n<p>6.with、聚合（avg，sum）</p>\n<p>7.having</p>\n<p>8.select</p>\n<p>9.distinct</p>\n<p>10.order by</p>\n<p>11.limit</p>\n</blockquote>\n<blockquote>\n<p>中间每一步都会生成一张虚拟表，如果需要的字段不在上一步的虚拟表中就会报错</p>\n<p>select中的别名不能用于select中，但是可以用于后面的步骤，比如order by</p>\n</blockquote>\n<ul>\n<li>count(*),count(1),count(列名) </li>\n</ul>\n<blockquote>\n<p>count(*)包含了所有的列，相当于行数，统计结果的时候不会忽略列值null*</p>\n<p>count(1)效果与count(*)相同</p>\n<p>count(列名)只包括列名那一列，统计结果的时候会忽略列值为空 null，为主键时执行快，不为主键时执行没有count(1)快 </p>\n</blockquote>\n<ul>\n<li><p>rank,dense_rank(不跳过),row_number </p>\n<p>窗口函数运行在having语句之后，order by之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * rank() over (partition by xx order by yy desc)  as rnk from oo order by zz;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"https://leetcode.com/problems/second-highest-salary/description/\" target=\"_blank\" rel=\"noopener\">leetcode176SecondHighestSalary</a></p>\n<ul>\n<li>limit 1 offset 1，从第一条开始（offset1）取一条</li>\n<li>limit 2,1 从第二条开始去一条，即取第二条 </li>\n<li>ifnull(xx,null) as xx</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ifnull((select distinct Salary </span><br><span class=\"line\">from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/nth-highest-salary/\" target=\"_blank\" rel=\"noopener\">leetcode177NthHighestSalary</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create function getNthHighestSalary(N int) returns int</span><br><span class=\"line\">begin</span><br><span class=\"line\">declare M int;</span><br><span class=\"line\">set M=N-1;</span><br><span class=\"line\">\treturn(</span><br><span class=\"line\">        select distinct Salary from Employee order by Salary desc limit M,1</span><br><span class=\"line\">    );</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/rank-scores/\" target=\"_blank\" rel=\"noopener\">leetcode178:RankScore</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Score,</span><br><span class=\"line\">(select count(*) from (select distinct Score s from Scores) tmp where s &gt;= Score) Rank</span><br><span class=\"line\">from Scores order by Score desc;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/rising-temperature/\" target=\"_blank\" rel=\"noopener\">leetcode197:Rising Temperature</a></p>\n<p>datediff函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#找出比前一天温度高的Id</span><br><span class=\"line\">select weather.Id</span><br><span class=\"line\">from weather join weather w on DATEDIFF(weather.RecordDate,w.RecordDate) = 1</span><br><span class=\"line\">and weather.Temperature &gt; w.Temperature;</span><br><span class=\"line\"></span><br><span class=\"line\">select w1.Id</span><br><span class=\"line\">from Weather w1,Weather w2</span><br><span class=\"line\">where w1.Temperature &gt; w2.Temperature</span><br><span class=\"line\">and to_days(w1.RecordDate)-to_days(w2.RecordDate)=1;</span><br></pre></td></tr></table></figure>\n<p>presto中的常用日期处理函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date_diff(&apos;day&apos;,cast(xx_time as date),cast(yy_time as date)) as zz_time</span><br><span class=\"line\">date_trunc(&apos;year&apos;,t1.xx_time)</span><br><span class=\"line\">year(xx_time)&gt;2017</span><br></pre></td></tr></table></figure>\n<h4 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h4><p><a href=\"https://leetcode.com/problems/tenth-line/description/\" target=\"_blank\" rel=\"noopener\">leetcode195:TenthLine</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnt=0</span><br><span class=\"line\">while read line &amp;&amp; [ $cnt -le 10 ];do</span><br><span class=\"line\">\tlet 'cnt = cnt + 1'</span><br><span class=\"line\">\tif [ $cnt -eq 10 ];then</span><br><span class=\"line\">\t\techo $line</span><br><span class=\"line\">\t\texit 0</span><br><span class=\"line\">\tfi</span><br><span class=\"line\">done &lt; file.txt</span><br><span class=\"line\"></span><br><span class=\"line\">awk 'FNR == 10 &#123;print&#125;' file.txt</span><br><span class=\"line\">awk 'NR == 10' file.txt</span><br><span class=\"line\"></span><br><span class=\"line\">sed -n 10p file.txt</span><br><span class=\"line\"></span><br><span class=\"line\">tail -n+10 file.txt|head -1</span><br><span class=\"line\"></span><br><span class=\"line\">head -10 file.txt | tail -1</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>RT!</p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//孪生素数</span></span><br><span class=\"line\"><span class=\"comment\">//在定义变量时，*定义的是指针，&amp;定义的是引用</span></span><br><span class=\"line\"><span class=\"comment\">//在使用时，*是解指针，&amp;是取地址</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stdio.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isPrime</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>;i*i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;a+<span class=\"number\">2</span>&lt;=b;a++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isPrime(a&amp;&amp;isPrime(a+<span class=\"number\">2</span>)))</span><br><span class=\"line\">            flag=<span class=\"number\">0</span>,<span class=\"built_in\">printf</span>(%d,%d\\n,a,a+<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//A+B</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INT_MAX 2147483647</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INT_MIN (-INT_MAX-1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverseInt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result &gt; INT_MAX/<span class=\"number\">10</span> || result &lt; INT_MIN/<span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = result*<span class=\"number\">10</span> + tmp;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    TreeNode left;</span><br><span class=\"line\">    TreeNode right;</span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right != <span class=\"keyword\">null</span>) stack.push(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left != <span class=\"keyword\">null</span>) stack.push(root.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(root != <span class=\"keyword\">null</span> || !stack.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            stack.push(root);</span><br><span class=\"line\">            root = root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        root = root.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; res = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">        root = stack.pop();</span><br><span class=\"line\">        <span class=\"comment\">//链表擅长增删</span></span><br><span class=\"line\">        res.addFirst(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left == <span class=\"keyword\">null</span>) stack.push(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right == <span class=\"keyword\">null</span>) stack.push(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>层序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelorderTraversal(TreeNode root)&#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    Queue&lt;TreeNode&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    q.add(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = q.size();</span><br><span class=\"line\">        List&lt;Integer&gt; sub = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cnt -- &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            TreeNode tmp = q.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.left != <span class=\"keyword\">null</span>) q.add(tmp.left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.right != <span class=\"keyword\">null</span>) q.add(tmp.right);</span><br><span class=\"line\">            sub.add(tmp.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.add(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">队列的方法：</span></span><br><span class=\"line\"><span class=\"comment\">add offer</span></span><br><span class=\"line\"><span class=\"comment\">remove poll</span></span><br><span class=\"line\"><span class=\"comment\">element peek</span></span><br><span class=\"line\"><span class=\"comment\">区别：为空或者已满时是否抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br></pre></td></tr></table></figure>\n<p>二分查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinarySearch</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>,right=nums.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left+(right-left)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid]==target)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &gt; target)</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给一个数组，除了两个数字只出现一次，其他的都出现两次，找出这两个数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">findNumsAppearedOnce</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> num1[],<span class=\"keyword\">int</span> num2[])</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> val:nums)</span><br><span class=\"line\">        diff ^= val;</span><br><span class=\"line\">    diff &amp;= -diff;    <span class=\"comment\">//取出最右边两个不同的数的不同位</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> val:nums)&#123;  <span class=\"comment\">//分成两组，两个不同的数字在不同组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((val &amp; diff) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            num1[<span class=\"number\">0</span>] ^= val;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            num2[<span class=\"number\">0</span>] ^= val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>判断一棵树是否是另一棵树的子树</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IsSubTree</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//t是否是s的子树</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubTree</span><span class=\"params\">(TreeNode s,TreeNode t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isSameTree(s,t)) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSubTree(s.left,t) || isSubTree(s.right,t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p.val == q.val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>归并排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergeSort</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt;&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums)</span></span>&#123;</span><br><span class=\"line\">        sort(nums,<span class=\"number\">0</span>.nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(h &lt; l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = l + (h-l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        sort(nums,l,m);</span><br><span class=\"line\">        sort(nums,m+<span class=\"number\">1</span>,h);</span><br><span class=\"line\">        merge(nums,l,m,h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(T[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        T[] tmp = (T[]) <span class=\"keyword\">new</span> Comparable[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;h;k++)</span><br><span class=\"line\">            tmp[k] = nums[k];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=l,j=m+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=l;k&lt;h;k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;m)</span><br><span class=\"line\">                nums[k] = nums[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &gt; h)</span><br><span class=\"line\">                nums[k] = nums[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i].compareTo(nums[j]) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                nums[k] = nums[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                nums[k] = nums[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>String To Int</p>\n<p>考虑：判断空串、判断空格、判断符号、判断数字（判断溢出）,注意index&lt;s.length()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Atoi</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">myAtoi</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//空串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//空格</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index &lt; s.length() &amp;&amp; s.charAt(index) == <span class=\"string\">' '</span>)</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        <span class=\"comment\">//符号</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &lt; s.length() &amp;&amp; (s.charAt(index) == <span class=\"string\">'+'</span>) || s.charAt(index) == <span class=\"string\">'-'</span>)&#123;</span><br><span class=\"line\">            sign = s.charAt(index) == <span class=\"string\">'+'</span> ? <span class=\"number\">1</span>:-<span class=\"number\">1</span>;</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//数字</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> digit = s.charAt(index) - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(digit &lt; <span class=\"number\">0</span> || digit &gt; <span class=\"number\">9</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">//判断溢出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Integer.MAX_VALUE/<span class=\"number\">10</span> &lt; total || (Integer.MAX_VALUE/<span class=\"number\">10</span> == total &amp;&amp; Integer.MAX_VALUE%<span class=\"number\">10</span> &lt; digit))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sign &gt; <span class=\"number\">0</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class=\"line\">            total = total*<span class=\"number\">10</span> + digit;</span><br><span class=\"line\">            index ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sign*total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>求第k大的数(复杂度是多少？)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度O(n)，空间复杂度O(1)</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindKthLargestElem</span></span>&#123;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findKthLargestElem</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        k = nums.length - k;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l=<span class=\"number\">0</span>,h=nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= h)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = partition(nums,l,h);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j == k) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &lt; k)</span><br><span class=\"line\">                l = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                h = j - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> h)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=l,j=h+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((nums[++i] &lt; nums[l]) &amp;&amp; i&lt;h);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((nums[--j] &gt; nums[l]) &amp;&amp; j&gt;l);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            swap(nums,i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums,l,j);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> j,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TwoSum</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> obj = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(obj))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;map.get(obj),i&#125;;</span><br><span class=\"line\">            map.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"No Solution!\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//Throwable--Error/Exception[IllegalArgumentException]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//排序，二分查找</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreeSum</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] nums)&#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i-<span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>,k=nums.length-<span class=\"number\">1</span>,target=-nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j&lt;k)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j]+nums[k]=target)&#123;</span><br><span class=\"line\">                    res.add(Arrays.asList(nums[i],nums[j],nums[k]));</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                    k--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(j&lt;k &amp;&amp; nums[j]==nums[j-<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(j&lt;k &amp;&amp; nums[k]==nums[k+<span class=\"number\">1</span>]) k--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[j]+nums[k] &lt; target)</span><br><span class=\"line\">                    j++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//pre-&gt;curr-&gt;next</span></span><br><span class=\"line\"><span class=\"comment\">//curr&lt;-next</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RverseLinkedList</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseLinkedList</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">        ListNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode curr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ListNode next = curr.next;</span><br><span class=\"line\">            curr.next = prev;</span><br><span class=\"line\">            prev = curr;</span><br><span class=\"line\">            curr = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseNodeRecurse</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head = <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ListNode p = reverseNodeRecurse(head.next);</span><br><span class=\"line\">        head.next.next = head;</span><br><span class=\"line\">        head.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//(2-&gt;4-&gt;3)+(5-&gt;6-&gt;4)=(7-&gt;0-&gt;8)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddTwoNum</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNums</span><span class=\"params\">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class=\"line\">        ListNode dummyHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode p=l1,q=l2,curr=dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"keyword\">null</span> || q!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = p!=<span class=\"keyword\">null</span> ? p.val:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = q!=<span class=\"keyword\">null</span> ? q.val:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = x+y+carry;</span><br><span class=\"line\">            carry = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(sum%<span class=\"number\">10</span>);</span><br><span class=\"line\">            curr = curr.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p!=<span class=\"keyword\">null</span>) p=p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q!=<span class=\"keyword\">null</span>) q=q.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(carry &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            curr.next = <span class=\"keyword\">new</span> ListNode(carry);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetIntersection</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersection</span><span class=\"params\">(ListNode headA,ListNode headB)</span></span>&#123;</span><br><span class=\"line\">        ListNode l1=headA,l2=headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != l2)&#123;</span><br><span class=\"line\">            l1 = l1 != <span class=\"keyword\">null</span> ? l1.next:headB;</span><br><span class=\"line\">            l2 = l2 != <span class=\"keyword\">null</span> ? l2.next:headA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RemoveNthFromEnd</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode fast = dummy;</span><br><span class=\"line\">        ListNode slow = dummy;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow.next = slow.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode\"><a href=\"#LeetCode\" class=\"headerlink\" title=\"LeetCode\"></a>LeetCode</h3><h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><p>查找数在排序数组中插入位置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sorted(lst + [target]).index(target)</span><br><span class=\"line\">len([x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> lst <span class=\"keyword\">if</span> x &lt; target])</span><br><span class=\"line\">bisect.bisect_right(lst, target) <span class=\"comment\">#bisect_left</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h4><p>执行顺序：</p>\n<blockquote>\n<p>1.from</p>\n<p>2.on</p>\n<p>3.join</p>\n<p>4.where</p>\n<p>5.group by</p>\n<p>6.with、聚合（avg，sum）</p>\n<p>7.having</p>\n<p>8.select</p>\n<p>9.distinct</p>\n<p>10.order by</p>\n<p>11.limit</p>\n</blockquote>\n<blockquote>\n<p>中间每一步都会生成一张虚拟表，如果需要的字段不在上一步的虚拟表中就会报错</p>\n<p>select中的别名不能用于select中，但是可以用于后面的步骤，比如order by</p>\n</blockquote>\n<ul>\n<li>count(*),count(1),count(列名) </li>\n</ul>\n<blockquote>\n<p>count(*)包含了所有的列，相当于行数，统计结果的时候不会忽略列值null*</p>\n<p>count(1)效果与count(*)相同</p>\n<p>count(列名)只包括列名那一列，统计结果的时候会忽略列值为空 null，为主键时执行快，不为主键时执行没有count(1)快 </p>\n</blockquote>\n<ul>\n<li><p>rank,dense_rank(不跳过),row_number </p>\n<p>窗口函数运行在having语句之后，order by之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * rank() over (partition by xx order by yy desc)  as rnk from oo order by zz;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"https://leetcode.com/problems/second-highest-salary/description/\" target=\"_blank\" rel=\"noopener\">leetcode176SecondHighestSalary</a></p>\n<ul>\n<li>limit 1 offset 1，从第一条开始（offset1）取一条</li>\n<li>limit 2,1 从第二条开始去一条，即取第二条 </li>\n<li>ifnull(xx,null) as xx</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ifnull((select distinct Salary </span><br><span class=\"line\">from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/nth-highest-salary/\" target=\"_blank\" rel=\"noopener\">leetcode177NthHighestSalary</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create function getNthHighestSalary(N int) returns int</span><br><span class=\"line\">begin</span><br><span class=\"line\">declare M int;</span><br><span class=\"line\">set M=N-1;</span><br><span class=\"line\">\treturn(</span><br><span class=\"line\">        select distinct Salary from Employee order by Salary desc limit M,1</span><br><span class=\"line\">    );</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/rank-scores/\" target=\"_blank\" rel=\"noopener\">leetcode178:RankScore</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select Score,</span><br><span class=\"line\">(select count(*) from (select distinct Score s from Scores) tmp where s &gt;= Score) Rank</span><br><span class=\"line\">from Scores order by Score desc;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.com/problems/rising-temperature/\" target=\"_blank\" rel=\"noopener\">leetcode197:Rising Temperature</a></p>\n<p>datediff函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#找出比前一天温度高的Id</span><br><span class=\"line\">select weather.Id</span><br><span class=\"line\">from weather join weather w on DATEDIFF(weather.RecordDate,w.RecordDate) = 1</span><br><span class=\"line\">and weather.Temperature &gt; w.Temperature;</span><br><span class=\"line\"></span><br><span class=\"line\">select w1.Id</span><br><span class=\"line\">from Weather w1,Weather w2</span><br><span class=\"line\">where w1.Temperature &gt; w2.Temperature</span><br><span class=\"line\">and to_days(w1.RecordDate)-to_days(w2.RecordDate)=1;</span><br></pre></td></tr></table></figure>\n<p>presto中的常用日期处理函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date_diff(&apos;day&apos;,cast(xx_time as date),cast(yy_time as date)) as zz_time</span><br><span class=\"line\">date_trunc(&apos;year&apos;,t1.xx_time)</span><br><span class=\"line\">year(xx_time)&gt;2017</span><br></pre></td></tr></table></figure>\n<h4 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h4><p><a href=\"https://leetcode.com/problems/tenth-line/description/\" target=\"_blank\" rel=\"noopener\">leetcode195:TenthLine</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnt=0</span><br><span class=\"line\">while read line &amp;&amp; [ $cnt -le 10 ];do</span><br><span class=\"line\">\tlet 'cnt = cnt + 1'</span><br><span class=\"line\">\tif [ $cnt -eq 10 ];then</span><br><span class=\"line\">\t\techo $line</span><br><span class=\"line\">\t\texit 0</span><br><span class=\"line\">\tfi</span><br><span class=\"line\">done &lt; file.txt</span><br><span class=\"line\"></span><br><span class=\"line\">awk 'FNR == 10 &#123;print&#125;' file.txt</span><br><span class=\"line\">awk 'NR == 10' file.txt</span><br><span class=\"line\"></span><br><span class=\"line\">sed -n 10p file.txt</span><br><span class=\"line\"></span><br><span class=\"line\">tail -n+10 file.txt|head -1</span><br><span class=\"line\"></span><br><span class=\"line\">head -10 file.txt | tail -1</span><br></pre></td></tr></table></figure>"},{"title":"Java&Python","date":"2018-08-19T16:33:45.000Z","_content":"\nJava和Python的一些基础知识总结\n\n<!--more-->\n\n多线程、多进程、同步、异步、阻塞、非阻塞\n\n多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 \n\n同步才有阻塞和非阻塞之分\n\n同步：执行一个操作后等待结果，然后再继续后面的操作\n\n阻塞：进程给cpu传达一个任务后，一直等待cpu处理完成再进行后续操作\n\n非阻塞：进程给cpu传达一个任务后，继续处理后续操作，隔段时间再询问之前操作是否完成，也称轮询\n\n异步：执行一个操作后，可以去执行其他操作，等待通知再回来执行未完成操作 \n\n### Java\n\n##### 常用类\n\nCollection：\n\n java.util.Collection(接口) --extends java.lang.Iterable ，每一个位置存一个元素，没有get方法，只能通过iterator() 遍历元素\n\n- List【维护一组元素特定顺序】\n  - **ArrayList**【查询快，基于arrays数组实现】\n  - **LinkedList**【增删快，常用作队列】\n  - **Vector**【实现同步，线程安全】\n- Queue\n  - **PriorityQueue**【基于堆结构实现】\n- Set【每个元素唯一】\n  - SortedSet\n    - **TreeSet**【保持次序的set，基于红黑树实现，查找效率不如hashset】\n  - **HashSet**【定义了hashcode，支持快速查找，不支持有序性操作，使用iterator遍历的结果可能是不确定的】\n  - **LinkedHashSet**【hash加快查询，链表维护元素次序，只能顺序访问，可以快速增删】\n  \nMap：\n\njava.util.Map(接口)      （key-value pair）\n\n- **HashMap**\n- **HashTable**【线程安全】\n- **ConcurrentHashMap**【支持线程安全，且效率更高】\n- **LinkedHashMap**【使用链表维护元素顺序(插入顺序、LRU顺序)】\n- SortedMap\n  - **TreeMap**\n\narray：容量固定且无法动态改变\n**Arrays**：操作array的类，拥有一组静态函数\n```java\nInteger[] arr = {1,2,3};\nList list = Arrays.asList();\n```\n**Collections**：和Arrays一样是工具类\n**包装类**：\n- 对象型：Boolean、Character(object的直接子类)\n- 数值型：Byte、Double、Short、Integer、Float\n基本数据类型：boolean、byte、char、short、int、float、long、double\n包装类和基本类型的转化是自动拆箱装箱的，java把一些基本类型的常用对象存储在缓存池中，调用valueOf() 方法直接使用缓存池中的对象\n> valueOf() 和new 对象区别：new出来的对象虽然值一样但是不是同一个对象，所以x!=y\n\n> java不能隐式执行下转型1.1字面是double类型，不能执行float f = 1.1，只能执行float f = 1.1f但使用+=可以执行隐式类型转换 \n\n**String、StringBuilder、StringBuffer**:\n\n> String声明为final不可变，其他两个是可变的，StringBuilder线程不安全\n##### 常识梳理\n**关键字**\n\n> public,protected,default,private\n>\n> 全局，自身子类包内，包内，自身 \n\n**参数传递方式**\n\n> java的参数是以值传递的方式传入方法，而不是引用传递Dog dog = new Dog('a');中的dog是存储对象地址的指针，在将一个参数传入方法时，本质是将对象的地址以值得方式传递到形参中 。\n\n**接口和抽象类**\n\n> 抽象类(IS-A):包含抽象方法的类（也可以不包含），也可以拥有成员变量和成员方法,不能被实例化，需要继承抽象类才能实例化其子类【抽象事物，模板式设计】\n>\n> 抽象方法：只有声明没有具体实现，必须为public或者protected抽象类是为了继承而生的，子类必须实现父类的抽象方法，如果没有实现，也应该声明为抽象类 \n>\n> 接口(LIKE-A)：极度抽象，一般都不定义变量（public(方法) 、成员变量只能static final），所有的方法（public abstract）都不能有具体的实现【抽象行为，辐射式设计】(从java8开始接口也可以拥有默认的方法实现，因为不支持默认方法的接口维护成本太高，接口增加方法要修改所有实现了该方法的类)\n>\n> 只能继承一个抽象类，但是能实现多个接口 \n\n> java中的接口有继承和实现两个概念，且支持多继承\n>\n> 接口可以继承另外一个接口，并获得父接口所有的方法和成员变量\n>\n> 接口也可以被一个类实现，实现接口的类需要实现接口及其父接口里的多有抽象方法（java1.8中增加了default关键字，允许接口里有非抽象方法，这些抽象方法可以不被接口的实现类实现）\n>\n> 为什么接口支持多继承而类不可以？\n>\n> 当继承多个类中有参数列表相同的方法时子类就会产生混淆，所以只能单继承，单继承限制了类的拓展性但是接口中的方法都为抽象方法，没有方法体，只有接口的实现类有方法的实现，所以不会产生混淆 \n\n**泛型**\n\n> 泛型：参数化类型\n>\n> 泛型类型逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型？ \n\n**反射**\n\n> 运行时动态加载 \n\n**Object通用方法**\n\n> equals和==：\n>\n> 基本类型没有equals方法，\\==判断两个值是否相等引用类型equals判断引用的对象是否等价，\\==判断两个实例是否引用同一个对象 \n>\n> 等价的两个实例散列值一定相同，但散列值相同的两个实例不一定等价，在覆盖equals方法时应该也覆盖hashCode方法，保证等价的实例有相同的hashcode \n\n```java\npublic class EqualExample{\n        private int x;\n        private int y;\n        private int z;\n        public EqualExample(int x,int y,int z){\n                this.x = x;\n                this.y = y;\n                this.z = z;\n}\n@override\npublic boolean equals(Object o){\n        if(this == o) return true;\n        if(o == null || getClass() != o.getClass()) return false;\n        EqualExample that = (EqualExample) o;\n        if(x!=that.x) return false;\n        if(y!=that.y) return false;\n        return z = that.z;\n}\n@override\npublic int hashCode(){\n}\n}\n\nEqualExample e1 = new EqualExample(1,1,1);\nEqualExample e2 = new EqualExample(1,1,1);\nsyso(e1.equals(e2)); //true\n\nHashSet<EqualExample> s1 = new HashSet<>();\ns1.add(e1);\ns1.add(e2);\nsyso(s1.size()) //2,没有重写hashcode方法\n/*\ntoString()\nclone()\nprotect方法，必须显示重写才能调用\n必须先实现cloneable接口才能调用clone方法\n**/\npublic class CloneExample{\n        private int a;\n        private int b;\n        @override\n        protected CloneExample clone() throws Exception{\n                return (CloneExample)super.clone();\n    }\n}\nCloneExample c1 = new CloneExample();\ntry{\n        CloneExample c2 = c1.clone();\n} catch (CloneNotSupportedException e){\n        e.printStackTrace();\n} //java.lang.CloneNotSupportedException: CloneTest\n\npublic class CloneExample implements Cloneable{\n        private int a;\n        private int b;\n\n        @override\n        protected CloneExample clone() throws Exception{\n                return (CloneExample)super.clone();\n    }\n}\n//深拷贝(引用不同对象)和浅拷贝(引用同一对象)\n```\n\n**封装继承重写重载**\n\n> 封装\n>\n> 子类覆盖父类的方法，子类中该方法的访问级别不能低于父类，(里式替换原则：子类对象必须能够替换所有的父类对象)字段不能公有，使用共有的getter，setter进行修改 \n>\n> 重写：继承过程中\n>\n> 重载：同一个类中同名方法，只有返回值不同不算重载方法名相同，参数列表不同（不同参数类型，参数顺序或参数个数），方法的返回值类型和修饰符与方法重载没有任何关系。 \n\n**初始化顺序**\n\n> 在存在继承的情况下，初始化顺序为：\n>\n> 父类(静态变量，静态语句块)\n>\n> 子类(静态变量，静态语句块)\n>\n> 父类(实例变量，普通语句块)\n>\n> 父类(构造函数)\n>\n> 子类(实例变量，普通语句块)\n>\n> 子类(构造函数) \n\n**虚拟机**\n\n> - **运行时数据区域**\n>\n>   **THREAD**\n>\n>   - **程序计数器**：\n>\n>     记录正在执行的虚拟机字节码指令地址 \n>\n>   - **虚拟机栈**：\n>\n>     每一个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等\n>\n>     每一个方法调用到完成的过程对应一个栈帧在JVM中入栈和出栈的过程\n>\n>     java -Xss=512M HackTheJava //指定大小 \n>\n>   - **本地方法栈**： \n>\n>   **堆**：\n>\n>   所有的对象实例在这里分配内存，垃圾收集的主要区域，不需要连续内存，可动态扩展\n>\n>   新生代(Eden,From Survivor,To Survivor)\n>\n>   老年代\n>\n>   永久代\n>\n>   java -Xms=1M -Xmx=2M HackTheJava \n>\n>   **方法区**：\n>\n>   存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 \n>\n>   - **运行时常量池**：方法区的一部分 \n>\n> - **直接内存**：程序计数器、虚拟机栈、本地方法栈三个区域属于线程私有，只存在于线程的生命周期内，线程结束即消失，不需要垃圾收集\n\n> 垃圾收集垃圾收集主要集中在堆和方法区 \n\n> 类加载机制：运行期间动态加载 \n\n**Spring、SpringBoot**\n\nTODO\n\n---\n\n### Python\n\n[pythonGitbook](https://eastlakeside.gitbooks.io/interpy-zh/content/)\n\n**list、tuple、dict、set**\n\n- list：列表，链表，有序，可索引，“[]”\n\n  ```python\n  append(y)、extend(L)、count(y)、index(y)、insert(i,y)、pop(y)、remove(y)、reverse()、sort()\n  #y--元素，L--列表\n  ```\n\n- tuple：元组，对象集合，可索引，不能修改，“()”\n\n  > 不可变，能保证代码的安全性\n  >\n  > len()，tuple[y]\n  >\n  > 同样可以索引切片连接重复\n\n- dict：字典，key-value组合，无序，（空间换时间），“{}”\n\n  > 不允许一个键对应多个值\n\n  ```python\n  dict.keys(),dict.values(),dict.items()\n  hash(obj) ##-->可作为key\n  del,dict.pop,clear\n  sorted(dict.items(),key = lambda d:d[0])\n  dict.get()\n  dict.setdefault()\n  {}.fromkeys(('a','b'),True)  #{'a':True,'b':True}\n  ```\n\n- set：集合，无序，元素自动去重，“set([])”\n\n  ```python\n  add,update,remove\n  discard与remove #【如果删除的元素不在集合内，discard不会报错】\n  #|(联合),&(交集),-(差集),^(差分)\n  ```\n\n**collections**\n\n- defaultdict(不需要检查key是否存在，减少keyerror的发生)\n- Counter\n- deque：双端队列\n- namedtuple：可以像字典一样访问，但是是不可变的\n\n**dict排序**\n\n```python\ntmp_list = sorted(tmp_list.items(),key = lambda d:d[1],reverse = True)  ##按value、反序\n```\n\n**交集并集差集**\n\n```python\nprint(list(set(b).difference(set(a))))\nprint(list(set(b).union(set(a))))\nprint(list(set(b).intersection(set(a))))\n\n#检查是否有重复元素\nduplicates = set([x for x in some_list if some_list.count(x) > 1])\n```\n\n**xrange、range**\n\nxrange返回一个迭代器，range返回一个list\n\n**生成器**\n\n**@property**\n\n将一个函数定义为特性，直接obj.name使用，遵循统一访问的原则 ，相当与get set？\n\n```python\nclass Stu(object):\n    @property #相当于get方法，调用简单方便可控\n    def score(self):\n        return self._score\n    @score.setter #set方法，\n    def score(self,value):\n        if not isinstance(value,int):\n            raise ValueError('must be int')\n        if value<0 or value>100:\n            raise ValueError('must 0<x<100')\n            self._score = value\n```\n\n**@staticmethod、@classmethod**\n\n```python\nclass Date(object):\n    day = 0\n    month = 0\n    year = 0\n    def __init__(self,day=0,month=0,year=0):\n        self.day = day\n        self.month = month\n        self.year = year\n    @classmethod #尝试一种另类的构造函数，python缺乏重载的特性\n    def from_string(cls,date_as_string):\n        day,month,year = map(int,date_as_string.split('-'))\n        date1 = cls(day,month,year)\n        return date1\n    @staticmethod #不需要访问类\n    def is_date_valid(date_as_string):\n        day,month,year = map(int,date_as_string.split('-'))\n        return day<=31 and month<=12 and year<=2019\nif __name__ == '__main__':\n    s = Stu()\n    s.score = 60\n    print(s.score)\n    # s.score = 999\n    date2 = Date.from_string('06-08-2018')\n    is_date = Date.is_date_valid('06-08-2019')\n\n    print(date2.day)\n    print(is_date)\n```\n\n**enumerate**\n\n```python\nfor i in range(len(list1)):\n    print (i,list1[i])\n#enumerate的用法\nfor index,item in enumerate(list1):\n    print (index,item)\n#enumerate还可以指定索引的起始值\nfor index,item in enumerate(list1,1):\n    print(index,item)\n#简单的统计文件行数的方法\ncount = len(open(filepath,'r').readlines())\n\ncount=0\nfor index,line in enumerate(open(filepath,'r')):\n    count+=1\n```\n\n**多线程多进程**\n\n> Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。不能多线程并发。 \n\n```python\nimport argparse\nimport os,time,random\nfrom multiprocessing import Process,Pool,cpu_count,Queue\nimport subprocess\nimport threading\n\n# parser = argparse.ArgumentParser()\n# parser.add_argument('integer',type=int,help='display an integer')\n# args = parser.parse_args()\n# print(args.integer)\n\n# parser.add_argument(\"--square\",help=\"display a square of a given number\",type=int)\n# parser.add_argument(\"--cubic\",help=\"display a cubic of a given number\",type=int)\n#\n# args = parser.parse_args()\n#\n# if args.square:\n#     print(args.square**2)\n# if args.cubic:\n#     print(args.cubic**3)\n\ndef run_proc(name):\n    print('Run child process %s (%s)...' %(name,os.getpid()))\n\ndef long_time_task(name):\n    print('Run child process %s (%s)...' %(name,os.getpid()))\n    start = time.time()\n    time.sleep(random.random()*3)\n    end = time.time()\n    print('Task %s runs %.2f seconds' % (name,(end-start)))\n\ndef write(q):\n    print('Process to write: %s' % os.getpid())\n    for value in ['A','B','C']:\n    print('put %s queue ' % value)\n    q.put(value)\n    time.sleep(random.random())\ndef read(q):\n    print('Process to read: %s' % os.getpid())\n    while True:\n        value = q.get(True)\n    print('get %s from queue' % value)\n\ndef loop():\n    print('thread %s is running' % threading.current_thread().name)\n    n = 0\n    while n<5:\n        n = n+1\n        print('thread %s >>> %s' % (threading.current_thread().name,n))\n        time.sleep(1)\n        print('thread %s ended' % threading.current_thread().name)\nif __name__ == \"__main__\":\n    #进程，进程池\n    print(cpu_count())\n    print('Parent process %s' % os.getpid())\n    # p = Process(target=run_proc,args=('test',))\n    p = Pool(32)\n    for i in range(33):\n        p.apply_async(long_time_task,args=(i,))\n        # print('Child process start')\n        # p.start()\n        # p.join()\n        # print('Child process end')\n        print('waiting for all subprocess done')\n        p.close()\n        p.join()\n        print('All subprocess done')\n\n#进程执行\nr = subprocess.call(['nslookup','https://pamperxg.github.io'])\nprint('Exit code:',r)\n\n#进程间通信\nq = Queue()\npw = Process(target=write,args=(q,))\npr = Process(target=read,args=(q,))\npw.start()\npr.start()\npw.join()\npr.terminate()\n\n#线程\nt = threading.Thread(target=loop,name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended' % threading.current_thread().name)\n```\n\n**数据库连接**\n\n```python\ndef ConnectDataBase(self,db_name,user_name,password):\n        conn = mdb.connect(host='88.88.88.88',port=3306,user=user_name,passwd=password,\\\n                           db=db_name,charset='utf8')\n        cursor = conn.cursor()\n        return (conn,cursor)\n```\n\n**pandas操作**\n\n```python\n#选取指定列进行操作\ndf.loc[(df.Cabin.notnull()),'Cabin'] = 'Yes'  #选取指定列替换为yes\ndf.loc[df.Team.isin(['England','Italy','Russia']),['Team','Shooting Accuracy']] #选取满足条件的列\n#\ndf.groupby('a',as_index=False).sum()\n```\n\n```python\n#分组排序，算位置\n#groupby时as_index=False和True的区别\ndef get_level(data,key,values,ascending=True):\n    data_temp = data[key + [values]].copy()\n    data_temp.sort_values(key + [values], inplace=True, ascending=ascending)\n    data_temp['rank'] = range(data_temp.shape[0])\n    data_tmp['rank'] = data_tmp['rank'] + 1\n    min_rank = data_temp.groupby(key,as_index=False)['rank'].agg({'min_rank':'min'})\n    index = data_temp.index\n    data_temp = data_temp.merge(min_rank,on=key,how='left')\n    data_temp['rank'] = data_temp['rank'] - data_temp['min_rank']\n    max_rank = data_temp.groupby(key,as_index=False)['rank'].agg({'max_rank':'max'})\n    data_temp = data_temp.merge(max_rank,on=key,how='left')\n    data_temp.index = index\n    data_temp['slevel'] = round(data_temp['rank']/data_temp['max_rank'],2)\n    return data_temp['slevel']   \n```\n\n```python\n#shift、diff函数\n\n```\n\n**loc、iloc、ix**\n\n> loc：在行标签上进行索引，包括start和end\n>\n> iloc：在行标签位置上进行索引，不包括end\n>\n> ix：在行标签上索引，索引不到就到位置上索引（如果index非全部整数）,不包括end\n>\n> > .ix is deprecated. Please use\n> > .loc for label based indexing or\n> > .iloc for positional indexing\n\n**map、filter、reduce**\n\n```python\nitems = [1,2,3,4]\nsquared = list(map(lambda x:x**2,items)) #map python3返回迭代器，python2返回列表\n\nless_than_zero = filter(lambda x:x<0,number_list) #同python3返回迭代器，python2返回列表\n\n#对一个列表进行计算并且返回结果\nproduct = reduce((lambda x,y:x*y),[1,2,3,4]) #24\n```\n\n**时间处理**(python、pandas)：\n\npython标准库：datetime、time、calendar\n\n- 其中datetime模块中的标准数据类型有：date、time、datetime、timedeltad\n\n\n\n```python\n#1\nfrom datetime import datetime,timedelta\ndatetime.now()\n#2\n[datetime.strptime(x,'%Y-%m-%d') for x in date]\n#3\nfrom dateutil.parser import parse\nparse('2018-10-10')\n#4\nimport pandas as pd\npd.to_datetime(date)\n```\n\n**网络相关**：\n\n应用层：为特定应用程序提供数据传输服务，http，dns\n\n运输层：进程间的通用数据传输服务，TCP、UDP\n\n网络层：主机间的数据传输服务\n\n数据链路层：为同一链路的主机提供服务\n\n物理层：怎样在传输媒体上传输数据比特流 \n\n表示层\n\n会话层 \n\nTCP/UDP：---  应用层：http，dns                  \n\n​\t\t    ---   运输层：tcp，udp                  \n\n​                    ---   网际层 ：IP                  \n\n   \t\t    ---   网络接口层： \n\n> UDP是无连接的，支持一对一，一对多，多对一，多对多\n>\n> TCP是面向连接的，只能一对一\n\n序号，确认号，数据偏移，确认ACK，同步SYN，中止FIN，窗口 \n\n*TCP三次握手，四次挥手：*\n\n- 服务端处于listen状态，等待客户端的连接请求\n\n-  客户端向服务端发送请求报文，SYN=1，ACK=0，初始序号x \n\n- 服务端收到请求报文后，若同意连接，向客户端发送确认报文，SYN=1,ACK=1，确认号ack=x+1,初始序号y \n\n- 客户端收到确认报文后，继续向服务端发出确认，确认号ack=y+1，序号为x+1 \n\n- 服务端收到客户端确认后，连接建立\n\n  > 防止失效连接请求到达服务器\n  >\n  > 如果客户端发送的连接请求在网络中滞留，滞留时间超过客户端超时重传时间后，客户端会重新请求连接，延时的请求还是会到达服务端，如果不进行三次握手，服务器就会打开两个连接，有三次握手就会忽略滞留连接请求的连接确认，不进行三次握手，所以不会再次打开连接。 \n\n---\n\n- 客户端发送连接释放报文，FIN=1 \n\n- 服务端收到后发出确认，此时TCP处于**半关闭状态**，服务器端能向客户端发送数据，反之不行/ CLOSE_WAIT \n\n- 服务端不再需要连接时，发送连接释放报文，FIN=1 \n\n- 客户端收到后发出确认，进入**TIME_WAIT**状态，等待2MSL(最大报文存活时间)后释放连接 \n\n- 服务端收到客户端确认后释放连接 \n\n  > CLOSE_WAIT:状态让服务端发送完数据\n  >\n  > TIME_WAIT:确保确认报文能到达服务端，若未到达，服务端会再次发送释放报文。。                   \n  >\n  > ​\t\t     等待本连接产生的所有报文都从网络中消失，下一个新连接不会受到旧的请求报文 \n  >\n  > 可靠传输：超时重传 \n\n---\n\nPycharm相同路径下的文件无法引用问题：\n\n> 在该路径下右击，Mark Directory as Source Root\n","source":"_posts/Java-Python.md","raw":"---\ntitle: Java&Python\ndate: 2018-8-20 00:33:45\ntags: [coding,Java,Python,语言基础知识]\n---\n\nJava和Python的一些基础知识总结\n\n<!--more-->\n\n多线程、多进程、同步、异步、阻塞、非阻塞\n\n多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 \n\n同步才有阻塞和非阻塞之分\n\n同步：执行一个操作后等待结果，然后再继续后面的操作\n\n阻塞：进程给cpu传达一个任务后，一直等待cpu处理完成再进行后续操作\n\n非阻塞：进程给cpu传达一个任务后，继续处理后续操作，隔段时间再询问之前操作是否完成，也称轮询\n\n异步：执行一个操作后，可以去执行其他操作，等待通知再回来执行未完成操作 \n\n### Java\n\n##### 常用类\n\nCollection：\n\n java.util.Collection(接口) --extends java.lang.Iterable ，每一个位置存一个元素，没有get方法，只能通过iterator() 遍历元素\n\n- List【维护一组元素特定顺序】\n  - **ArrayList**【查询快，基于arrays数组实现】\n  - **LinkedList**【增删快，常用作队列】\n  - **Vector**【实现同步，线程安全】\n- Queue\n  - **PriorityQueue**【基于堆结构实现】\n- Set【每个元素唯一】\n  - SortedSet\n    - **TreeSet**【保持次序的set，基于红黑树实现，查找效率不如hashset】\n  - **HashSet**【定义了hashcode，支持快速查找，不支持有序性操作，使用iterator遍历的结果可能是不确定的】\n  - **LinkedHashSet**【hash加快查询，链表维护元素次序，只能顺序访问，可以快速增删】\n  \nMap：\n\njava.util.Map(接口)      （key-value pair）\n\n- **HashMap**\n- **HashTable**【线程安全】\n- **ConcurrentHashMap**【支持线程安全，且效率更高】\n- **LinkedHashMap**【使用链表维护元素顺序(插入顺序、LRU顺序)】\n- SortedMap\n  - **TreeMap**\n\narray：容量固定且无法动态改变\n**Arrays**：操作array的类，拥有一组静态函数\n```java\nInteger[] arr = {1,2,3};\nList list = Arrays.asList();\n```\n**Collections**：和Arrays一样是工具类\n**包装类**：\n- 对象型：Boolean、Character(object的直接子类)\n- 数值型：Byte、Double、Short、Integer、Float\n基本数据类型：boolean、byte、char、short、int、float、long、double\n包装类和基本类型的转化是自动拆箱装箱的，java把一些基本类型的常用对象存储在缓存池中，调用valueOf() 方法直接使用缓存池中的对象\n> valueOf() 和new 对象区别：new出来的对象虽然值一样但是不是同一个对象，所以x!=y\n\n> java不能隐式执行下转型1.1字面是double类型，不能执行float f = 1.1，只能执行float f = 1.1f但使用+=可以执行隐式类型转换 \n\n**String、StringBuilder、StringBuffer**:\n\n> String声明为final不可变，其他两个是可变的，StringBuilder线程不安全\n##### 常识梳理\n**关键字**\n\n> public,protected,default,private\n>\n> 全局，自身子类包内，包内，自身 \n\n**参数传递方式**\n\n> java的参数是以值传递的方式传入方法，而不是引用传递Dog dog = new Dog('a');中的dog是存储对象地址的指针，在将一个参数传入方法时，本质是将对象的地址以值得方式传递到形参中 。\n\n**接口和抽象类**\n\n> 抽象类(IS-A):包含抽象方法的类（也可以不包含），也可以拥有成员变量和成员方法,不能被实例化，需要继承抽象类才能实例化其子类【抽象事物，模板式设计】\n>\n> 抽象方法：只有声明没有具体实现，必须为public或者protected抽象类是为了继承而生的，子类必须实现父类的抽象方法，如果没有实现，也应该声明为抽象类 \n>\n> 接口(LIKE-A)：极度抽象，一般都不定义变量（public(方法) 、成员变量只能static final），所有的方法（public abstract）都不能有具体的实现【抽象行为，辐射式设计】(从java8开始接口也可以拥有默认的方法实现，因为不支持默认方法的接口维护成本太高，接口增加方法要修改所有实现了该方法的类)\n>\n> 只能继承一个抽象类，但是能实现多个接口 \n\n> java中的接口有继承和实现两个概念，且支持多继承\n>\n> 接口可以继承另外一个接口，并获得父接口所有的方法和成员变量\n>\n> 接口也可以被一个类实现，实现接口的类需要实现接口及其父接口里的多有抽象方法（java1.8中增加了default关键字，允许接口里有非抽象方法，这些抽象方法可以不被接口的实现类实现）\n>\n> 为什么接口支持多继承而类不可以？\n>\n> 当继承多个类中有参数列表相同的方法时子类就会产生混淆，所以只能单继承，单继承限制了类的拓展性但是接口中的方法都为抽象方法，没有方法体，只有接口的实现类有方法的实现，所以不会产生混淆 \n\n**泛型**\n\n> 泛型：参数化类型\n>\n> 泛型类型逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型？ \n\n**反射**\n\n> 运行时动态加载 \n\n**Object通用方法**\n\n> equals和==：\n>\n> 基本类型没有equals方法，\\==判断两个值是否相等引用类型equals判断引用的对象是否等价，\\==判断两个实例是否引用同一个对象 \n>\n> 等价的两个实例散列值一定相同，但散列值相同的两个实例不一定等价，在覆盖equals方法时应该也覆盖hashCode方法，保证等价的实例有相同的hashcode \n\n```java\npublic class EqualExample{\n        private int x;\n        private int y;\n        private int z;\n        public EqualExample(int x,int y,int z){\n                this.x = x;\n                this.y = y;\n                this.z = z;\n}\n@override\npublic boolean equals(Object o){\n        if(this == o) return true;\n        if(o == null || getClass() != o.getClass()) return false;\n        EqualExample that = (EqualExample) o;\n        if(x!=that.x) return false;\n        if(y!=that.y) return false;\n        return z = that.z;\n}\n@override\npublic int hashCode(){\n}\n}\n\nEqualExample e1 = new EqualExample(1,1,1);\nEqualExample e2 = new EqualExample(1,1,1);\nsyso(e1.equals(e2)); //true\n\nHashSet<EqualExample> s1 = new HashSet<>();\ns1.add(e1);\ns1.add(e2);\nsyso(s1.size()) //2,没有重写hashcode方法\n/*\ntoString()\nclone()\nprotect方法，必须显示重写才能调用\n必须先实现cloneable接口才能调用clone方法\n**/\npublic class CloneExample{\n        private int a;\n        private int b;\n        @override\n        protected CloneExample clone() throws Exception{\n                return (CloneExample)super.clone();\n    }\n}\nCloneExample c1 = new CloneExample();\ntry{\n        CloneExample c2 = c1.clone();\n} catch (CloneNotSupportedException e){\n        e.printStackTrace();\n} //java.lang.CloneNotSupportedException: CloneTest\n\npublic class CloneExample implements Cloneable{\n        private int a;\n        private int b;\n\n        @override\n        protected CloneExample clone() throws Exception{\n                return (CloneExample)super.clone();\n    }\n}\n//深拷贝(引用不同对象)和浅拷贝(引用同一对象)\n```\n\n**封装继承重写重载**\n\n> 封装\n>\n> 子类覆盖父类的方法，子类中该方法的访问级别不能低于父类，(里式替换原则：子类对象必须能够替换所有的父类对象)字段不能公有，使用共有的getter，setter进行修改 \n>\n> 重写：继承过程中\n>\n> 重载：同一个类中同名方法，只有返回值不同不算重载方法名相同，参数列表不同（不同参数类型，参数顺序或参数个数），方法的返回值类型和修饰符与方法重载没有任何关系。 \n\n**初始化顺序**\n\n> 在存在继承的情况下，初始化顺序为：\n>\n> 父类(静态变量，静态语句块)\n>\n> 子类(静态变量，静态语句块)\n>\n> 父类(实例变量，普通语句块)\n>\n> 父类(构造函数)\n>\n> 子类(实例变量，普通语句块)\n>\n> 子类(构造函数) \n\n**虚拟机**\n\n> - **运行时数据区域**\n>\n>   **THREAD**\n>\n>   - **程序计数器**：\n>\n>     记录正在执行的虚拟机字节码指令地址 \n>\n>   - **虚拟机栈**：\n>\n>     每一个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等\n>\n>     每一个方法调用到完成的过程对应一个栈帧在JVM中入栈和出栈的过程\n>\n>     java -Xss=512M HackTheJava //指定大小 \n>\n>   - **本地方法栈**： \n>\n>   **堆**：\n>\n>   所有的对象实例在这里分配内存，垃圾收集的主要区域，不需要连续内存，可动态扩展\n>\n>   新生代(Eden,From Survivor,To Survivor)\n>\n>   老年代\n>\n>   永久代\n>\n>   java -Xms=1M -Xmx=2M HackTheJava \n>\n>   **方法区**：\n>\n>   存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 \n>\n>   - **运行时常量池**：方法区的一部分 \n>\n> - **直接内存**：程序计数器、虚拟机栈、本地方法栈三个区域属于线程私有，只存在于线程的生命周期内，线程结束即消失，不需要垃圾收集\n\n> 垃圾收集垃圾收集主要集中在堆和方法区 \n\n> 类加载机制：运行期间动态加载 \n\n**Spring、SpringBoot**\n\nTODO\n\n---\n\n### Python\n\n[pythonGitbook](https://eastlakeside.gitbooks.io/interpy-zh/content/)\n\n**list、tuple、dict、set**\n\n- list：列表，链表，有序，可索引，“[]”\n\n  ```python\n  append(y)、extend(L)、count(y)、index(y)、insert(i,y)、pop(y)、remove(y)、reverse()、sort()\n  #y--元素，L--列表\n  ```\n\n- tuple：元组，对象集合，可索引，不能修改，“()”\n\n  > 不可变，能保证代码的安全性\n  >\n  > len()，tuple[y]\n  >\n  > 同样可以索引切片连接重复\n\n- dict：字典，key-value组合，无序，（空间换时间），“{}”\n\n  > 不允许一个键对应多个值\n\n  ```python\n  dict.keys(),dict.values(),dict.items()\n  hash(obj) ##-->可作为key\n  del,dict.pop,clear\n  sorted(dict.items(),key = lambda d:d[0])\n  dict.get()\n  dict.setdefault()\n  {}.fromkeys(('a','b'),True)  #{'a':True,'b':True}\n  ```\n\n- set：集合，无序，元素自动去重，“set([])”\n\n  ```python\n  add,update,remove\n  discard与remove #【如果删除的元素不在集合内，discard不会报错】\n  #|(联合),&(交集),-(差集),^(差分)\n  ```\n\n**collections**\n\n- defaultdict(不需要检查key是否存在，减少keyerror的发生)\n- Counter\n- deque：双端队列\n- namedtuple：可以像字典一样访问，但是是不可变的\n\n**dict排序**\n\n```python\ntmp_list = sorted(tmp_list.items(),key = lambda d:d[1],reverse = True)  ##按value、反序\n```\n\n**交集并集差集**\n\n```python\nprint(list(set(b).difference(set(a))))\nprint(list(set(b).union(set(a))))\nprint(list(set(b).intersection(set(a))))\n\n#检查是否有重复元素\nduplicates = set([x for x in some_list if some_list.count(x) > 1])\n```\n\n**xrange、range**\n\nxrange返回一个迭代器，range返回一个list\n\n**生成器**\n\n**@property**\n\n将一个函数定义为特性，直接obj.name使用，遵循统一访问的原则 ，相当与get set？\n\n```python\nclass Stu(object):\n    @property #相当于get方法，调用简单方便可控\n    def score(self):\n        return self._score\n    @score.setter #set方法，\n    def score(self,value):\n        if not isinstance(value,int):\n            raise ValueError('must be int')\n        if value<0 or value>100:\n            raise ValueError('must 0<x<100')\n            self._score = value\n```\n\n**@staticmethod、@classmethod**\n\n```python\nclass Date(object):\n    day = 0\n    month = 0\n    year = 0\n    def __init__(self,day=0,month=0,year=0):\n        self.day = day\n        self.month = month\n        self.year = year\n    @classmethod #尝试一种另类的构造函数，python缺乏重载的特性\n    def from_string(cls,date_as_string):\n        day,month,year = map(int,date_as_string.split('-'))\n        date1 = cls(day,month,year)\n        return date1\n    @staticmethod #不需要访问类\n    def is_date_valid(date_as_string):\n        day,month,year = map(int,date_as_string.split('-'))\n        return day<=31 and month<=12 and year<=2019\nif __name__ == '__main__':\n    s = Stu()\n    s.score = 60\n    print(s.score)\n    # s.score = 999\n    date2 = Date.from_string('06-08-2018')\n    is_date = Date.is_date_valid('06-08-2019')\n\n    print(date2.day)\n    print(is_date)\n```\n\n**enumerate**\n\n```python\nfor i in range(len(list1)):\n    print (i,list1[i])\n#enumerate的用法\nfor index,item in enumerate(list1):\n    print (index,item)\n#enumerate还可以指定索引的起始值\nfor index,item in enumerate(list1,1):\n    print(index,item)\n#简单的统计文件行数的方法\ncount = len(open(filepath,'r').readlines())\n\ncount=0\nfor index,line in enumerate(open(filepath,'r')):\n    count+=1\n```\n\n**多线程多进程**\n\n> Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。不能多线程并发。 \n\n```python\nimport argparse\nimport os,time,random\nfrom multiprocessing import Process,Pool,cpu_count,Queue\nimport subprocess\nimport threading\n\n# parser = argparse.ArgumentParser()\n# parser.add_argument('integer',type=int,help='display an integer')\n# args = parser.parse_args()\n# print(args.integer)\n\n# parser.add_argument(\"--square\",help=\"display a square of a given number\",type=int)\n# parser.add_argument(\"--cubic\",help=\"display a cubic of a given number\",type=int)\n#\n# args = parser.parse_args()\n#\n# if args.square:\n#     print(args.square**2)\n# if args.cubic:\n#     print(args.cubic**3)\n\ndef run_proc(name):\n    print('Run child process %s (%s)...' %(name,os.getpid()))\n\ndef long_time_task(name):\n    print('Run child process %s (%s)...' %(name,os.getpid()))\n    start = time.time()\n    time.sleep(random.random()*3)\n    end = time.time()\n    print('Task %s runs %.2f seconds' % (name,(end-start)))\n\ndef write(q):\n    print('Process to write: %s' % os.getpid())\n    for value in ['A','B','C']:\n    print('put %s queue ' % value)\n    q.put(value)\n    time.sleep(random.random())\ndef read(q):\n    print('Process to read: %s' % os.getpid())\n    while True:\n        value = q.get(True)\n    print('get %s from queue' % value)\n\ndef loop():\n    print('thread %s is running' % threading.current_thread().name)\n    n = 0\n    while n<5:\n        n = n+1\n        print('thread %s >>> %s' % (threading.current_thread().name,n))\n        time.sleep(1)\n        print('thread %s ended' % threading.current_thread().name)\nif __name__ == \"__main__\":\n    #进程，进程池\n    print(cpu_count())\n    print('Parent process %s' % os.getpid())\n    # p = Process(target=run_proc,args=('test',))\n    p = Pool(32)\n    for i in range(33):\n        p.apply_async(long_time_task,args=(i,))\n        # print('Child process start')\n        # p.start()\n        # p.join()\n        # print('Child process end')\n        print('waiting for all subprocess done')\n        p.close()\n        p.join()\n        print('All subprocess done')\n\n#进程执行\nr = subprocess.call(['nslookup','https://pamperxg.github.io'])\nprint('Exit code:',r)\n\n#进程间通信\nq = Queue()\npw = Process(target=write,args=(q,))\npr = Process(target=read,args=(q,))\npw.start()\npr.start()\npw.join()\npr.terminate()\n\n#线程\nt = threading.Thread(target=loop,name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended' % threading.current_thread().name)\n```\n\n**数据库连接**\n\n```python\ndef ConnectDataBase(self,db_name,user_name,password):\n        conn = mdb.connect(host='88.88.88.88',port=3306,user=user_name,passwd=password,\\\n                           db=db_name,charset='utf8')\n        cursor = conn.cursor()\n        return (conn,cursor)\n```\n\n**pandas操作**\n\n```python\n#选取指定列进行操作\ndf.loc[(df.Cabin.notnull()),'Cabin'] = 'Yes'  #选取指定列替换为yes\ndf.loc[df.Team.isin(['England','Italy','Russia']),['Team','Shooting Accuracy']] #选取满足条件的列\n#\ndf.groupby('a',as_index=False).sum()\n```\n\n```python\n#分组排序，算位置\n#groupby时as_index=False和True的区别\ndef get_level(data,key,values,ascending=True):\n    data_temp = data[key + [values]].copy()\n    data_temp.sort_values(key + [values], inplace=True, ascending=ascending)\n    data_temp['rank'] = range(data_temp.shape[0])\n    data_tmp['rank'] = data_tmp['rank'] + 1\n    min_rank = data_temp.groupby(key,as_index=False)['rank'].agg({'min_rank':'min'})\n    index = data_temp.index\n    data_temp = data_temp.merge(min_rank,on=key,how='left')\n    data_temp['rank'] = data_temp['rank'] - data_temp['min_rank']\n    max_rank = data_temp.groupby(key,as_index=False)['rank'].agg({'max_rank':'max'})\n    data_temp = data_temp.merge(max_rank,on=key,how='left')\n    data_temp.index = index\n    data_temp['slevel'] = round(data_temp['rank']/data_temp['max_rank'],2)\n    return data_temp['slevel']   \n```\n\n```python\n#shift、diff函数\n\n```\n\n**loc、iloc、ix**\n\n> loc：在行标签上进行索引，包括start和end\n>\n> iloc：在行标签位置上进行索引，不包括end\n>\n> ix：在行标签上索引，索引不到就到位置上索引（如果index非全部整数）,不包括end\n>\n> > .ix is deprecated. Please use\n> > .loc for label based indexing or\n> > .iloc for positional indexing\n\n**map、filter、reduce**\n\n```python\nitems = [1,2,3,4]\nsquared = list(map(lambda x:x**2,items)) #map python3返回迭代器，python2返回列表\n\nless_than_zero = filter(lambda x:x<0,number_list) #同python3返回迭代器，python2返回列表\n\n#对一个列表进行计算并且返回结果\nproduct = reduce((lambda x,y:x*y),[1,2,3,4]) #24\n```\n\n**时间处理**(python、pandas)：\n\npython标准库：datetime、time、calendar\n\n- 其中datetime模块中的标准数据类型有：date、time、datetime、timedeltad\n\n\n\n```python\n#1\nfrom datetime import datetime,timedelta\ndatetime.now()\n#2\n[datetime.strptime(x,'%Y-%m-%d') for x in date]\n#3\nfrom dateutil.parser import parse\nparse('2018-10-10')\n#4\nimport pandas as pd\npd.to_datetime(date)\n```\n\n**网络相关**：\n\n应用层：为特定应用程序提供数据传输服务，http，dns\n\n运输层：进程间的通用数据传输服务，TCP、UDP\n\n网络层：主机间的数据传输服务\n\n数据链路层：为同一链路的主机提供服务\n\n物理层：怎样在传输媒体上传输数据比特流 \n\n表示层\n\n会话层 \n\nTCP/UDP：---  应用层：http，dns                  \n\n​\t\t    ---   运输层：tcp，udp                  \n\n​                    ---   网际层 ：IP                  \n\n   \t\t    ---   网络接口层： \n\n> UDP是无连接的，支持一对一，一对多，多对一，多对多\n>\n> TCP是面向连接的，只能一对一\n\n序号，确认号，数据偏移，确认ACK，同步SYN，中止FIN，窗口 \n\n*TCP三次握手，四次挥手：*\n\n- 服务端处于listen状态，等待客户端的连接请求\n\n-  客户端向服务端发送请求报文，SYN=1，ACK=0，初始序号x \n\n- 服务端收到请求报文后，若同意连接，向客户端发送确认报文，SYN=1,ACK=1，确认号ack=x+1,初始序号y \n\n- 客户端收到确认报文后，继续向服务端发出确认，确认号ack=y+1，序号为x+1 \n\n- 服务端收到客户端确认后，连接建立\n\n  > 防止失效连接请求到达服务器\n  >\n  > 如果客户端发送的连接请求在网络中滞留，滞留时间超过客户端超时重传时间后，客户端会重新请求连接，延时的请求还是会到达服务端，如果不进行三次握手，服务器就会打开两个连接，有三次握手就会忽略滞留连接请求的连接确认，不进行三次握手，所以不会再次打开连接。 \n\n---\n\n- 客户端发送连接释放报文，FIN=1 \n\n- 服务端收到后发出确认，此时TCP处于**半关闭状态**，服务器端能向客户端发送数据，反之不行/ CLOSE_WAIT \n\n- 服务端不再需要连接时，发送连接释放报文，FIN=1 \n\n- 客户端收到后发出确认，进入**TIME_WAIT**状态，等待2MSL(最大报文存活时间)后释放连接 \n\n- 服务端收到客户端确认后释放连接 \n\n  > CLOSE_WAIT:状态让服务端发送完数据\n  >\n  > TIME_WAIT:确保确认报文能到达服务端，若未到达，服务端会再次发送释放报文。。                   \n  >\n  > ​\t\t     等待本连接产生的所有报文都从网络中消失，下一个新连接不会受到旧的请求报文 \n  >\n  > 可靠传输：超时重传 \n\n---\n\nPycharm相同路径下的文件无法引用问题：\n\n> 在该路径下右击，Mark Directory as Source Root\n","slug":"Java-Python","published":1,"updated":"2019-07-07T14:45:13.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2rv0013qsezfdj950h5","content":"<p>Java和Python的一些基础知识总结</p>\n<a id=\"more\"></a>\n<p>多线程、多进程、同步、异步、阻塞、非阻塞</p>\n<p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 </p>\n<p>同步才有阻塞和非阻塞之分</p>\n<p>同步：执行一个操作后等待结果，然后再继续后面的操作</p>\n<p>阻塞：进程给cpu传达一个任务后，一直等待cpu处理完成再进行后续操作</p>\n<p>非阻塞：进程给cpu传达一个任务后，继续处理后续操作，隔段时间再询问之前操作是否完成，也称轮询</p>\n<p>异步：执行一个操作后，可以去执行其他操作，等待通知再回来执行未完成操作 </p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><h5 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h5><p>Collection：</p>\n<p> java.util.Collection(接口) –extends java.lang.Iterable ，每一个位置存一个元素，没有get方法，只能通过iterator() 遍历元素</p>\n<ul>\n<li>List【维护一组元素特定顺序】<ul>\n<li><strong>ArrayList</strong>【查询快，基于arrays数组实现】</li>\n<li><strong>LinkedList</strong>【增删快，常用作队列】</li>\n<li><strong>Vector</strong>【实现同步，线程安全】</li>\n</ul>\n</li>\n<li>Queue<ul>\n<li><strong>PriorityQueue</strong>【基于堆结构实现】</li>\n</ul>\n</li>\n<li>Set【每个元素唯一】<ul>\n<li>SortedSet<ul>\n<li><strong>TreeSet</strong>【保持次序的set，基于红黑树实现，查找效率不如hashset】</li>\n</ul>\n</li>\n<li><strong>HashSet</strong>【定义了hashcode，支持快速查找，不支持有序性操作，使用iterator遍历的结果可能是不确定的】</li>\n<li><strong>LinkedHashSet</strong>【hash加快查询，链表维护元素次序，只能顺序访问，可以快速增删】</li>\n</ul>\n</li>\n</ul>\n<p>Map：</p>\n<p>java.util.Map(接口)      （key-value pair）</p>\n<ul>\n<li><strong>HashMap</strong></li>\n<li><strong>HashTable</strong>【线程安全】</li>\n<li><strong>ConcurrentHashMap</strong>【支持线程安全，且效率更高】</li>\n<li><strong>LinkedHashMap</strong>【使用链表维护元素顺序(插入顺序、LRU顺序)】</li>\n<li>SortedMap<ul>\n<li><strong>TreeMap</strong></li>\n</ul>\n</li>\n</ul>\n<p>array：容量固定且无法动态改变<br><strong>Arrays</strong>：操作array的类，拥有一组静态函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">List list = Arrays.asList();</span><br></pre></td></tr></table></figure></p>\n<p><strong>Collections</strong>：和Arrays一样是工具类<br><strong>包装类</strong>：</p>\n<ul>\n<li>对象型：Boolean、Character(object的直接子类)</li>\n<li>数值型：Byte、Double、Short、Integer、Float<br>基本数据类型：boolean、byte、char、short、int、float、long、double<br>包装类和基本类型的转化是自动拆箱装箱的，java把一些基本类型的常用对象存储在缓存池中，调用valueOf() 方法直接使用缓存池中的对象<blockquote>\n<p>valueOf() 和new 对象区别：new出来的对象虽然值一样但是不是同一个对象，所以x!=y</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>java不能隐式执行下转型1.1字面是double类型，不能执行float f = 1.1，只能执行float f = 1.1f但使用+=可以执行隐式类型转换 </p>\n</blockquote>\n<p><strong>String、StringBuilder、StringBuffer</strong>:</p>\n<blockquote>\n<p>String声明为final不可变，其他两个是可变的，StringBuilder线程不安全</p>\n</blockquote>\n<h5 id=\"常识梳理\"><a href=\"#常识梳理\" class=\"headerlink\" title=\"常识梳理\"></a>常识梳理</h5><p><strong>关键字</strong></p>\n<blockquote>\n<p>public,protected,default,private</p>\n<p>全局，自身子类包内，包内，自身 </p>\n</blockquote>\n<p><strong>参数传递方式</strong></p>\n<blockquote>\n<p>java的参数是以值传递的方式传入方法，而不是引用传递Dog dog = new Dog(‘a’);中的dog是存储对象地址的指针，在将一个参数传入方法时，本质是将对象的地址以值得方式传递到形参中 。</p>\n</blockquote>\n<p><strong>接口和抽象类</strong></p>\n<blockquote>\n<p>抽象类(IS-A):包含抽象方法的类（也可以不包含），也可以拥有成员变量和成员方法,不能被实例化，需要继承抽象类才能实例化其子类【抽象事物，模板式设计】</p>\n<p>抽象方法：只有声明没有具体实现，必须为public或者protected抽象类是为了继承而生的，子类必须实现父类的抽象方法，如果没有实现，也应该声明为抽象类 </p>\n<p>接口(LIKE-A)：极度抽象，一般都不定义变量（public(方法) 、成员变量只能static final），所有的方法（public abstract）都不能有具体的实现【抽象行为，辐射式设计】(从java8开始接口也可以拥有默认的方法实现，因为不支持默认方法的接口维护成本太高，接口增加方法要修改所有实现了该方法的类)</p>\n<p>只能继承一个抽象类，但是能实现多个接口 </p>\n</blockquote>\n<blockquote>\n<p>java中的接口有继承和实现两个概念，且支持多继承</p>\n<p>接口可以继承另外一个接口，并获得父接口所有的方法和成员变量</p>\n<p>接口也可以被一个类实现，实现接口的类需要实现接口及其父接口里的多有抽象方法（java1.8中增加了default关键字，允许接口里有非抽象方法，这些抽象方法可以不被接口的实现类实现）</p>\n<p>为什么接口支持多继承而类不可以？</p>\n<p>当继承多个类中有参数列表相同的方法时子类就会产生混淆，所以只能单继承，单继承限制了类的拓展性但是接口中的方法都为抽象方法，没有方法体，只有接口的实现类有方法的实现，所以不会产生混淆 </p>\n</blockquote>\n<p><strong>泛型</strong></p>\n<blockquote>\n<p>泛型：参数化类型</p>\n<p>泛型类型逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型？ </p>\n</blockquote>\n<p><strong>反射</strong></p>\n<blockquote>\n<p>运行时动态加载 </p>\n</blockquote>\n<p><strong>Object通用方法</strong></p>\n<blockquote>\n<p>equals和==：</p>\n<p>基本类型没有equals方法，\\==判断两个值是否相等引用类型equals判断引用的对象是否等价，\\==判断两个实例是否引用同一个对象 </p>\n<p>等价的两个实例散列值一定相同，但散列值相同的两个实例不一定等价，在覆盖equals方法时应该也覆盖hashCode方法，保证等价的实例有相同的hashcode </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EqualExample</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> z;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EqualExample</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> z)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.z = z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        EqualExample that = (EqualExample) o;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x!=that.x) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y!=that.y) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> z = that.z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EqualExample e1 = <span class=\"keyword\">new</span> EqualExample(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">EqualExample e2 = <span class=\"keyword\">new</span> EqualExample(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">syso(e1.equals(e2)); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">HashSet&lt;EqualExample&gt; s1 = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">s1.add(e1);</span><br><span class=\"line\">s1.add(e2);</span><br><span class=\"line\">syso(s1.size()) <span class=\"comment\">//2,没有重写hashcode方法</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">toString()</span></span><br><span class=\"line\"><span class=\"comment\">clone()</span></span><br><span class=\"line\"><span class=\"comment\">protect方法，必须显示重写才能调用</span></span><br><span class=\"line\"><span class=\"comment\">必须先实现cloneable接口才能调用clone方法</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneExample</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">        <span class=\"meta\">@override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> CloneExample <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (CloneExample)<span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CloneExample c1 = <span class=\"keyword\">new</span> CloneExample();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        CloneExample c2 = c1.clone();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"comment\">//java.lang.CloneNotSupportedException: CloneTest</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneExample</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> CloneExample <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (CloneExample)<span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//深拷贝(引用不同对象)和浅拷贝(引用同一对象)</span></span><br></pre></td></tr></table></figure>\n<p><strong>封装继承重写重载</strong></p>\n<blockquote>\n<p>封装</p>\n<p>子类覆盖父类的方法，子类中该方法的访问级别不能低于父类，(里式替换原则：子类对象必须能够替换所有的父类对象)字段不能公有，使用共有的getter，setter进行修改 </p>\n<p>重写：继承过程中</p>\n<p>重载：同一个类中同名方法，只有返回值不同不算重载方法名相同，参数列表不同（不同参数类型，参数顺序或参数个数），方法的返回值类型和修饰符与方法重载没有任何关系。 </p>\n</blockquote>\n<p><strong>初始化顺序</strong></p>\n<blockquote>\n<p>在存在继承的情况下，初始化顺序为：</p>\n<p>父类(静态变量，静态语句块)</p>\n<p>子类(静态变量，静态语句块)</p>\n<p>父类(实例变量，普通语句块)</p>\n<p>父类(构造函数)</p>\n<p>子类(实例变量，普通语句块)</p>\n<p>子类(构造函数) </p>\n</blockquote>\n<p><strong>虚拟机</strong></p>\n<blockquote>\n<ul>\n<li><p><strong>运行时数据区域</strong></p>\n<p><strong>THREAD</strong></p>\n<ul>\n<li><p><strong>程序计数器</strong>：</p>\n<p>记录正在执行的虚拟机字节码指令地址 </p>\n</li>\n<li><p><strong>虚拟机栈</strong>：</p>\n<p>每一个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等</p>\n<p>每一个方法调用到完成的过程对应一个栈帧在JVM中入栈和出栈的过程</p>\n<p>java -Xss=512M HackTheJava //指定大小 </p>\n</li>\n<li><p><strong>本地方法栈</strong>： </p>\n</li>\n</ul>\n<p><strong>堆</strong>：</p>\n<p>所有的对象实例在这里分配内存，垃圾收集的主要区域，不需要连续内存，可动态扩展</p>\n<p>新生代(Eden,From Survivor,To Survivor)</p>\n<p>老年代</p>\n<p>永久代</p>\n<p>java -Xms=1M -Xmx=2M HackTheJava </p>\n<p><strong>方法区</strong>：</p>\n<p>存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 </p>\n<ul>\n<li><strong>运行时常量池</strong>：方法区的一部分 </li>\n</ul>\n</li>\n<li><p><strong>直接内存</strong>：程序计数器、虚拟机栈、本地方法栈三个区域属于线程私有，只存在于线程的生命周期内，线程结束即消失，不需要垃圾收集</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>垃圾收集垃圾收集主要集中在堆和方法区 </p>\n</blockquote>\n<blockquote>\n<p>类加载机制：运行期间动态加载 </p>\n</blockquote>\n<p><strong>Spring、SpringBoot</strong></p>\n<p>TODO</p>\n<hr>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p><a href=\"https://eastlakeside.gitbooks.io/interpy-zh/content/\" target=\"_blank\" rel=\"noopener\">pythonGitbook</a></p>\n<p><strong>list、tuple、dict、set</strong></p>\n<ul>\n<li><p>list：列表，链表，有序，可索引，“[]”</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">append(y)、extend(L)、count(y)、index(y)、insert(i,y)、pop(y)、remove(y)、reverse()、sort()</span><br><span class=\"line\"><span class=\"comment\">#y--元素，L--列表</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>tuple：元组，对象集合，可索引，不能修改，“()”</p>\n<blockquote>\n<p>不可变，能保证代码的安全性</p>\n<p>len()，tuple[y]</p>\n<p>同样可以索引切片连接重复</p>\n</blockquote>\n</li>\n<li><p>dict：字典，key-value组合，无序，（空间换时间），“{}”</p>\n<blockquote>\n<p>不允许一个键对应多个值</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict.keys(),dict.values(),dict.items()</span><br><span class=\"line\">hash(obj) <span class=\"comment\">##--&gt;可作为key</span></span><br><span class=\"line\"><span class=\"keyword\">del</span>,dict.pop,clear</span><br><span class=\"line\">sorted(dict.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">0</span>])</span><br><span class=\"line\">dict.get()</span><br><span class=\"line\">dict.setdefault()</span><br><span class=\"line\">&#123;&#125;.fromkeys((<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>),<span class=\"keyword\">True</span>)  <span class=\"comment\">#&#123;'a':True,'b':True&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>set：集合，无序，元素自动去重，“set([])”</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add,update,remove</span><br><span class=\"line\">discard与remove <span class=\"comment\">#【如果删除的元素不在集合内，discard不会报错】</span></span><br><span class=\"line\"><span class=\"comment\">#|(联合),&amp;(交集),-(差集),^(差分)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>collections</strong></p>\n<ul>\n<li>defaultdict(不需要检查key是否存在，减少keyerror的发生)</li>\n<li>Counter</li>\n<li>deque：双端队列</li>\n<li>namedtuple：可以像字典一样访问，但是是不可变的</li>\n</ul>\n<p><strong>dict排序</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp_list = sorted(tmp_list.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">1</span>],reverse = <span class=\"keyword\">True</span>)  <span class=\"comment\">##按value、反序</span></span><br></pre></td></tr></table></figure>\n<p><strong>交集并集差集</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(list(set(b).difference(set(a))))</span><br><span class=\"line\">print(list(set(b).union(set(a))))</span><br><span class=\"line\">print(list(set(b).intersection(set(a))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#检查是否有重复元素</span></span><br><span class=\"line\">duplicates = set([x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> some_list <span class=\"keyword\">if</span> some_list.count(x) &gt; <span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n<p><strong>xrange、range</strong></p>\n<p>xrange返回一个迭代器，range返回一个list</p>\n<p><strong>生成器</strong></p>\n<p><strong>@property</strong></p>\n<p>将一个函数定义为特性，直接obj.name使用，遵循统一访问的原则 ，相当与get set？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stu</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @property #相当于get方法，调用简单方便可控</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._score</span><br><span class=\"line\"><span class=\"meta\">    @score.setter #set方法，</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self,value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value,int):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'must be int'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> value&lt;<span class=\"number\">0</span> <span class=\"keyword\">or</span> value&gt;<span class=\"number\">100</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'must 0&lt;x&lt;100'</span>)</span><br><span class=\"line\">            self._score = value</span><br></pre></td></tr></table></figure>\n<p><strong>@staticmethod、@classmethod</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Date</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    day = <span class=\"number\">0</span></span><br><span class=\"line\">    month = <span class=\"number\">0</span></span><br><span class=\"line\">    year = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,day=<span class=\"number\">0</span>,month=<span class=\"number\">0</span>,year=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        self.day = day</span><br><span class=\"line\">        self.month = month</span><br><span class=\"line\">        self.year = year</span><br><span class=\"line\"><span class=\"meta\">    @classmethod #尝试一种另类的构造函数，python缺乏重载的特性</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_string</span><span class=\"params\">(cls,date_as_string)</span>:</span></span><br><span class=\"line\">        day,month,year = map(int,date_as_string.split(<span class=\"string\">'-'</span>))</span><br><span class=\"line\">        date1 = cls(day,month,year)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> date1</span><br><span class=\"line\"><span class=\"meta\">    @staticmethod #不需要访问类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_date_valid</span><span class=\"params\">(date_as_string)</span>:</span></span><br><span class=\"line\">        day,month,year = map(int,date_as_string.split(<span class=\"string\">'-'</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> day&lt;=<span class=\"number\">31</span> <span class=\"keyword\">and</span> month&lt;=<span class=\"number\">12</span> <span class=\"keyword\">and</span> year&lt;=<span class=\"number\">2019</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    s = Stu()</span><br><span class=\"line\">    s.score = <span class=\"number\">60</span></span><br><span class=\"line\">    print(s.score)</span><br><span class=\"line\">    <span class=\"comment\"># s.score = 999</span></span><br><span class=\"line\">    date2 = Date.from_string(<span class=\"string\">'06-08-2018'</span>)</span><br><span class=\"line\">    is_date = Date.is_date_valid(<span class=\"string\">'06-08-2019'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(date2.day)</span><br><span class=\"line\">    print(is_date)</span><br></pre></td></tr></table></figure>\n<p><strong>enumerate</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(list1)):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (i,list1[i])</span><br><span class=\"line\"><span class=\"comment\">#enumerate的用法</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,item <span class=\"keyword\">in</span> enumerate(list1):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (index,item)</span><br><span class=\"line\"><span class=\"comment\">#enumerate还可以指定索引的起始值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,item <span class=\"keyword\">in</span> enumerate(list1,<span class=\"number\">1</span>):</span><br><span class=\"line\">    print(index,item)</span><br><span class=\"line\"><span class=\"comment\">#简单的统计文件行数的方法</span></span><br><span class=\"line\">count = len(open(filepath,<span class=\"string\">'r'</span>).readlines())</span><br><span class=\"line\"></span><br><span class=\"line\">count=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,line <span class=\"keyword\">in</span> enumerate(open(filepath,<span class=\"string\">'r'</span>)):</span><br><span class=\"line\">    count+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p><strong>多线程多进程</strong></p>\n<blockquote>\n<p>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。不能多线程并发。 </p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> os,time,random</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process,Pool,cpu_count,Queue</span><br><span class=\"line\"><span class=\"keyword\">import</span> subprocess</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># parser = argparse.ArgumentParser()</span></span><br><span class=\"line\"><span class=\"comment\"># parser.add_argument('integer',type=int,help='display an integer')</span></span><br><span class=\"line\"><span class=\"comment\"># args = parser.parse_args()</span></span><br><span class=\"line\"><span class=\"comment\"># print(args.integer)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># parser.add_argument(\"--square\",help=\"display a square of a given number\",type=int)</span></span><br><span class=\"line\"><span class=\"comment\"># parser.add_argument(\"--cubic\",help=\"display a cubic of a given number\",type=int)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># args = parser.parse_args()</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># if args.square:</span></span><br><span class=\"line\"><span class=\"comment\">#     print(args.square**2)</span></span><br><span class=\"line\"><span class=\"comment\"># if args.cubic:</span></span><br><span class=\"line\"><span class=\"comment\">#     print(args.cubic**3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_proc</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> %(name,os.getpid()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">long_time_task</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> %(name,os.getpid()))</span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    time.sleep(random.random()*<span class=\"number\">3</span>)</span><br><span class=\"line\">    end = time.time()</span><br><span class=\"line\">    print(<span class=\"string\">'Task %s runs %.2f seconds'</span> % (name,(end-start)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Process to write: %s'</span> % os.getpid())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>]:</span><br><span class=\"line\">    print(<span class=\"string\">'put %s queue '</span> % value)</span><br><span class=\"line\">    q.put(value)</span><br><span class=\"line\">    time.sleep(random.random())</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Process to read: %s'</span> % os.getpid())</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        value = q.get(<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    print(<span class=\"string\">'get %s from queue'</span> % value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n&lt;<span class=\"number\">5</span>:</span><br><span class=\"line\">        n = n+<span class=\"number\">1</span></span><br><span class=\"line\">        print(<span class=\"string\">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name,n))</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'thread %s ended'</span> % threading.current_thread().name)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#进程，进程池</span></span><br><span class=\"line\">    print(cpu_count())</span><br><span class=\"line\">    print(<span class=\"string\">'Parent process %s'</span> % os.getpid())</span><br><span class=\"line\">    <span class=\"comment\"># p = Process(target=run_proc,args=('test',))</span></span><br><span class=\"line\">    p = Pool(<span class=\"number\">32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">33</span>):</span><br><span class=\"line\">        p.apply_async(long_time_task,args=(i,))</span><br><span class=\"line\">        <span class=\"comment\"># print('Child process start')</span></span><br><span class=\"line\">        <span class=\"comment\"># p.start()</span></span><br><span class=\"line\">        <span class=\"comment\"># p.join()</span></span><br><span class=\"line\">        <span class=\"comment\"># print('Child process end')</span></span><br><span class=\"line\">        print(<span class=\"string\">'waiting for all subprocess done'</span>)</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">        p.join()</span><br><span class=\"line\">        print(<span class=\"string\">'All subprocess done'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#进程执行</span></span><br><span class=\"line\">r = subprocess.call([<span class=\"string\">'nslookup'</span>,<span class=\"string\">'https://pamperxg.github.io'</span>])</span><br><span class=\"line\">print(<span class=\"string\">'Exit code:'</span>,r)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#进程间通信</span></span><br><span class=\"line\">q = Queue()</span><br><span class=\"line\">pw = Process(target=write,args=(q,))</span><br><span class=\"line\">pr = Process(target=read,args=(q,))</span><br><span class=\"line\">pw.start()</span><br><span class=\"line\">pr.start()</span><br><span class=\"line\">pw.join()</span><br><span class=\"line\">pr.terminate()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#线程</span></span><br><span class=\"line\">t = threading.Thread(target=loop,name=<span class=\"string\">'LoopThread'</span>)</span><br><span class=\"line\">t.start()</span><br><span class=\"line\">t.join()</span><br><span class=\"line\">print(<span class=\"string\">'thread %s ended'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>\n<p><strong>数据库连接</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ConnectDataBase</span><span class=\"params\">(self,db_name,user_name,password)</span>:</span></span><br><span class=\"line\">        conn = mdb.connect(host=<span class=\"string\">'88.88.88.88'</span>,port=<span class=\"number\">3306</span>,user=user_name,passwd=password,\\</span><br><span class=\"line\">                           db=db_name,charset=<span class=\"string\">'utf8'</span>)</span><br><span class=\"line\">        cursor = conn.cursor()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (conn,cursor)</span><br></pre></td></tr></table></figure>\n<p><strong>pandas操作</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#选取指定列进行操作</span></span><br><span class=\"line\">df.loc[(df.Cabin.notnull()),<span class=\"string\">'Cabin'</span>] = <span class=\"string\">'Yes'</span>  <span class=\"comment\">#选取指定列替换为yes</span></span><br><span class=\"line\">df.loc[df.Team.isin([<span class=\"string\">'England'</span>,<span class=\"string\">'Italy'</span>,<span class=\"string\">'Russia'</span>]),[<span class=\"string\">'Team'</span>,<span class=\"string\">'Shooting Accuracy'</span>]] <span class=\"comment\">#选取满足条件的列</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">df.groupby(<span class=\"string\">'a'</span>,as_index=<span class=\"keyword\">False</span>).sum()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#分组排序，算位置</span></span><br><span class=\"line\"><span class=\"comment\">#groupby时as_index=False和True的区别</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_level</span><span class=\"params\">(data,key,values,ascending=True)</span>:</span></span><br><span class=\"line\">    data_temp = data[key + [values]].copy()</span><br><span class=\"line\">    data_temp.sort_values(key + [values], inplace=<span class=\"keyword\">True</span>, ascending=ascending)</span><br><span class=\"line\">    data_temp[<span class=\"string\">'rank'</span>] = range(data_temp.shape[<span class=\"number\">0</span>])</span><br><span class=\"line\">    data_tmp[<span class=\"string\">'rank'</span>] = data_tmp[<span class=\"string\">'rank'</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">    min_rank = data_temp.groupby(key,as_index=<span class=\"keyword\">False</span>)[<span class=\"string\">'rank'</span>].agg(&#123;<span class=\"string\">'min_rank'</span>:<span class=\"string\">'min'</span>&#125;)</span><br><span class=\"line\">    index = data_temp.index</span><br><span class=\"line\">    data_temp = data_temp.merge(min_rank,on=key,how=<span class=\"string\">'left'</span>)</span><br><span class=\"line\">    data_temp[<span class=\"string\">'rank'</span>] = data_temp[<span class=\"string\">'rank'</span>] - data_temp[<span class=\"string\">'min_rank'</span>]</span><br><span class=\"line\">    max_rank = data_temp.groupby(key,as_index=<span class=\"keyword\">False</span>)[<span class=\"string\">'rank'</span>].agg(&#123;<span class=\"string\">'max_rank'</span>:<span class=\"string\">'max'</span>&#125;)</span><br><span class=\"line\">    data_temp = data_temp.merge(max_rank,on=key,how=<span class=\"string\">'left'</span>)</span><br><span class=\"line\">    data_temp.index = index</span><br><span class=\"line\">    data_temp[<span class=\"string\">'slevel'</span>] = round(data_temp[<span class=\"string\">'rank'</span>]/data_temp[<span class=\"string\">'max_rank'</span>],<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_temp[<span class=\"string\">'slevel'</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#shift、diff函数</span></span><br></pre></td></tr></table></figure>\n<p><strong>loc、iloc、ix</strong></p>\n<blockquote>\n<p>loc：在行标签上进行索引，包括start和end</p>\n<p>iloc：在行标签位置上进行索引，不包括end</p>\n<p>ix：在行标签上索引，索引不到就到位置上索引（如果index非全部整数）,不包括end</p>\n<blockquote>\n<p>.ix is deprecated. Please use<br>.loc for label based indexing or<br>.iloc for positional indexing</p>\n</blockquote>\n</blockquote>\n<p><strong>map、filter、reduce</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">squared = list(map(<span class=\"keyword\">lambda</span> x:x**<span class=\"number\">2</span>,items)) <span class=\"comment\">#map python3返回迭代器，python2返回列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">less_than_zero = filter(<span class=\"keyword\">lambda</span> x:x&lt;<span class=\"number\">0</span>,number_list) <span class=\"comment\">#同python3返回迭代器，python2返回列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#对一个列表进行计算并且返回结果</span></span><br><span class=\"line\">product = reduce((<span class=\"keyword\">lambda</span> x,y:x*y),[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]) <span class=\"comment\">#24</span></span><br></pre></td></tr></table></figure>\n<p><strong>时间处理</strong>(python、pandas)：</p>\n<p>python标准库：datetime、time、calendar</p>\n<ul>\n<li>其中datetime模块中的标准数据类型有：date、time、datetime、timedeltad</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime,timedelta</span><br><span class=\"line\">datetime.now()</span><br><span class=\"line\"><span class=\"comment\">#2</span></span><br><span class=\"line\">[datetime.strptime(x,<span class=\"string\">'%Y-%m-%d'</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> date]</span><br><span class=\"line\"><span class=\"comment\">#3</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> dateutil.parser <span class=\"keyword\">import</span> parse</span><br><span class=\"line\">parse(<span class=\"string\">'2018-10-10'</span>)</span><br><span class=\"line\"><span class=\"comment\">#4</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\">pd.to_datetime(date)</span><br></pre></td></tr></table></figure>\n<p><strong>网络相关</strong>：</p>\n<p>应用层：为特定应用程序提供数据传输服务，http，dns</p>\n<p>运输层：进程间的通用数据传输服务，TCP、UDP</p>\n<p>网络层：主机间的数据传输服务</p>\n<p>数据链路层：为同一链路的主机提供服务</p>\n<p>物理层：怎样在传输媒体上传输数据比特流 </p>\n<p>表示层</p>\n<p>会话层 </p>\n<p>TCP/UDP：—  应用层：http，dns                  </p>\n<p>​            —   运输层：tcp，udp                  </p>\n<p>​                    —   网际层 ：IP                  </p>\n<pre><code>---   网络接口层： \n</code></pre><blockquote>\n<p>UDP是无连接的，支持一对一，一对多，多对一，多对多</p>\n<p>TCP是面向连接的，只能一对一</p>\n</blockquote>\n<p>序号，确认号，数据偏移，确认ACK，同步SYN，中止FIN，窗口 </p>\n<p><em>TCP三次握手，四次挥手：</em></p>\n<ul>\n<li><p>服务端处于listen状态，等待客户端的连接请求</p>\n</li>\n<li><p>客户端向服务端发送请求报文，SYN=1，ACK=0，初始序号x </p>\n</li>\n<li><p>服务端收到请求报文后，若同意连接，向客户端发送确认报文，SYN=1,ACK=1，确认号ack=x+1,初始序号y </p>\n</li>\n<li><p>客户端收到确认报文后，继续向服务端发出确认，确认号ack=y+1，序号为x+1 </p>\n</li>\n<li><p>服务端收到客户端确认后，连接建立</p>\n<blockquote>\n<p>防止失效连接请求到达服务器</p>\n<p>如果客户端发送的连接请求在网络中滞留，滞留时间超过客户端超时重传时间后，客户端会重新请求连接，延时的请求还是会到达服务端，如果不进行三次握手，服务器就会打开两个连接，有三次握手就会忽略滞留连接请求的连接确认，不进行三次握手，所以不会再次打开连接。 </p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>客户端发送连接释放报文，FIN=1 </p>\n</li>\n<li><p>服务端收到后发出确认，此时TCP处于<strong>半关闭状态</strong>，服务器端能向客户端发送数据，反之不行/ CLOSE_WAIT </p>\n</li>\n<li><p>服务端不再需要连接时，发送连接释放报文，FIN=1 </p>\n</li>\n<li><p>客户端收到后发出确认，进入<strong>TIME_WAIT</strong>状态，等待2MSL(最大报文存活时间)后释放连接 </p>\n</li>\n<li><p>服务端收到客户端确认后释放连接 </p>\n<blockquote>\n<p>CLOSE_WAIT:状态让服务端发送完数据</p>\n<p>TIME_WAIT:确保确认报文能到达服务端，若未到达，服务端会再次发送释放报文。。                   </p>\n<p>​             等待本连接产生的所有报文都从网络中消失，下一个新连接不会受到旧的请求报文 </p>\n<p>可靠传输：超时重传 </p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<p>Pycharm相同路径下的文件无法引用问题：</p>\n<blockquote>\n<p>在该路径下右击，Mark Directory as Source Root</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Java和Python的一些基础知识总结</p>","more":"<p>多线程、多进程、同步、异步、阻塞、非阻塞</p>\n<p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。 </p>\n<p>同步才有阻塞和非阻塞之分</p>\n<p>同步：执行一个操作后等待结果，然后再继续后面的操作</p>\n<p>阻塞：进程给cpu传达一个任务后，一直等待cpu处理完成再进行后续操作</p>\n<p>非阻塞：进程给cpu传达一个任务后，继续处理后续操作，隔段时间再询问之前操作是否完成，也称轮询</p>\n<p>异步：执行一个操作后，可以去执行其他操作，等待通知再回来执行未完成操作 </p>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><h5 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h5><p>Collection：</p>\n<p> java.util.Collection(接口) –extends java.lang.Iterable ，每一个位置存一个元素，没有get方法，只能通过iterator() 遍历元素</p>\n<ul>\n<li>List【维护一组元素特定顺序】<ul>\n<li><strong>ArrayList</strong>【查询快，基于arrays数组实现】</li>\n<li><strong>LinkedList</strong>【增删快，常用作队列】</li>\n<li><strong>Vector</strong>【实现同步，线程安全】</li>\n</ul>\n</li>\n<li>Queue<ul>\n<li><strong>PriorityQueue</strong>【基于堆结构实现】</li>\n</ul>\n</li>\n<li>Set【每个元素唯一】<ul>\n<li>SortedSet<ul>\n<li><strong>TreeSet</strong>【保持次序的set，基于红黑树实现，查找效率不如hashset】</li>\n</ul>\n</li>\n<li><strong>HashSet</strong>【定义了hashcode，支持快速查找，不支持有序性操作，使用iterator遍历的结果可能是不确定的】</li>\n<li><strong>LinkedHashSet</strong>【hash加快查询，链表维护元素次序，只能顺序访问，可以快速增删】</li>\n</ul>\n</li>\n</ul>\n<p>Map：</p>\n<p>java.util.Map(接口)      （key-value pair）</p>\n<ul>\n<li><strong>HashMap</strong></li>\n<li><strong>HashTable</strong>【线程安全】</li>\n<li><strong>ConcurrentHashMap</strong>【支持线程安全，且效率更高】</li>\n<li><strong>LinkedHashMap</strong>【使用链表维护元素顺序(插入顺序、LRU顺序)】</li>\n<li>SortedMap<ul>\n<li><strong>TreeMap</strong></li>\n</ul>\n</li>\n</ul>\n<p>array：容量固定且无法动态改变<br><strong>Arrays</strong>：操作array的类，拥有一组静态函数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">List list = Arrays.asList();</span><br></pre></td></tr></table></figure></p>\n<p><strong>Collections</strong>：和Arrays一样是工具类<br><strong>包装类</strong>：</p>\n<ul>\n<li>对象型：Boolean、Character(object的直接子类)</li>\n<li>数值型：Byte、Double、Short、Integer、Float<br>基本数据类型：boolean、byte、char、short、int、float、long、double<br>包装类和基本类型的转化是自动拆箱装箱的，java把一些基本类型的常用对象存储在缓存池中，调用valueOf() 方法直接使用缓存池中的对象<blockquote>\n<p>valueOf() 和new 对象区别：new出来的对象虽然值一样但是不是同一个对象，所以x!=y</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>java不能隐式执行下转型1.1字面是double类型，不能执行float f = 1.1，只能执行float f = 1.1f但使用+=可以执行隐式类型转换 </p>\n</blockquote>\n<p><strong>String、StringBuilder、StringBuffer</strong>:</p>\n<blockquote>\n<p>String声明为final不可变，其他两个是可变的，StringBuilder线程不安全</p>\n</blockquote>\n<h5 id=\"常识梳理\"><a href=\"#常识梳理\" class=\"headerlink\" title=\"常识梳理\"></a>常识梳理</h5><p><strong>关键字</strong></p>\n<blockquote>\n<p>public,protected,default,private</p>\n<p>全局，自身子类包内，包内，自身 </p>\n</blockquote>\n<p><strong>参数传递方式</strong></p>\n<blockquote>\n<p>java的参数是以值传递的方式传入方法，而不是引用传递Dog dog = new Dog(‘a’);中的dog是存储对象地址的指针，在将一个参数传入方法时，本质是将对象的地址以值得方式传递到形参中 。</p>\n</blockquote>\n<p><strong>接口和抽象类</strong></p>\n<blockquote>\n<p>抽象类(IS-A):包含抽象方法的类（也可以不包含），也可以拥有成员变量和成员方法,不能被实例化，需要继承抽象类才能实例化其子类【抽象事物，模板式设计】</p>\n<p>抽象方法：只有声明没有具体实现，必须为public或者protected抽象类是为了继承而生的，子类必须实现父类的抽象方法，如果没有实现，也应该声明为抽象类 </p>\n<p>接口(LIKE-A)：极度抽象，一般都不定义变量（public(方法) 、成员变量只能static final），所有的方法（public abstract）都不能有具体的实现【抽象行为，辐射式设计】(从java8开始接口也可以拥有默认的方法实现，因为不支持默认方法的接口维护成本太高，接口增加方法要修改所有实现了该方法的类)</p>\n<p>只能继承一个抽象类，但是能实现多个接口 </p>\n</blockquote>\n<blockquote>\n<p>java中的接口有继承和实现两个概念，且支持多继承</p>\n<p>接口可以继承另外一个接口，并获得父接口所有的方法和成员变量</p>\n<p>接口也可以被一个类实现，实现接口的类需要实现接口及其父接口里的多有抽象方法（java1.8中增加了default关键字，允许接口里有非抽象方法，这些抽象方法可以不被接口的实现类实现）</p>\n<p>为什么接口支持多继承而类不可以？</p>\n<p>当继承多个类中有参数列表相同的方法时子类就会产生混淆，所以只能单继承，单继承限制了类的拓展性但是接口中的方法都为抽象方法，没有方法体，只有接口的实现类有方法的实现，所以不会产生混淆 </p>\n</blockquote>\n<p><strong>泛型</strong></p>\n<blockquote>\n<p>泛型：参数化类型</p>\n<p>泛型类型逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型？ </p>\n</blockquote>\n<p><strong>反射</strong></p>\n<blockquote>\n<p>运行时动态加载 </p>\n</blockquote>\n<p><strong>Object通用方法</strong></p>\n<blockquote>\n<p>equals和==：</p>\n<p>基本类型没有equals方法，\\==判断两个值是否相等引用类型equals判断引用的对象是否等价，\\==判断两个实例是否引用同一个对象 </p>\n<p>等价的两个实例散列值一定相同，但散列值相同的两个实例不一定等价，在覆盖equals方法时应该也覆盖hashCode方法，保证等价的实例有相同的hashcode </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EqualExample</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> z;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EqualExample</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> z)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.z = z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        EqualExample that = (EqualExample) o;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x!=that.x) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y!=that.y) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> z = that.z;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EqualExample e1 = <span class=\"keyword\">new</span> EqualExample(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">EqualExample e2 = <span class=\"keyword\">new</span> EqualExample(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">syso(e1.equals(e2)); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">HashSet&lt;EqualExample&gt; s1 = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">s1.add(e1);</span><br><span class=\"line\">s1.add(e2);</span><br><span class=\"line\">syso(s1.size()) <span class=\"comment\">//2,没有重写hashcode方法</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">toString()</span></span><br><span class=\"line\"><span class=\"comment\">clone()</span></span><br><span class=\"line\"><span class=\"comment\">protect方法，必须显示重写才能调用</span></span><br><span class=\"line\"><span class=\"comment\">必须先实现cloneable接口才能调用clone方法</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneExample</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">        <span class=\"meta\">@override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> CloneExample <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (CloneExample)<span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CloneExample c1 = <span class=\"keyword\">new</span> CloneExample();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        CloneExample c2 = c1.clone();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"comment\">//java.lang.CloneNotSupportedException: CloneTest</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneExample</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> CloneExample <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (CloneExample)<span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//深拷贝(引用不同对象)和浅拷贝(引用同一对象)</span></span><br></pre></td></tr></table></figure>\n<p><strong>封装继承重写重载</strong></p>\n<blockquote>\n<p>封装</p>\n<p>子类覆盖父类的方法，子类中该方法的访问级别不能低于父类，(里式替换原则：子类对象必须能够替换所有的父类对象)字段不能公有，使用共有的getter，setter进行修改 </p>\n<p>重写：继承过程中</p>\n<p>重载：同一个类中同名方法，只有返回值不同不算重载方法名相同，参数列表不同（不同参数类型，参数顺序或参数个数），方法的返回值类型和修饰符与方法重载没有任何关系。 </p>\n</blockquote>\n<p><strong>初始化顺序</strong></p>\n<blockquote>\n<p>在存在继承的情况下，初始化顺序为：</p>\n<p>父类(静态变量，静态语句块)</p>\n<p>子类(静态变量，静态语句块)</p>\n<p>父类(实例变量，普通语句块)</p>\n<p>父类(构造函数)</p>\n<p>子类(实例变量，普通语句块)</p>\n<p>子类(构造函数) </p>\n</blockquote>\n<p><strong>虚拟机</strong></p>\n<blockquote>\n<ul>\n<li><p><strong>运行时数据区域</strong></p>\n<p><strong>THREAD</strong></p>\n<ul>\n<li><p><strong>程序计数器</strong>：</p>\n<p>记录正在执行的虚拟机字节码指令地址 </p>\n</li>\n<li><p><strong>虚拟机栈</strong>：</p>\n<p>每一个java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等</p>\n<p>每一个方法调用到完成的过程对应一个栈帧在JVM中入栈和出栈的过程</p>\n<p>java -Xss=512M HackTheJava //指定大小 </p>\n</li>\n<li><p><strong>本地方法栈</strong>： </p>\n</li>\n</ul>\n<p><strong>堆</strong>：</p>\n<p>所有的对象实例在这里分配内存，垃圾收集的主要区域，不需要连续内存，可动态扩展</p>\n<p>新生代(Eden,From Survivor,To Survivor)</p>\n<p>老年代</p>\n<p>永久代</p>\n<p>java -Xms=1M -Xmx=2M HackTheJava </p>\n<p><strong>方法区</strong>：</p>\n<p>存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 </p>\n<ul>\n<li><strong>运行时常量池</strong>：方法区的一部分 </li>\n</ul>\n</li>\n<li><p><strong>直接内存</strong>：程序计数器、虚拟机栈、本地方法栈三个区域属于线程私有，只存在于线程的生命周期内，线程结束即消失，不需要垃圾收集</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>垃圾收集垃圾收集主要集中在堆和方法区 </p>\n</blockquote>\n<blockquote>\n<p>类加载机制：运行期间动态加载 </p>\n</blockquote>\n<p><strong>Spring、SpringBoot</strong></p>\n<p>TODO</p>\n<hr>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><p><a href=\"https://eastlakeside.gitbooks.io/interpy-zh/content/\" target=\"_blank\" rel=\"noopener\">pythonGitbook</a></p>\n<p><strong>list、tuple、dict、set</strong></p>\n<ul>\n<li><p>list：列表，链表，有序，可索引，“[]”</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">append(y)、extend(L)、count(y)、index(y)、insert(i,y)、pop(y)、remove(y)、reverse()、sort()</span><br><span class=\"line\"><span class=\"comment\">#y--元素，L--列表</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>tuple：元组，对象集合，可索引，不能修改，“()”</p>\n<blockquote>\n<p>不可变，能保证代码的安全性</p>\n<p>len()，tuple[y]</p>\n<p>同样可以索引切片连接重复</p>\n</blockquote>\n</li>\n<li><p>dict：字典，key-value组合，无序，（空间换时间），“{}”</p>\n<blockquote>\n<p>不允许一个键对应多个值</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict.keys(),dict.values(),dict.items()</span><br><span class=\"line\">hash(obj) <span class=\"comment\">##--&gt;可作为key</span></span><br><span class=\"line\"><span class=\"keyword\">del</span>,dict.pop,clear</span><br><span class=\"line\">sorted(dict.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">0</span>])</span><br><span class=\"line\">dict.get()</span><br><span class=\"line\">dict.setdefault()</span><br><span class=\"line\">&#123;&#125;.fromkeys((<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>),<span class=\"keyword\">True</span>)  <span class=\"comment\">#&#123;'a':True,'b':True&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>set：集合，无序，元素自动去重，“set([])”</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add,update,remove</span><br><span class=\"line\">discard与remove <span class=\"comment\">#【如果删除的元素不在集合内，discard不会报错】</span></span><br><span class=\"line\"><span class=\"comment\">#|(联合),&amp;(交集),-(差集),^(差分)</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>collections</strong></p>\n<ul>\n<li>defaultdict(不需要检查key是否存在，减少keyerror的发生)</li>\n<li>Counter</li>\n<li>deque：双端队列</li>\n<li>namedtuple：可以像字典一样访问，但是是不可变的</li>\n</ul>\n<p><strong>dict排序</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp_list = sorted(tmp_list.items(),key = <span class=\"keyword\">lambda</span> d:d[<span class=\"number\">1</span>],reverse = <span class=\"keyword\">True</span>)  <span class=\"comment\">##按value、反序</span></span><br></pre></td></tr></table></figure>\n<p><strong>交集并集差集</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(list(set(b).difference(set(a))))</span><br><span class=\"line\">print(list(set(b).union(set(a))))</span><br><span class=\"line\">print(list(set(b).intersection(set(a))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#检查是否有重复元素</span></span><br><span class=\"line\">duplicates = set([x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> some_list <span class=\"keyword\">if</span> some_list.count(x) &gt; <span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n<p><strong>xrange、range</strong></p>\n<p>xrange返回一个迭代器，range返回一个list</p>\n<p><strong>生成器</strong></p>\n<p><strong>@property</strong></p>\n<p>将一个函数定义为特性，直接obj.name使用，遵循统一访问的原则 ，相当与get set？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stu</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @property #相当于get方法，调用简单方便可控</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._score</span><br><span class=\"line\"><span class=\"meta\">    @score.setter #set方法，</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self,value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value,int):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'must be int'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> value&lt;<span class=\"number\">0</span> <span class=\"keyword\">or</span> value&gt;<span class=\"number\">100</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'must 0&lt;x&lt;100'</span>)</span><br><span class=\"line\">            self._score = value</span><br></pre></td></tr></table></figure>\n<p><strong>@staticmethod、@classmethod</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Date</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    day = <span class=\"number\">0</span></span><br><span class=\"line\">    month = <span class=\"number\">0</span></span><br><span class=\"line\">    year = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,day=<span class=\"number\">0</span>,month=<span class=\"number\">0</span>,year=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        self.day = day</span><br><span class=\"line\">        self.month = month</span><br><span class=\"line\">        self.year = year</span><br><span class=\"line\"><span class=\"meta\">    @classmethod #尝试一种另类的构造函数，python缺乏重载的特性</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_string</span><span class=\"params\">(cls,date_as_string)</span>:</span></span><br><span class=\"line\">        day,month,year = map(int,date_as_string.split(<span class=\"string\">'-'</span>))</span><br><span class=\"line\">        date1 = cls(day,month,year)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> date1</span><br><span class=\"line\"><span class=\"meta\">    @staticmethod #不需要访问类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_date_valid</span><span class=\"params\">(date_as_string)</span>:</span></span><br><span class=\"line\">        day,month,year = map(int,date_as_string.split(<span class=\"string\">'-'</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> day&lt;=<span class=\"number\">31</span> <span class=\"keyword\">and</span> month&lt;=<span class=\"number\">12</span> <span class=\"keyword\">and</span> year&lt;=<span class=\"number\">2019</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    s = Stu()</span><br><span class=\"line\">    s.score = <span class=\"number\">60</span></span><br><span class=\"line\">    print(s.score)</span><br><span class=\"line\">    <span class=\"comment\"># s.score = 999</span></span><br><span class=\"line\">    date2 = Date.from_string(<span class=\"string\">'06-08-2018'</span>)</span><br><span class=\"line\">    is_date = Date.is_date_valid(<span class=\"string\">'06-08-2019'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(date2.day)</span><br><span class=\"line\">    print(is_date)</span><br></pre></td></tr></table></figure>\n<p><strong>enumerate</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(list1)):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (i,list1[i])</span><br><span class=\"line\"><span class=\"comment\">#enumerate的用法</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,item <span class=\"keyword\">in</span> enumerate(list1):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> (index,item)</span><br><span class=\"line\"><span class=\"comment\">#enumerate还可以指定索引的起始值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,item <span class=\"keyword\">in</span> enumerate(list1,<span class=\"number\">1</span>):</span><br><span class=\"line\">    print(index,item)</span><br><span class=\"line\"><span class=\"comment\">#简单的统计文件行数的方法</span></span><br><span class=\"line\">count = len(open(filepath,<span class=\"string\">'r'</span>).readlines())</span><br><span class=\"line\"></span><br><span class=\"line\">count=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,line <span class=\"keyword\">in</span> enumerate(open(filepath,<span class=\"string\">'r'</span>)):</span><br><span class=\"line\">    count+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p><strong>多线程多进程</strong></p>\n<blockquote>\n<p>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。不能多线程并发。 </p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> os,time,random</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process,Pool,cpu_count,Queue</span><br><span class=\"line\"><span class=\"keyword\">import</span> subprocess</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># parser = argparse.ArgumentParser()</span></span><br><span class=\"line\"><span class=\"comment\"># parser.add_argument('integer',type=int,help='display an integer')</span></span><br><span class=\"line\"><span class=\"comment\"># args = parser.parse_args()</span></span><br><span class=\"line\"><span class=\"comment\"># print(args.integer)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># parser.add_argument(\"--square\",help=\"display a square of a given number\",type=int)</span></span><br><span class=\"line\"><span class=\"comment\"># parser.add_argument(\"--cubic\",help=\"display a cubic of a given number\",type=int)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># args = parser.parse_args()</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># if args.square:</span></span><br><span class=\"line\"><span class=\"comment\">#     print(args.square**2)</span></span><br><span class=\"line\"><span class=\"comment\"># if args.cubic:</span></span><br><span class=\"line\"><span class=\"comment\">#     print(args.cubic**3)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_proc</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> %(name,os.getpid()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">long_time_task</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> %(name,os.getpid()))</span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    time.sleep(random.random()*<span class=\"number\">3</span>)</span><br><span class=\"line\">    end = time.time()</span><br><span class=\"line\">    print(<span class=\"string\">'Task %s runs %.2f seconds'</span> % (name,(end-start)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Process to write: %s'</span> % os.getpid())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>]:</span><br><span class=\"line\">    print(<span class=\"string\">'put %s queue '</span> % value)</span><br><span class=\"line\">    q.put(value)</span><br><span class=\"line\">    time.sleep(random.random())</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read</span><span class=\"params\">(q)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Process to read: %s'</span> % os.getpid())</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        value = q.get(<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    print(<span class=\"string\">'get %s from queue'</span> % value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'thread %s is running'</span> % threading.current_thread().name)</span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n&lt;<span class=\"number\">5</span>:</span><br><span class=\"line\">        n = n+<span class=\"number\">1</span></span><br><span class=\"line\">        print(<span class=\"string\">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name,n))</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'thread %s ended'</span> % threading.current_thread().name)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#进程，进程池</span></span><br><span class=\"line\">    print(cpu_count())</span><br><span class=\"line\">    print(<span class=\"string\">'Parent process %s'</span> % os.getpid())</span><br><span class=\"line\">    <span class=\"comment\"># p = Process(target=run_proc,args=('test',))</span></span><br><span class=\"line\">    p = Pool(<span class=\"number\">32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">33</span>):</span><br><span class=\"line\">        p.apply_async(long_time_task,args=(i,))</span><br><span class=\"line\">        <span class=\"comment\"># print('Child process start')</span></span><br><span class=\"line\">        <span class=\"comment\"># p.start()</span></span><br><span class=\"line\">        <span class=\"comment\"># p.join()</span></span><br><span class=\"line\">        <span class=\"comment\"># print('Child process end')</span></span><br><span class=\"line\">        print(<span class=\"string\">'waiting for all subprocess done'</span>)</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">        p.join()</span><br><span class=\"line\">        print(<span class=\"string\">'All subprocess done'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#进程执行</span></span><br><span class=\"line\">r = subprocess.call([<span class=\"string\">'nslookup'</span>,<span class=\"string\">'https://pamperxg.github.io'</span>])</span><br><span class=\"line\">print(<span class=\"string\">'Exit code:'</span>,r)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#进程间通信</span></span><br><span class=\"line\">q = Queue()</span><br><span class=\"line\">pw = Process(target=write,args=(q,))</span><br><span class=\"line\">pr = Process(target=read,args=(q,))</span><br><span class=\"line\">pw.start()</span><br><span class=\"line\">pr.start()</span><br><span class=\"line\">pw.join()</span><br><span class=\"line\">pr.terminate()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#线程</span></span><br><span class=\"line\">t = threading.Thread(target=loop,name=<span class=\"string\">'LoopThread'</span>)</span><br><span class=\"line\">t.start()</span><br><span class=\"line\">t.join()</span><br><span class=\"line\">print(<span class=\"string\">'thread %s ended'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>\n<p><strong>数据库连接</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ConnectDataBase</span><span class=\"params\">(self,db_name,user_name,password)</span>:</span></span><br><span class=\"line\">        conn = mdb.connect(host=<span class=\"string\">'88.88.88.88'</span>,port=<span class=\"number\">3306</span>,user=user_name,passwd=password,\\</span><br><span class=\"line\">                           db=db_name,charset=<span class=\"string\">'utf8'</span>)</span><br><span class=\"line\">        cursor = conn.cursor()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (conn,cursor)</span><br></pre></td></tr></table></figure>\n<p><strong>pandas操作</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#选取指定列进行操作</span></span><br><span class=\"line\">df.loc[(df.Cabin.notnull()),<span class=\"string\">'Cabin'</span>] = <span class=\"string\">'Yes'</span>  <span class=\"comment\">#选取指定列替换为yes</span></span><br><span class=\"line\">df.loc[df.Team.isin([<span class=\"string\">'England'</span>,<span class=\"string\">'Italy'</span>,<span class=\"string\">'Russia'</span>]),[<span class=\"string\">'Team'</span>,<span class=\"string\">'Shooting Accuracy'</span>]] <span class=\"comment\">#选取满足条件的列</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">df.groupby(<span class=\"string\">'a'</span>,as_index=<span class=\"keyword\">False</span>).sum()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#分组排序，算位置</span></span><br><span class=\"line\"><span class=\"comment\">#groupby时as_index=False和True的区别</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_level</span><span class=\"params\">(data,key,values,ascending=True)</span>:</span></span><br><span class=\"line\">    data_temp = data[key + [values]].copy()</span><br><span class=\"line\">    data_temp.sort_values(key + [values], inplace=<span class=\"keyword\">True</span>, ascending=ascending)</span><br><span class=\"line\">    data_temp[<span class=\"string\">'rank'</span>] = range(data_temp.shape[<span class=\"number\">0</span>])</span><br><span class=\"line\">    data_tmp[<span class=\"string\">'rank'</span>] = data_tmp[<span class=\"string\">'rank'</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">    min_rank = data_temp.groupby(key,as_index=<span class=\"keyword\">False</span>)[<span class=\"string\">'rank'</span>].agg(&#123;<span class=\"string\">'min_rank'</span>:<span class=\"string\">'min'</span>&#125;)</span><br><span class=\"line\">    index = data_temp.index</span><br><span class=\"line\">    data_temp = data_temp.merge(min_rank,on=key,how=<span class=\"string\">'left'</span>)</span><br><span class=\"line\">    data_temp[<span class=\"string\">'rank'</span>] = data_temp[<span class=\"string\">'rank'</span>] - data_temp[<span class=\"string\">'min_rank'</span>]</span><br><span class=\"line\">    max_rank = data_temp.groupby(key,as_index=<span class=\"keyword\">False</span>)[<span class=\"string\">'rank'</span>].agg(&#123;<span class=\"string\">'max_rank'</span>:<span class=\"string\">'max'</span>&#125;)</span><br><span class=\"line\">    data_temp = data_temp.merge(max_rank,on=key,how=<span class=\"string\">'left'</span>)</span><br><span class=\"line\">    data_temp.index = index</span><br><span class=\"line\">    data_temp[<span class=\"string\">'slevel'</span>] = round(data_temp[<span class=\"string\">'rank'</span>]/data_temp[<span class=\"string\">'max_rank'</span>],<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_temp[<span class=\"string\">'slevel'</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#shift、diff函数</span></span><br></pre></td></tr></table></figure>\n<p><strong>loc、iloc、ix</strong></p>\n<blockquote>\n<p>loc：在行标签上进行索引，包括start和end</p>\n<p>iloc：在行标签位置上进行索引，不包括end</p>\n<p>ix：在行标签上索引，索引不到就到位置上索引（如果index非全部整数）,不包括end</p>\n<blockquote>\n<p>.ix is deprecated. Please use<br>.loc for label based indexing or<br>.iloc for positional indexing</p>\n</blockquote>\n</blockquote>\n<p><strong>map、filter、reduce</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">squared = list(map(<span class=\"keyword\">lambda</span> x:x**<span class=\"number\">2</span>,items)) <span class=\"comment\">#map python3返回迭代器，python2返回列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">less_than_zero = filter(<span class=\"keyword\">lambda</span> x:x&lt;<span class=\"number\">0</span>,number_list) <span class=\"comment\">#同python3返回迭代器，python2返回列表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#对一个列表进行计算并且返回结果</span></span><br><span class=\"line\">product = reduce((<span class=\"keyword\">lambda</span> x,y:x*y),[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]) <span class=\"comment\">#24</span></span><br></pre></td></tr></table></figure>\n<p><strong>时间处理</strong>(python、pandas)：</p>\n<p>python标准库：datetime、time、calendar</p>\n<ul>\n<li>其中datetime模块中的标准数据类型有：date、time、datetime、timedeltad</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime,timedelta</span><br><span class=\"line\">datetime.now()</span><br><span class=\"line\"><span class=\"comment\">#2</span></span><br><span class=\"line\">[datetime.strptime(x,<span class=\"string\">'%Y-%m-%d'</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> date]</span><br><span class=\"line\"><span class=\"comment\">#3</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> dateutil.parser <span class=\"keyword\">import</span> parse</span><br><span class=\"line\">parse(<span class=\"string\">'2018-10-10'</span>)</span><br><span class=\"line\"><span class=\"comment\">#4</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\">pd.to_datetime(date)</span><br></pre></td></tr></table></figure>\n<p><strong>网络相关</strong>：</p>\n<p>应用层：为特定应用程序提供数据传输服务，http，dns</p>\n<p>运输层：进程间的通用数据传输服务，TCP、UDP</p>\n<p>网络层：主机间的数据传输服务</p>\n<p>数据链路层：为同一链路的主机提供服务</p>\n<p>物理层：怎样在传输媒体上传输数据比特流 </p>\n<p>表示层</p>\n<p>会话层 </p>\n<p>TCP/UDP：—  应用层：http，dns                  </p>\n<p>​            —   运输层：tcp，udp                  </p>\n<p>​                    —   网际层 ：IP                  </p>\n<pre><code>---   网络接口层： \n</code></pre><blockquote>\n<p>UDP是无连接的，支持一对一，一对多，多对一，多对多</p>\n<p>TCP是面向连接的，只能一对一</p>\n</blockquote>\n<p>序号，确认号，数据偏移，确认ACK，同步SYN，中止FIN，窗口 </p>\n<p><em>TCP三次握手，四次挥手：</em></p>\n<ul>\n<li><p>服务端处于listen状态，等待客户端的连接请求</p>\n</li>\n<li><p>客户端向服务端发送请求报文，SYN=1，ACK=0，初始序号x </p>\n</li>\n<li><p>服务端收到请求报文后，若同意连接，向客户端发送确认报文，SYN=1,ACK=1，确认号ack=x+1,初始序号y </p>\n</li>\n<li><p>客户端收到确认报文后，继续向服务端发出确认，确认号ack=y+1，序号为x+1 </p>\n</li>\n<li><p>服务端收到客户端确认后，连接建立</p>\n<blockquote>\n<p>防止失效连接请求到达服务器</p>\n<p>如果客户端发送的连接请求在网络中滞留，滞留时间超过客户端超时重传时间后，客户端会重新请求连接，延时的请求还是会到达服务端，如果不进行三次握手，服务器就会打开两个连接，有三次握手就会忽略滞留连接请求的连接确认，不进行三次握手，所以不会再次打开连接。 </p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>客户端发送连接释放报文，FIN=1 </p>\n</li>\n<li><p>服务端收到后发出确认，此时TCP处于<strong>半关闭状态</strong>，服务器端能向客户端发送数据，反之不行/ CLOSE_WAIT </p>\n</li>\n<li><p>服务端不再需要连接时，发送连接释放报文，FIN=1 </p>\n</li>\n<li><p>客户端收到后发出确认，进入<strong>TIME_WAIT</strong>状态，等待2MSL(最大报文存活时间)后释放连接 </p>\n</li>\n<li><p>服务端收到客户端确认后释放连接 </p>\n<blockquote>\n<p>CLOSE_WAIT:状态让服务端发送完数据</p>\n<p>TIME_WAIT:确保确认报文能到达服务端，若未到达，服务端会再次发送释放报文。。                   </p>\n<p>​             等待本连接产生的所有报文都从网络中消失，下一个新连接不会受到旧的请求报文 </p>\n<p>可靠传输：超时重传 </p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<p>Pycharm相同路径下的文件无法引用问题：</p>\n<blockquote>\n<p>在该路径下右击，Mark Directory as Source Root</p>\n</blockquote>"},{"title":"ML&DL基础概念","date":"2018-08-25T12:42:56.000Z","_content":"\n**统计学习**偏向于理论的优美完善，研究泛化误差界。**机器学习**是统计学习对实践技术的延伸，为实际问题提供算法支撑。**数据挖掘**偏重于大量数据的实践应用，注重实际问题的解决。\n\n<!--more-->\n\n### ML\n\n**WTF**：从给定的训练数据集合出发，**假设**数据是独立同分布产生的，**假设**要学习的模型是某个函数集合（假设空间），有某评价准则，从假设空间挑选最优模型。\n\n其中涉及的变换空间有：输入空间、特征空间、输出空间\n\n统计学习三个要素：**模型**、**策略**、**算法**\n\n目标：研究泛化误差界\n\n---\n\n##### 基本概念\n\n- 监督学习关于数据的基本假设：输入输出的随机变量遵循联合概率分布（$P(X,Y)$）。\n\n  分为概率模型和非概率模型，分别表示为条件概率分布（$P(Y|X)$）和决策函数（$Y=f(X)$）。\n\n- 损失函数和风险函数：一次预测的好坏和平均意义下模型预测结果的好坏\n\n- 风险函数：期望损失： 损失函数*联合概率分布的二重积分\n\n> 由于联合概率是未知的，根据大数定律，当样本容量趋于无穷时，经验风险趋于期望风险，所以可以由经验风险来求期望风险，但是由于样本的数量有限，效果往往达不到预期。\n\n- 监督学习的两个基本策略：经验风险最小化(empiracal risk minimization)和结构风险最小化(structural risk minimization)\n- ERM：样本容量足够大的时候能达到较好的效果，样本容量较小的时候容易产生过拟合，例：极大似然估计（模型是条件概率分布，损失函数是对数损失，经验风险最小化等价于极大似然估计）。\n- SRM：通过正则化系数来权衡经验风险和模型复杂度，模型越复杂时，正则项越大，例：最大后验估计（模型是条件概率分布，损失函数为对数损失函数，模型复杂度由先验概率表示，结构风险最小化等价于最大后验估计）。\n\n贝叶斯定理中任意一个量都可以从联合概率分布得到，要么通过积分的方式，要么通过关于某个合适的变量求条件概率。\n\n频率派和贝叶斯派区别和联系：\n\n- 频率观点：通过最优化某些准则（如似然函数）来确定参数的具体值。\n- 贝叶斯观点：给定观察数据，我们引入参数的先验分布，然后使用贝叶斯定理来计算对应的后验概率。\n\n共轭先验：使得后验概率分布的函数形式与先验概率相同，一般称先验分布与似然函数是共轭的。\n\n关于熵：\n\n> 我们一般使用**信息量**来进行**不确定性**的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。\n>\n> > 对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。\n>\n> **(信息)熵**定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。\n>\n> > 1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$\n> >\n> > 多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$\n> >\n> > > 随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0<H(X)<log(n)$)\n>\n> **条件熵**：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。\n>\n> > $H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$\n> >\n> > $H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$\n> >\n> > $H(Y|X)=H(X,Y)-H(X)$\n>\n> **相对熵**（KL散度）：两个概率分布之间的差异。\n>\n> > $D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)\n>\n> **交叉熵**：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。\n>\n> > $H(p,q)=-\\sum_xp(x)logq(x)$\n> >\n> > $H(p,q)=H(p)+D_{KL}(p||q)$\n>\n> 熵与方差的关系(在大部分分布的情况下正相关？)\n>\n> **信息增益**：熵-条件熵\n>\n> **互信息**：联合分布于乘积分布之间的相对熵，熵-条件熵\n>\n> > $I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$\n\n过拟合和欠拟合：\n\n> 欠拟合指的是模型不能在训练集上获得足够低的误差，过拟合指的是训练误差和测试误差的差距太大。\n>\n> 调整模型的**容量**，\n>\n> 当算法容量适合任务的复杂度和所提供数据的数量时，算法效果最佳。\n\nVC维：\n\n> 量化模型（二元分类器）容量，该分类器能够分类的训练样本的最大数目。训练误差和泛化误差之间差异的上界随着模型容量的增长而增长，但是随着训练样本增多而下降。\n\nNo Free Lunch theorem：\n\n> 在所有可能的数据生成分布上平均后，每一个分类算法在未事先观测的点上都有相同的错误率。没有一个机器学习算法总是比其他的要好。但是这个结论只在我们考虑所有的数据生成分布时才成立。真实应用中，如果我们对遇到的概率分布进行假设，则可以设计在这些分布上效果良好的学习算法。\n>\n> 机器学习是理解什么样的分布于人工智能获取经验的“真实世界”相关，以及什么样的学习算法在我们关注的数据生成分布上效果要好。\n\n正则项：\n\n> 修改学习算法，使其降低泛化误差而非训练误差\n\n- 当经验风险项较小时，表示模型较复杂，包含的参数越多，正则项就会越大。\n- 正则项的作用就是选择经验风险和模型复杂度同时较小的模型。奥卡姆剃刀法则（能很好地解释已知数据并且十分简单的才是最好的模型）。\n- 从贝叶斯的角度看，正则项相当于模型的先验概率，简单的模型有较大的先验概率，复杂的模型有较小的先验概率。\n- 可以看成是一种模型选择的手段，其他模型选择方法还有：交叉验证（重复使用数据）。\n\n在模型中增加更多的特征一般会增加训练样本的准确率，减小bias。但是测试样本的准确率不一定增加，除非增加的特征为有效特征。\n\n生成模型和判别模型\n\n- 生成方法由数据学习联合概率分布，然后求出条件概率分布作为预测模型。\n\n- 判别方法直接学习决策函数或条件概率分布。\n\n- 生成方法可以还原出联合概率分布，学习收敛速度快，样本容量的增加时可以更快收敛于真实模型，存在隐变量时可以使用而不能使用判别模型。\n\n- 判别模型直接面对预测，往往学习的准确率更高，可以对数据进行各种程度的抽象，定义特征，简化学习问题。\n\n判别数据集是否线性可分\n\n- 低维直接画图判断，高维检查凸包是否相交。\n\n模型选择\n\n- prml第一章中，多项式曲线拟合主要在于1、**函数空间**的选择（拟合三角函数为何用多项式函数），其中正则化方法对函数空间进行限制，使得函数空间变小。2、确定了多项式拟合后，**阶数**如何选择。\n- 一个模型中可能存在多个控制模型复杂度的参数。\n- 最大似然的方法容易过拟合，尤其是数据集小的时候（太小不服从大数定律？频率派的思想？）\n- 在数据量充足的情况下，一般选择在验证集上表现好的模型。但是在验证集很小的情况下对预测的表现估计会有一定的噪声。如果模型的设计使用有限规模的数据集迭代很多次，对于验证集会发生一定程度的过拟合。因此，保留一个第三方的测试集很有必要，最终使用该数据集来进行模型选择。\n- 在训练集和测试集有限的情况下，可以使用交叉验证（CV、Loocv）来充分利用数据。但是也有其缺点，交叉验证需要进行训练的次数随着折数的增加而增加，如果训练本身很耗时不太适用。对于一个模型有多个复杂度参数的情况，探索这些参数的组合所需的训练次数是参数个数的指数函数（$2^n$）。\n- 模型选择的理想情况：模型的选择依赖于训练数据，且允许在一轮训练中对比多个超参数和模型类型。\n- 信息准则：赤池信息准则（AIC【考虑模型的复杂度和模型的拟合度】）、贝叶斯信息准则（BIC）（倾向于选择过于简单的模型）。。\n\n泛函，指函数张成的空间。例Taylor公式，任意一个函数可以放到（$1,x,x^2,x^3...$）所张成的函数空间，如果是有限个基的话就称为欧式空间，无穷的话就是Hilbert空间。\n\n回归分析，p-value(假设检验的角度)？\n\n维度灾难\n\n（特征的数量有一个邻界点，过多带来过拟合）\n\n- 如果把空间的区域分割成一个一个的单元格，单元格的数量随着空间的维数以指数的形式增大。此时，为了保证这些单元格都不为空，需要指数级增长的训练数据（维度在指数级地爆炸增长）。\n\n  > 增加维度来获得最佳线性分类效果等价于在低维空间中使用非线性模型\n\n- 对于一个M阶多项式，系数数量的增长速度类似于D（维度）的M次方。$y(x,w)=w_0+\\sum_{i=1}^{D}w_ix_i+\\sum_{i=1}^{D}\\sum_{j=1}^{D}w_{ij}x_ix_j+\\sum_{i=1}^{D}\\sum_{j=1}^{D}\\sum_{k=1}^{D}w_{ijk}x_ix_jx_k$\n\n- D很大时，一个球体的大部分体积都聚集在表面附近的薄壳上（样本密度越来越小，数据的稀疏性变得愈发明显）。\n\n- 距离度量（欧式距离）失效，最近距离和最远距离变得不可辨别\n\n各种分布\n\n> 【随着数据量的增加，参数的后验分布等于最大似然解。在数据量足够的情况下,先验知识就显得不是那么重要了。】\n\n- 伯努利分布（二项分布的特例）\n\n  二元随机变量$x\\in\\{0,1\\}$，概率分布：$p(x=1|\\mu)=\\mu$，$Beru(x|\\mu)=\\mu^x(1-\\mu)^{(1-x)}$，$E[x]=\\mu,var[x]=\\mu(1-\\mu)$，对于一个观测数据集$D=\\{x_1,...,x_n\\}$，似然函数为：$P(D|\\mu)=\\prod_{i=1}^{N}p(x_n|\\mu)$\n\n- 二项式分布（泊松分布是二项式分布的极限形式，二项式分布也能推出正态分布）\n\n- beta分布（引入先验，二项分布的共轭分布。beta分布于二项式分布的似然函数有着相同的形式，当用beta分布作为二项式分布参数的先验分布，乘似然函数后得到的后验分布依然是beta分布）\n\n- 多项式分布-->狄利克雷分布（二项->抛硬币，多项->掷骰子）\n\n- 高斯分布\n\n- t分布（无限个均值一样，方差不同的高斯分布混合而成）\n\n- 混合高斯模型（隐变量：数据点属于哪个高斯分布，EM（隐变量，模型参数））\n\n- 指数族\n\n---\n\n##### Naive贝叶斯：\n\n- 贝叶斯定理+特征条件独立性假设。\n- 对于给定的数据集，基于特征条件独立假设学习输入输出的联合概率分布($P(X,Y)​$)，然后基于此模型，对于给定的输入$X​$，利用贝叶斯定理求出后验概率($P(Y|X)​$)。（联合概率分布 == 先验概率($P(Y)​$)*条件概率($P(X|Y)​$)（条件独立性假设））\n- 学习到生成数据的机制，即生成模型。\n- 分类的特征在类确定的条件下都是条件独立的。\n- 后验概率最大化 == 0-1损失时的期望风险最小化。\n\n---\n\n##### 决策树：\n\n*互斥且完备的if-then规则集合，定义在特征空间和类空间上的条件概率分布，模型可读性强，分类速度快。学习过程是由训练数据预估条件概率模型（从训练数据中归纳出一组分类规则）。*\n\n- 该算法主要包含三个步骤：特征选择、决策树的生成、剪枝\n- 内部结点表示一个特征或者属性，叶子节点表示一个类。\n- **损失函数**：正则化的极大似然函数，**策略**：以损失函数为目标的最小化。\n\n*从所有可能的决策树中选取最优决策树是NP完全问题，所以决策树的学习通常采用启发式算法，近似求解这一最优化问题，得到一个次最优的决策树。*\n\n- 过程：递归选择最优特征，根据该特征对训练数据进行分割，使得各个子数据集有一个最好的分类过程。\n\n  这种方法容易过拟合，所以要注意剪枝过程。\n\n- 如果特征的数量众多，在开始学习之前，可以对特征进行选择，留下对数据具有足够分类能力的特征。\n\n- 树的生成只考虑局部最优，剪枝考虑全局最优。\n\n**熵**：不确定性的大小。\n\n- 当各个微观状态出现概率相等时，熵达到最大值。\n\n  熵值依赖于X的分布，与其大小无关。\n\n- 条件熵：X给定的条件下，条件概率分布的熵对X的数学期望。（按某一个特征分类后的和）\n\n- 经验熵，经验条件熵：由数据估计得到的熵和条件熵。\n\n- 信息增益：经验熵与给定特征条件下经验条件熵之差。\n\n*熵与条件熵之差称为互信息，决策树中的信息增益等价于训练集中类与特征的互信息。*\n\n**特征选择**：\n\n信息增益（ID3），信息增益比（C4.5）（信息增益存在偏向于选择取值较多的特征的问题，信息增益比可以对这个问题进行校正）。\n\n**树的生成**：\n\n启发式算法，每一步最优分割。\n\n**剪枝**：通过极小化整体的损失函数或者代价函数实现，正则项限制复杂度。\n\n分为预剪枝（一边建立一边剪枝，控制树深度、叶子节点样本数、叶子节点个数、信息增益量）和后剪枝（优化损失函数）\n\n决策树的生成只考虑了信息增益（比）对训练集更好地拟合，而剪枝考虑减小模型的复杂度，利用损失函数最小化原则进行剪枝就是用正则化的极大似然估计进行模型选择。\n\n计算每个节点的经验熵，递归地从叶子节点往上回缩，直到选得损失函数最小的子树。\n\n**CART**：（二叉树）\n\n在给定输入随机变量X条件下输出随机变量Y的条件概率分布的学习方法。\n\n**生成树**：\n\n递归构建二叉树，对回归树用**平方误差最小化**准则，分类树用**基尼指数最小化**准则进行特征选择，生成二叉树。\n\n**剪枝**：\n\n从生成算法的决策树底端开始不断剪枝，直到根节点，形成一个子树序列，然后通过交叉验证在独立的验证数据集上对子树序列进行测试，选取最优子树。\n\n---\n\n> 涉及到**距离度量**时，缺失的数据就会比较重要。\n\n**随机森林和XGBoost缺失值处理**：\n\n- 随机森林：1、数值型变量用所有对应类别中的中位数替换，类别型变量用出现最多的值（众数）替换\n\n  ​\t\t   2、加权，相似的点拥有更高的权重\t\t  \n\n- XGBoost：训练时缺失数据会被分到左子树或者右子树计算损失，选择较优的那个。如果训练时没有缺失而预测时出现缺失，则默认被分到右子树。\n\n---\n\n**PCA**：\n\n> 求解协方差矩阵的topK大的特征向量\n\n1、数据在低维线性空间（主子空间）上的正交投影，使得投影数据的方差最大化\n\n2、使得投影代价（数据点和它们的投影间的平方距离）最小的线性投影\n\n标准化有什么好处？\n\n> 防止过分捕捉某些数值大的特征，让每个维度的重要性一样。\n>\n> 有利于梯度下降法的收敛。\n\n---\n\n**Kmeans**:\n\n> k均值算法对应于用于高斯混合模型的EM算法的一个特定的非概率极限\n>\n> k-means算法是高斯混合聚类在混合成分方差相等，且每个样本仅指派一个混合成分时候的特例。 \n\n数据集$\\{x_n\\}$，聚类中心$\\{\\mu_k\\}$，定义一个目标函数：\n$$\nJ=\\sum_{n=1}^{N}\\sum_{k=1}^{K}r_{nk}||x_n-\\mu_k||^2\n$$\n如果数据点$x_n$被分配到类别$k$，则$r_{nk}=1$\n\n目标是寻找$r_{nk}$和$\\mu_k$的值，使得$J$最小化，可以使用一种迭代的方法完成这件事，每次迭代涉及两个连续步骤，分别为$r_{nk}$的最优化和$\\mu_k$的最优化。\n\n- 选择$\\mu_k$的初始值\n\n- 关于$r_{nk}$优化$J$，保持$\\mu_k$固定（E）\n\n  $r_{nk}= \\begin{cases}1&\\mbox{if $k=arg\\ min_j ||x_n-\\mu_j||^2$}, \\\\0 & \\text{else}.\\end{cases}$\n\n- 关于$\\mu_k$优化$J$，保持$r_{nk}$固定（M）\n\n  $\\partial J/\\partial \\mu_k = 2\\sum_{n=1}^{N}r_{nk}(x_n-\\mu_k)=0$\n\n  $\\Rightarrow \\mu_k=\\frac{\\sum_nr_{nk}x_n}{\\sum_nr_{nk}}$\n\n- 不断重复这两个阶段直至收敛\n\n**高斯混合模型**：\n\n![GMM](GMM.png)\n\n---\n\n**线性模型**：\n\nGLM建模过程：先明确y(条件概率？)服从什么分布，找到一个合适的链接函数，将参数$\\theta$映射成整条实直线，规定$f(\\theta) = a + bx$ 。[推导](https://mp.weixin.qq.com/s?__biz=MzU1NTUxNTM0Mg==&mid=2247487577&amp;idx=3&amp;sn=eaa836d0bf6aeb4e454a73f42f70340b&source=41#wechat_redirect)\n\n回归的线性模型和分类的线性模型：基于**固定**非线性基函数的线性组合。$y(x,w)=f(\\sum_{j=1}^{M}w_j\\phi_j(x))$,$f(.)$在分类问题中是一个非线性激活函数，在回归问题中为恒等函数。\n\n线性回归的模型可以表达非线性的东西，因为基函数是非线性的（这里基函数是固定的，NN、SVM是变化基）。\n\n多项式基函数的局限：它们是输入变量的全局函数，对于输入空间一个区域的改变将会影响所有的其他区域。\n\n对$x$做非线性变化，再对这些基函数线性组合，会使得计算量变得庞大，可以使用kernel trick，直接由核函数来计算内积，来解决非线性关系。\n\n固定基函数的线性组合构成的回归模型和分类模型，它们的实际应用被**维数灾难**问题限制了。为了将这些模型应用于大规模问题，有必要根据数据调节基函数。（SVM、神经网络）\n\n如何避免维度灾难问题？\n\nkernel function 满足交换律（内积满足交换律），满足Mercer定理（核矩阵是半正定的）。\n\n> 有一些模式识别方法，对于新输入的预测纯粹依靠学习到的参数向量$w$，也有一类方法，训练数据点或者它的一个子集在预测阶段任然保留并且被使用。如最近邻方法（memory-based，训练速度快，预测速度慢）、核函数方法（每一个核函数都以训练数据为中心）。\n\n核方法：\n\n许多线性参数模型可以被转化为一个等价的“对偶表示”，预测的基础也是在训练数据点处计算的核函数的线性组合。对于基于固定非线性特征空间映射$\\phi(x)$的模型来说，核函数关系如下：\n$$\nk(x,x^\\prime) = \\phi(x)^T\\phi(x^\\prime)\n$$\n对偶表示：完全通过核函数表示，可以直接针对核函数进行计算，**避免了显式地引入特征向量**$\\phi(x)$，这使得我们可以隐式地使用高维特征空间，甚至无限维特征空间。\n\n构造核：核函数对应于某个特征空间的标量积，合法核函数的充分必要条件：Gram矩阵在所有的集合$\\{x_n\\}$的选择下都是半正定的。\n\n多项式核\n\n高斯核？无穷维？\n\nsigmoid核（Gram矩阵是非半正定的也可以使用）\n\n很多基于核的学习算法最大的局限是核函数必须对所有的可能点求值，这在训练阶段的计算上是不可行的。\n\n$\\Longrightarrow\\Downarrow$\n\nSVM(分类，回归，异常检测)\n\n线性可分：存在$w,b$,有$t_ny_n > 0$\n\nmargin：决策边界与任意样本之间的最小距离，这个决策边界的位置由数据点的一个子集确定，这些数据点称为支持向量\n\nsoft margin：引入松弛变量，允许一些训练数据点被错分\n\n核函数对应于特征空间的内积，特征空间可以是高维甚至是无穷维的，通过直接对核函数操作而不显式引入特征空间，可以有效地避免维度灾难的问题。（然而。。）\n\n对新输入的预测只通过支持向量来完成，但是训练阶段使用了整个数据集，所以一个解决二次规划的高效算法很重要。\n\nSMO：\n\n多分类SVM：\n\nSVR：\n\n---\n\n### DL\n\n##### 基本概念：\n\n**神经网络**\n\n通用近似原理：一个带有线性输出的两层网络可以在任意精度下近似任何输入变量较少的连续函数，只要隐含单元的数量足够多。\n\n前馈神经网络（MLP）：使用参数形式的基函数，这些参数可以在训练阶段调节。\n\n三层网络函数：$i(D维),j(M维)[a=w^Tx,z=h(a)],k(K维)[a = w^Tz,\\sigma(a)]$\n$$\ny_k(x,w) = \\sigma(\\sum_{j=0}^{M}w_{kj}^{(2)}h(\\sum_{i=0}^{D}w_{ji}^{(1)}x_i)\n$$\n误差方向传播：提供了计算导数的一个高效方法  \n$$\n\\delta_j = h^\\prime(a_j)\\sum_k(\\delta_kw_{kj})\n$$\n![BP](BP.jpg)\n\n卷积网络：\n\n将不变性的性质融入到神经网络结构中，以构造对输入变量的变换具有不变性的模型，并能提取多个局部特征（读个feature map）\n\n特点：1、卷积（不变性，检测不同位置的相同模式） 2、权值共享（feature map） 3、下采样（微小平移不敏感）\n\n**梯度下降法的步骤**：\n\n（梯度下降法、批量最优化方法[共轭梯度法、拟牛顿法]、随机梯度下降（高效地处理数据中的冗余性，可以逃离局部最小值点））\n\n1、随机初始化权重和偏差\n\n2、把输入传入网络得到输出值\n\n3、计算预测值与真实值之间的误差\n\n4、对每一个产生误差的神经元，调整相应的权重值以减小误差\n\n5、重复迭代，直至网络权重达到最佳值\n\n**跳出局部最小值的策略**：\n\n1、尝试不同的参数初始化策略，再选择\n\n2、模拟退火\n\n> 每一步都以一定的概率接受比当前差的结果，有助于跳出局部极值，接受“次优解”的概率随着时间的推移不断降低\n\n3、使用随机梯度下降\n\n4、动量\n\n**各种梯度下降**：\n\n**梯度消失爆炸**：\n\n> 原因：1、网络过深。2、激活函数选择不合适（如sigmoid的导数不会超过0.25）\n\n解决办法：\n\n1、预训练+微调\n\n2、梯度剪切、权重正则（针对爆炸）[出现的更多的是梯度消失]\n\n3、更换激活函数\n\n4、batchnorm（消除放大缩小影响，把梯度拉回非饱和区）\n\n5、使用残差结构（shortcut）\n\n6、使用LSTM（gates）\n\n**各类激活函数比较**：\n\nrelu：\n\n> 缓解梯度消失爆炸、计算方便、加速网络训练\n\nleakrelu:\n\nelu:\n\n**BN**：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/ML&DL基础概念.md","raw":"---\ntitle: ML&DL基础概念\ndate: 2018-08-25 20:42:56\ntags: [notes,DataScience,MachineLearning,DeepLearning]\n---\n\n**统计学习**偏向于理论的优美完善，研究泛化误差界。**机器学习**是统计学习对实践技术的延伸，为实际问题提供算法支撑。**数据挖掘**偏重于大量数据的实践应用，注重实际问题的解决。\n\n<!--more-->\n\n### ML\n\n**WTF**：从给定的训练数据集合出发，**假设**数据是独立同分布产生的，**假设**要学习的模型是某个函数集合（假设空间），有某评价准则，从假设空间挑选最优模型。\n\n其中涉及的变换空间有：输入空间、特征空间、输出空间\n\n统计学习三个要素：**模型**、**策略**、**算法**\n\n目标：研究泛化误差界\n\n---\n\n##### 基本概念\n\n- 监督学习关于数据的基本假设：输入输出的随机变量遵循联合概率分布（$P(X,Y)$）。\n\n  分为概率模型和非概率模型，分别表示为条件概率分布（$P(Y|X)$）和决策函数（$Y=f(X)$）。\n\n- 损失函数和风险函数：一次预测的好坏和平均意义下模型预测结果的好坏\n\n- 风险函数：期望损失： 损失函数*联合概率分布的二重积分\n\n> 由于联合概率是未知的，根据大数定律，当样本容量趋于无穷时，经验风险趋于期望风险，所以可以由经验风险来求期望风险，但是由于样本的数量有限，效果往往达不到预期。\n\n- 监督学习的两个基本策略：经验风险最小化(empiracal risk minimization)和结构风险最小化(structural risk minimization)\n- ERM：样本容量足够大的时候能达到较好的效果，样本容量较小的时候容易产生过拟合，例：极大似然估计（模型是条件概率分布，损失函数是对数损失，经验风险最小化等价于极大似然估计）。\n- SRM：通过正则化系数来权衡经验风险和模型复杂度，模型越复杂时，正则项越大，例：最大后验估计（模型是条件概率分布，损失函数为对数损失函数，模型复杂度由先验概率表示，结构风险最小化等价于最大后验估计）。\n\n贝叶斯定理中任意一个量都可以从联合概率分布得到，要么通过积分的方式，要么通过关于某个合适的变量求条件概率。\n\n频率派和贝叶斯派区别和联系：\n\n- 频率观点：通过最优化某些准则（如似然函数）来确定参数的具体值。\n- 贝叶斯观点：给定观察数据，我们引入参数的先验分布，然后使用贝叶斯定理来计算对应的后验概率。\n\n共轭先验：使得后验概率分布的函数形式与先验概率相同，一般称先验分布与似然函数是共轭的。\n\n关于熵：\n\n> 我们一般使用**信息量**来进行**不确定性**的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。\n>\n> > 对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。\n>\n> **(信息)熵**定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。\n>\n> > 1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$\n> >\n> > 多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$\n> >\n> > > 随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0<H(X)<log(n)$)\n>\n> **条件熵**：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。\n>\n> > $H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$\n> >\n> > $H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$\n> >\n> > $H(Y|X)=H(X,Y)-H(X)$\n>\n> **相对熵**（KL散度）：两个概率分布之间的差异。\n>\n> > $D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)\n>\n> **交叉熵**：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。\n>\n> > $H(p,q)=-\\sum_xp(x)logq(x)$\n> >\n> > $H(p,q)=H(p)+D_{KL}(p||q)$\n>\n> 熵与方差的关系(在大部分分布的情况下正相关？)\n>\n> **信息增益**：熵-条件熵\n>\n> **互信息**：联合分布于乘积分布之间的相对熵，熵-条件熵\n>\n> > $I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$\n\n过拟合和欠拟合：\n\n> 欠拟合指的是模型不能在训练集上获得足够低的误差，过拟合指的是训练误差和测试误差的差距太大。\n>\n> 调整模型的**容量**，\n>\n> 当算法容量适合任务的复杂度和所提供数据的数量时，算法效果最佳。\n\nVC维：\n\n> 量化模型（二元分类器）容量，该分类器能够分类的训练样本的最大数目。训练误差和泛化误差之间差异的上界随着模型容量的增长而增长，但是随着训练样本增多而下降。\n\nNo Free Lunch theorem：\n\n> 在所有可能的数据生成分布上平均后，每一个分类算法在未事先观测的点上都有相同的错误率。没有一个机器学习算法总是比其他的要好。但是这个结论只在我们考虑所有的数据生成分布时才成立。真实应用中，如果我们对遇到的概率分布进行假设，则可以设计在这些分布上效果良好的学习算法。\n>\n> 机器学习是理解什么样的分布于人工智能获取经验的“真实世界”相关，以及什么样的学习算法在我们关注的数据生成分布上效果要好。\n\n正则项：\n\n> 修改学习算法，使其降低泛化误差而非训练误差\n\n- 当经验风险项较小时，表示模型较复杂，包含的参数越多，正则项就会越大。\n- 正则项的作用就是选择经验风险和模型复杂度同时较小的模型。奥卡姆剃刀法则（能很好地解释已知数据并且十分简单的才是最好的模型）。\n- 从贝叶斯的角度看，正则项相当于模型的先验概率，简单的模型有较大的先验概率，复杂的模型有较小的先验概率。\n- 可以看成是一种模型选择的手段，其他模型选择方法还有：交叉验证（重复使用数据）。\n\n在模型中增加更多的特征一般会增加训练样本的准确率，减小bias。但是测试样本的准确率不一定增加，除非增加的特征为有效特征。\n\n生成模型和判别模型\n\n- 生成方法由数据学习联合概率分布，然后求出条件概率分布作为预测模型。\n\n- 判别方法直接学习决策函数或条件概率分布。\n\n- 生成方法可以还原出联合概率分布，学习收敛速度快，样本容量的增加时可以更快收敛于真实模型，存在隐变量时可以使用而不能使用判别模型。\n\n- 判别模型直接面对预测，往往学习的准确率更高，可以对数据进行各种程度的抽象，定义特征，简化学习问题。\n\n判别数据集是否线性可分\n\n- 低维直接画图判断，高维检查凸包是否相交。\n\n模型选择\n\n- prml第一章中，多项式曲线拟合主要在于1、**函数空间**的选择（拟合三角函数为何用多项式函数），其中正则化方法对函数空间进行限制，使得函数空间变小。2、确定了多项式拟合后，**阶数**如何选择。\n- 一个模型中可能存在多个控制模型复杂度的参数。\n- 最大似然的方法容易过拟合，尤其是数据集小的时候（太小不服从大数定律？频率派的思想？）\n- 在数据量充足的情况下，一般选择在验证集上表现好的模型。但是在验证集很小的情况下对预测的表现估计会有一定的噪声。如果模型的设计使用有限规模的数据集迭代很多次，对于验证集会发生一定程度的过拟合。因此，保留一个第三方的测试集很有必要，最终使用该数据集来进行模型选择。\n- 在训练集和测试集有限的情况下，可以使用交叉验证（CV、Loocv）来充分利用数据。但是也有其缺点，交叉验证需要进行训练的次数随着折数的增加而增加，如果训练本身很耗时不太适用。对于一个模型有多个复杂度参数的情况，探索这些参数的组合所需的训练次数是参数个数的指数函数（$2^n$）。\n- 模型选择的理想情况：模型的选择依赖于训练数据，且允许在一轮训练中对比多个超参数和模型类型。\n- 信息准则：赤池信息准则（AIC【考虑模型的复杂度和模型的拟合度】）、贝叶斯信息准则（BIC）（倾向于选择过于简单的模型）。。\n\n泛函，指函数张成的空间。例Taylor公式，任意一个函数可以放到（$1,x,x^2,x^3...$）所张成的函数空间，如果是有限个基的话就称为欧式空间，无穷的话就是Hilbert空间。\n\n回归分析，p-value(假设检验的角度)？\n\n维度灾难\n\n（特征的数量有一个邻界点，过多带来过拟合）\n\n- 如果把空间的区域分割成一个一个的单元格，单元格的数量随着空间的维数以指数的形式增大。此时，为了保证这些单元格都不为空，需要指数级增长的训练数据（维度在指数级地爆炸增长）。\n\n  > 增加维度来获得最佳线性分类效果等价于在低维空间中使用非线性模型\n\n- 对于一个M阶多项式，系数数量的增长速度类似于D（维度）的M次方。$y(x,w)=w_0+\\sum_{i=1}^{D}w_ix_i+\\sum_{i=1}^{D}\\sum_{j=1}^{D}w_{ij}x_ix_j+\\sum_{i=1}^{D}\\sum_{j=1}^{D}\\sum_{k=1}^{D}w_{ijk}x_ix_jx_k$\n\n- D很大时，一个球体的大部分体积都聚集在表面附近的薄壳上（样本密度越来越小，数据的稀疏性变得愈发明显）。\n\n- 距离度量（欧式距离）失效，最近距离和最远距离变得不可辨别\n\n各种分布\n\n> 【随着数据量的增加，参数的后验分布等于最大似然解。在数据量足够的情况下,先验知识就显得不是那么重要了。】\n\n- 伯努利分布（二项分布的特例）\n\n  二元随机变量$x\\in\\{0,1\\}$，概率分布：$p(x=1|\\mu)=\\mu$，$Beru(x|\\mu)=\\mu^x(1-\\mu)^{(1-x)}$，$E[x]=\\mu,var[x]=\\mu(1-\\mu)$，对于一个观测数据集$D=\\{x_1,...,x_n\\}$，似然函数为：$P(D|\\mu)=\\prod_{i=1}^{N}p(x_n|\\mu)$\n\n- 二项式分布（泊松分布是二项式分布的极限形式，二项式分布也能推出正态分布）\n\n- beta分布（引入先验，二项分布的共轭分布。beta分布于二项式分布的似然函数有着相同的形式，当用beta分布作为二项式分布参数的先验分布，乘似然函数后得到的后验分布依然是beta分布）\n\n- 多项式分布-->狄利克雷分布（二项->抛硬币，多项->掷骰子）\n\n- 高斯分布\n\n- t分布（无限个均值一样，方差不同的高斯分布混合而成）\n\n- 混合高斯模型（隐变量：数据点属于哪个高斯分布，EM（隐变量，模型参数））\n\n- 指数族\n\n---\n\n##### Naive贝叶斯：\n\n- 贝叶斯定理+特征条件独立性假设。\n- 对于给定的数据集，基于特征条件独立假设学习输入输出的联合概率分布($P(X,Y)​$)，然后基于此模型，对于给定的输入$X​$，利用贝叶斯定理求出后验概率($P(Y|X)​$)。（联合概率分布 == 先验概率($P(Y)​$)*条件概率($P(X|Y)​$)（条件独立性假设））\n- 学习到生成数据的机制，即生成模型。\n- 分类的特征在类确定的条件下都是条件独立的。\n- 后验概率最大化 == 0-1损失时的期望风险最小化。\n\n---\n\n##### 决策树：\n\n*互斥且完备的if-then规则集合，定义在特征空间和类空间上的条件概率分布，模型可读性强，分类速度快。学习过程是由训练数据预估条件概率模型（从训练数据中归纳出一组分类规则）。*\n\n- 该算法主要包含三个步骤：特征选择、决策树的生成、剪枝\n- 内部结点表示一个特征或者属性，叶子节点表示一个类。\n- **损失函数**：正则化的极大似然函数，**策略**：以损失函数为目标的最小化。\n\n*从所有可能的决策树中选取最优决策树是NP完全问题，所以决策树的学习通常采用启发式算法，近似求解这一最优化问题，得到一个次最优的决策树。*\n\n- 过程：递归选择最优特征，根据该特征对训练数据进行分割，使得各个子数据集有一个最好的分类过程。\n\n  这种方法容易过拟合，所以要注意剪枝过程。\n\n- 如果特征的数量众多，在开始学习之前，可以对特征进行选择，留下对数据具有足够分类能力的特征。\n\n- 树的生成只考虑局部最优，剪枝考虑全局最优。\n\n**熵**：不确定性的大小。\n\n- 当各个微观状态出现概率相等时，熵达到最大值。\n\n  熵值依赖于X的分布，与其大小无关。\n\n- 条件熵：X给定的条件下，条件概率分布的熵对X的数学期望。（按某一个特征分类后的和）\n\n- 经验熵，经验条件熵：由数据估计得到的熵和条件熵。\n\n- 信息增益：经验熵与给定特征条件下经验条件熵之差。\n\n*熵与条件熵之差称为互信息，决策树中的信息增益等价于训练集中类与特征的互信息。*\n\n**特征选择**：\n\n信息增益（ID3），信息增益比（C4.5）（信息增益存在偏向于选择取值较多的特征的问题，信息增益比可以对这个问题进行校正）。\n\n**树的生成**：\n\n启发式算法，每一步最优分割。\n\n**剪枝**：通过极小化整体的损失函数或者代价函数实现，正则项限制复杂度。\n\n分为预剪枝（一边建立一边剪枝，控制树深度、叶子节点样本数、叶子节点个数、信息增益量）和后剪枝（优化损失函数）\n\n决策树的生成只考虑了信息增益（比）对训练集更好地拟合，而剪枝考虑减小模型的复杂度，利用损失函数最小化原则进行剪枝就是用正则化的极大似然估计进行模型选择。\n\n计算每个节点的经验熵，递归地从叶子节点往上回缩，直到选得损失函数最小的子树。\n\n**CART**：（二叉树）\n\n在给定输入随机变量X条件下输出随机变量Y的条件概率分布的学习方法。\n\n**生成树**：\n\n递归构建二叉树，对回归树用**平方误差最小化**准则，分类树用**基尼指数最小化**准则进行特征选择，生成二叉树。\n\n**剪枝**：\n\n从生成算法的决策树底端开始不断剪枝，直到根节点，形成一个子树序列，然后通过交叉验证在独立的验证数据集上对子树序列进行测试，选取最优子树。\n\n---\n\n> 涉及到**距离度量**时，缺失的数据就会比较重要。\n\n**随机森林和XGBoost缺失值处理**：\n\n- 随机森林：1、数值型变量用所有对应类别中的中位数替换，类别型变量用出现最多的值（众数）替换\n\n  ​\t\t   2、加权，相似的点拥有更高的权重\t\t  \n\n- XGBoost：训练时缺失数据会被分到左子树或者右子树计算损失，选择较优的那个。如果训练时没有缺失而预测时出现缺失，则默认被分到右子树。\n\n---\n\n**PCA**：\n\n> 求解协方差矩阵的topK大的特征向量\n\n1、数据在低维线性空间（主子空间）上的正交投影，使得投影数据的方差最大化\n\n2、使得投影代价（数据点和它们的投影间的平方距离）最小的线性投影\n\n标准化有什么好处？\n\n> 防止过分捕捉某些数值大的特征，让每个维度的重要性一样。\n>\n> 有利于梯度下降法的收敛。\n\n---\n\n**Kmeans**:\n\n> k均值算法对应于用于高斯混合模型的EM算法的一个特定的非概率极限\n>\n> k-means算法是高斯混合聚类在混合成分方差相等，且每个样本仅指派一个混合成分时候的特例。 \n\n数据集$\\{x_n\\}$，聚类中心$\\{\\mu_k\\}$，定义一个目标函数：\n$$\nJ=\\sum_{n=1}^{N}\\sum_{k=1}^{K}r_{nk}||x_n-\\mu_k||^2\n$$\n如果数据点$x_n$被分配到类别$k$，则$r_{nk}=1$\n\n目标是寻找$r_{nk}$和$\\mu_k$的值，使得$J$最小化，可以使用一种迭代的方法完成这件事，每次迭代涉及两个连续步骤，分别为$r_{nk}$的最优化和$\\mu_k$的最优化。\n\n- 选择$\\mu_k$的初始值\n\n- 关于$r_{nk}$优化$J$，保持$\\mu_k$固定（E）\n\n  $r_{nk}= \\begin{cases}1&\\mbox{if $k=arg\\ min_j ||x_n-\\mu_j||^2$}, \\\\0 & \\text{else}.\\end{cases}$\n\n- 关于$\\mu_k$优化$J$，保持$r_{nk}$固定（M）\n\n  $\\partial J/\\partial \\mu_k = 2\\sum_{n=1}^{N}r_{nk}(x_n-\\mu_k)=0$\n\n  $\\Rightarrow \\mu_k=\\frac{\\sum_nr_{nk}x_n}{\\sum_nr_{nk}}$\n\n- 不断重复这两个阶段直至收敛\n\n**高斯混合模型**：\n\n![GMM](GMM.png)\n\n---\n\n**线性模型**：\n\nGLM建模过程：先明确y(条件概率？)服从什么分布，找到一个合适的链接函数，将参数$\\theta$映射成整条实直线，规定$f(\\theta) = a + bx$ 。[推导](https://mp.weixin.qq.com/s?__biz=MzU1NTUxNTM0Mg==&mid=2247487577&amp;idx=3&amp;sn=eaa836d0bf6aeb4e454a73f42f70340b&source=41#wechat_redirect)\n\n回归的线性模型和分类的线性模型：基于**固定**非线性基函数的线性组合。$y(x,w)=f(\\sum_{j=1}^{M}w_j\\phi_j(x))$,$f(.)$在分类问题中是一个非线性激活函数，在回归问题中为恒等函数。\n\n线性回归的模型可以表达非线性的东西，因为基函数是非线性的（这里基函数是固定的，NN、SVM是变化基）。\n\n多项式基函数的局限：它们是输入变量的全局函数，对于输入空间一个区域的改变将会影响所有的其他区域。\n\n对$x$做非线性变化，再对这些基函数线性组合，会使得计算量变得庞大，可以使用kernel trick，直接由核函数来计算内积，来解决非线性关系。\n\n固定基函数的线性组合构成的回归模型和分类模型，它们的实际应用被**维数灾难**问题限制了。为了将这些模型应用于大规模问题，有必要根据数据调节基函数。（SVM、神经网络）\n\n如何避免维度灾难问题？\n\nkernel function 满足交换律（内积满足交换律），满足Mercer定理（核矩阵是半正定的）。\n\n> 有一些模式识别方法，对于新输入的预测纯粹依靠学习到的参数向量$w$，也有一类方法，训练数据点或者它的一个子集在预测阶段任然保留并且被使用。如最近邻方法（memory-based，训练速度快，预测速度慢）、核函数方法（每一个核函数都以训练数据为中心）。\n\n核方法：\n\n许多线性参数模型可以被转化为一个等价的“对偶表示”，预测的基础也是在训练数据点处计算的核函数的线性组合。对于基于固定非线性特征空间映射$\\phi(x)$的模型来说，核函数关系如下：\n$$\nk(x,x^\\prime) = \\phi(x)^T\\phi(x^\\prime)\n$$\n对偶表示：完全通过核函数表示，可以直接针对核函数进行计算，**避免了显式地引入特征向量**$\\phi(x)$，这使得我们可以隐式地使用高维特征空间，甚至无限维特征空间。\n\n构造核：核函数对应于某个特征空间的标量积，合法核函数的充分必要条件：Gram矩阵在所有的集合$\\{x_n\\}$的选择下都是半正定的。\n\n多项式核\n\n高斯核？无穷维？\n\nsigmoid核（Gram矩阵是非半正定的也可以使用）\n\n很多基于核的学习算法最大的局限是核函数必须对所有的可能点求值，这在训练阶段的计算上是不可行的。\n\n$\\Longrightarrow\\Downarrow$\n\nSVM(分类，回归，异常检测)\n\n线性可分：存在$w,b$,有$t_ny_n > 0$\n\nmargin：决策边界与任意样本之间的最小距离，这个决策边界的位置由数据点的一个子集确定，这些数据点称为支持向量\n\nsoft margin：引入松弛变量，允许一些训练数据点被错分\n\n核函数对应于特征空间的内积，特征空间可以是高维甚至是无穷维的，通过直接对核函数操作而不显式引入特征空间，可以有效地避免维度灾难的问题。（然而。。）\n\n对新输入的预测只通过支持向量来完成，但是训练阶段使用了整个数据集，所以一个解决二次规划的高效算法很重要。\n\nSMO：\n\n多分类SVM：\n\nSVR：\n\n---\n\n### DL\n\n##### 基本概念：\n\n**神经网络**\n\n通用近似原理：一个带有线性输出的两层网络可以在任意精度下近似任何输入变量较少的连续函数，只要隐含单元的数量足够多。\n\n前馈神经网络（MLP）：使用参数形式的基函数，这些参数可以在训练阶段调节。\n\n三层网络函数：$i(D维),j(M维)[a=w^Tx,z=h(a)],k(K维)[a = w^Tz,\\sigma(a)]$\n$$\ny_k(x,w) = \\sigma(\\sum_{j=0}^{M}w_{kj}^{(2)}h(\\sum_{i=0}^{D}w_{ji}^{(1)}x_i)\n$$\n误差方向传播：提供了计算导数的一个高效方法  \n$$\n\\delta_j = h^\\prime(a_j)\\sum_k(\\delta_kw_{kj})\n$$\n![BP](BP.jpg)\n\n卷积网络：\n\n将不变性的性质融入到神经网络结构中，以构造对输入变量的变换具有不变性的模型，并能提取多个局部特征（读个feature map）\n\n特点：1、卷积（不变性，检测不同位置的相同模式） 2、权值共享（feature map） 3、下采样（微小平移不敏感）\n\n**梯度下降法的步骤**：\n\n（梯度下降法、批量最优化方法[共轭梯度法、拟牛顿法]、随机梯度下降（高效地处理数据中的冗余性，可以逃离局部最小值点））\n\n1、随机初始化权重和偏差\n\n2、把输入传入网络得到输出值\n\n3、计算预测值与真实值之间的误差\n\n4、对每一个产生误差的神经元，调整相应的权重值以减小误差\n\n5、重复迭代，直至网络权重达到最佳值\n\n**跳出局部最小值的策略**：\n\n1、尝试不同的参数初始化策略，再选择\n\n2、模拟退火\n\n> 每一步都以一定的概率接受比当前差的结果，有助于跳出局部极值，接受“次优解”的概率随着时间的推移不断降低\n\n3、使用随机梯度下降\n\n4、动量\n\n**各种梯度下降**：\n\n**梯度消失爆炸**：\n\n> 原因：1、网络过深。2、激活函数选择不合适（如sigmoid的导数不会超过0.25）\n\n解决办法：\n\n1、预训练+微调\n\n2、梯度剪切、权重正则（针对爆炸）[出现的更多的是梯度消失]\n\n3、更换激活函数\n\n4、batchnorm（消除放大缩小影响，把梯度拉回非饱和区）\n\n5、使用残差结构（shortcut）\n\n6、使用LSTM（gates）\n\n**各类激活函数比较**：\n\nrelu：\n\n> 缓解梯度消失爆炸、计算方便、加速网络训练\n\nleakrelu:\n\nelu:\n\n**BN**：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ML&DL基础概念","published":1,"updated":"2018-10-07T17:07:43.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2rx0014qsez0eavj9py","content":"<p><strong>统计学习</strong>偏向于理论的优美完善，研究泛化误差界。<strong>机器学习</strong>是统计学习对实践技术的延伸，为实际问题提供算法支撑。<strong>数据挖掘</strong>偏重于大量数据的实践应用，注重实际问题的解决。</p>\n<a id=\"more\"></a>\n<h3 id=\"ML\"><a href=\"#ML\" class=\"headerlink\" title=\"ML\"></a>ML</h3><p><strong>WTF</strong>：从给定的训练数据集合出发，<strong>假设</strong>数据是独立同分布产生的，<strong>假设</strong>要学习的模型是某个函数集合（假设空间），有某评价准则，从假设空间挑选最优模型。</p>\n<p>其中涉及的变换空间有：输入空间、特征空间、输出空间</p>\n<p>统计学习三个要素：<strong>模型</strong>、<strong>策略</strong>、<strong>算法</strong></p>\n<p>目标：研究泛化误差界</p>\n<hr>\n<h5 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h5><ul>\n<li><p>监督学习关于数据的基本假设：输入输出的随机变量遵循联合概率分布（$P(X,Y)$）。</p>\n<p>分为概率模型和非概率模型，分别表示为条件概率分布（$P(Y|X)$）和决策函数（$Y=f(X)$）。</p>\n</li>\n<li><p>损失函数和风险函数：一次预测的好坏和平均意义下模型预测结果的好坏</p>\n</li>\n<li><p>风险函数：期望损失： 损失函数*联合概率分布的二重积分</p>\n</li>\n</ul>\n<blockquote>\n<p>由于联合概率是未知的，根据大数定律，当样本容量趋于无穷时，经验风险趋于期望风险，所以可以由经验风险来求期望风险，但是由于样本的数量有限，效果往往达不到预期。</p>\n</blockquote>\n<ul>\n<li>监督学习的两个基本策略：经验风险最小化(empiracal risk minimization)和结构风险最小化(structural risk minimization)</li>\n<li>ERM：样本容量足够大的时候能达到较好的效果，样本容量较小的时候容易产生过拟合，例：极大似然估计（模型是条件概率分布，损失函数是对数损失，经验风险最小化等价于极大似然估计）。</li>\n<li>SRM：通过正则化系数来权衡经验风险和模型复杂度，模型越复杂时，正则项越大，例：最大后验估计（模型是条件概率分布，损失函数为对数损失函数，模型复杂度由先验概率表示，结构风险最小化等价于最大后验估计）。</li>\n</ul>\n<p>贝叶斯定理中任意一个量都可以从联合概率分布得到，要么通过积分的方式，要么通过关于某个合适的变量求条件概率。</p>\n<p>频率派和贝叶斯派区别和联系：</p>\n<ul>\n<li>频率观点：通过最优化某些准则（如似然函数）来确定参数的具体值。</li>\n<li>贝叶斯观点：给定观察数据，我们引入参数的先验分布，然后使用贝叶斯定理来计算对应的后验概率。</li>\n</ul>\n<p>共轭先验：使得后验概率分布的函数形式与先验概率相同，一般称先验分布与似然函数是共轭的。</p>\n<p>关于熵：</p>\n<blockquote>\n<p>我们一般使用<strong>信息量</strong>来进行<strong>不确定性</strong>的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。</p>\n<blockquote>\n<p>对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。</p>\n</blockquote>\n<p><strong>(信息)熵</strong>定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。</p>\n<blockquote>\n<p>1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$</p>\n<p>多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$</p>\n<blockquote>\n<p>随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0&lt;H(X)&lt;log(n)$)</p>\n</blockquote>\n</blockquote>\n<p><strong>条件熵</strong>：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。</p>\n<blockquote>\n<p>$H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$</p>\n<p>$H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$</p>\n<p>$H(Y|X)=H(X,Y)-H(X)$</p>\n</blockquote>\n<p><strong>相对熵</strong>（KL散度）：两个概率分布之间的差异。</p>\n<blockquote>\n<p>$D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)</p>\n</blockquote>\n<p><strong>交叉熵</strong>：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。</p>\n<blockquote>\n<p>$H(p,q)=-\\sum_xp(x)logq(x)$</p>\n<p>$H(p,q)=H(p)+D_{KL}(p||q)$</p>\n</blockquote>\n<p>熵与方差的关系(在大部分分布的情况下正相关？)</p>\n<p><strong>信息增益</strong>：熵-条件熵</p>\n<p><strong>互信息</strong>：联合分布于乘积分布之间的相对熵，熵-条件熵</p>\n<blockquote>\n<p>$I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$</p>\n</blockquote>\n</blockquote>\n<p>过拟合和欠拟合：</p>\n<blockquote>\n<p>欠拟合指的是模型不能在训练集上获得足够低的误差，过拟合指的是训练误差和测试误差的差距太大。</p>\n<p>调整模型的<strong>容量</strong>，</p>\n<p>当算法容量适合任务的复杂度和所提供数据的数量时，算法效果最佳。</p>\n</blockquote>\n<p>VC维：</p>\n<blockquote>\n<p>量化模型（二元分类器）容量，该分类器能够分类的训练样本的最大数目。训练误差和泛化误差之间差异的上界随着模型容量的增长而增长，但是随着训练样本增多而下降。</p>\n</blockquote>\n<p>No Free Lunch theorem：</p>\n<blockquote>\n<p>在所有可能的数据生成分布上平均后，每一个分类算法在未事先观测的点上都有相同的错误率。没有一个机器学习算法总是比其他的要好。但是这个结论只在我们考虑所有的数据生成分布时才成立。真实应用中，如果我们对遇到的概率分布进行假设，则可以设计在这些分布上效果良好的学习算法。</p>\n<p>机器学习是理解什么样的分布于人工智能获取经验的“真实世界”相关，以及什么样的学习算法在我们关注的数据生成分布上效果要好。</p>\n</blockquote>\n<p>正则项：</p>\n<blockquote>\n<p>修改学习算法，使其降低泛化误差而非训练误差</p>\n</blockquote>\n<ul>\n<li>当经验风险项较小时，表示模型较复杂，包含的参数越多，正则项就会越大。</li>\n<li>正则项的作用就是选择经验风险和模型复杂度同时较小的模型。奥卡姆剃刀法则（能很好地解释已知数据并且十分简单的才是最好的模型）。</li>\n<li>从贝叶斯的角度看，正则项相当于模型的先验概率，简单的模型有较大的先验概率，复杂的模型有较小的先验概率。</li>\n<li>可以看成是一种模型选择的手段，其他模型选择方法还有：交叉验证（重复使用数据）。</li>\n</ul>\n<p>在模型中增加更多的特征一般会增加训练样本的准确率，减小bias。但是测试样本的准确率不一定增加，除非增加的特征为有效特征。</p>\n<p>生成模型和判别模型</p>\n<ul>\n<li><p>生成方法由数据学习联合概率分布，然后求出条件概率分布作为预测模型。</p>\n</li>\n<li><p>判别方法直接学习决策函数或条件概率分布。</p>\n</li>\n<li><p>生成方法可以还原出联合概率分布，学习收敛速度快，样本容量的增加时可以更快收敛于真实模型，存在隐变量时可以使用而不能使用判别模型。</p>\n</li>\n<li><p>判别模型直接面对预测，往往学习的准确率更高，可以对数据进行各种程度的抽象，定义特征，简化学习问题。</p>\n</li>\n</ul>\n<p>判别数据集是否线性可分</p>\n<ul>\n<li>低维直接画图判断，高维检查凸包是否相交。</li>\n</ul>\n<p>模型选择</p>\n<ul>\n<li>prml第一章中，多项式曲线拟合主要在于1、<strong>函数空间</strong>的选择（拟合三角函数为何用多项式函数），其中正则化方法对函数空间进行限制，使得函数空间变小。2、确定了多项式拟合后，<strong>阶数</strong>如何选择。</li>\n<li>一个模型中可能存在多个控制模型复杂度的参数。</li>\n<li>最大似然的方法容易过拟合，尤其是数据集小的时候（太小不服从大数定律？频率派的思想？）</li>\n<li>在数据量充足的情况下，一般选择在验证集上表现好的模型。但是在验证集很小的情况下对预测的表现估计会有一定的噪声。如果模型的设计使用有限规模的数据集迭代很多次，对于验证集会发生一定程度的过拟合。因此，保留一个第三方的测试集很有必要，最终使用该数据集来进行模型选择。</li>\n<li>在训练集和测试集有限的情况下，可以使用交叉验证（CV、Loocv）来充分利用数据。但是也有其缺点，交叉验证需要进行训练的次数随着折数的增加而增加，如果训练本身很耗时不太适用。对于一个模型有多个复杂度参数的情况，探索这些参数的组合所需的训练次数是参数个数的指数函数（$2^n$）。</li>\n<li>模型选择的理想情况：模型的选择依赖于训练数据，且允许在一轮训练中对比多个超参数和模型类型。</li>\n<li>信息准则：赤池信息准则（AIC【考虑模型的复杂度和模型的拟合度】）、贝叶斯信息准则（BIC）（倾向于选择过于简单的模型）。。</li>\n</ul>\n<p>泛函，指函数张成的空间。例Taylor公式，任意一个函数可以放到（$1,x,x^2,x^3…$）所张成的函数空间，如果是有限个基的话就称为欧式空间，无穷的话就是Hilbert空间。</p>\n<p>回归分析，p-value(假设检验的角度)？</p>\n<p>维度灾难</p>\n<p>（特征的数量有一个邻界点，过多带来过拟合）</p>\n<ul>\n<li><p>如果把空间的区域分割成一个一个的单元格，单元格的数量随着空间的维数以指数的形式增大。此时，为了保证这些单元格都不为空，需要指数级增长的训练数据（维度在指数级地爆炸增长）。</p>\n<blockquote>\n<p>增加维度来获得最佳线性分类效果等价于在低维空间中使用非线性模型</p>\n</blockquote>\n</li>\n<li><p>对于一个M阶多项式，系数数量的增长速度类似于D（维度）的M次方。$y(x,w)=w_0+\\sum_{i=1}^{D}w_ix_i+\\sum_{i=1}^{D}\\sum_{j=1}^{D}w_{ij}x_ix_j+\\sum_{i=1}^{D}\\sum_{j=1}^{D}\\sum_{k=1}^{D}w_{ijk}x_ix_jx_k$</p>\n</li>\n<li><p>D很大时，一个球体的大部分体积都聚集在表面附近的薄壳上（样本密度越来越小，数据的稀疏性变得愈发明显）。</p>\n</li>\n<li><p>距离度量（欧式距离）失效，最近距离和最远距离变得不可辨别</p>\n</li>\n</ul>\n<p>各种分布</p>\n<blockquote>\n<p>【随着数据量的增加，参数的后验分布等于最大似然解。在数据量足够的情况下,先验知识就显得不是那么重要了。】</p>\n</blockquote>\n<ul>\n<li><p>伯努利分布（二项分布的特例）</p>\n<p>二元随机变量$x\\in{0,1}$，概率分布：$p(x=1|\\mu)=\\mu$，$Beru(x|\\mu)=\\mu^x(1-\\mu)^{(1-x)}$，$E[x]=\\mu,var[x]=\\mu(1-\\mu)$，对于一个观测数据集$D={x_1,…,x_n}$，似然函数为：$P(D|\\mu)=\\prod_{i=1}^{N}p(x_n|\\mu)$</p>\n</li>\n<li><p>二项式分布（泊松分布是二项式分布的极限形式，二项式分布也能推出正态分布）</p>\n</li>\n<li><p>beta分布（引入先验，二项分布的共轭分布。beta分布于二项式分布的似然函数有着相同的形式，当用beta分布作为二项式分布参数的先验分布，乘似然函数后得到的后验分布依然是beta分布）</p>\n</li>\n<li><p>多项式分布–&gt;狄利克雷分布（二项-&gt;抛硬币，多项-&gt;掷骰子）</p>\n</li>\n<li><p>高斯分布</p>\n</li>\n<li><p>t分布（无限个均值一样，方差不同的高斯分布混合而成）</p>\n</li>\n<li><p>混合高斯模型（隐变量：数据点属于哪个高斯分布，EM（隐变量，模型参数））</p>\n</li>\n<li><p>指数族</p>\n</li>\n</ul>\n<hr>\n<h5 id=\"Naive贝叶斯：\"><a href=\"#Naive贝叶斯：\" class=\"headerlink\" title=\"Naive贝叶斯：\"></a>Naive贝叶斯：</h5><ul>\n<li>贝叶斯定理+特征条件独立性假设。</li>\n<li>对于给定的数据集，基于特征条件独立假设学习输入输出的联合概率分布($P(X,Y)​$)，然后基于此模型，对于给定的输入$X​$，利用贝叶斯定理求出后验概率($P(Y|X)​$)。（联合概率分布 == 先验概率($P(Y)​$)*条件概率($P(X|Y)​$)（条件独立性假设））</li>\n<li>学习到生成数据的机制，即生成模型。</li>\n<li>分类的特征在类确定的条件下都是条件独立的。</li>\n<li>后验概率最大化 == 0-1损失时的期望风险最小化。</li>\n</ul>\n<hr>\n<h5 id=\"决策树：\"><a href=\"#决策树：\" class=\"headerlink\" title=\"决策树：\"></a>决策树：</h5><p><em>互斥且完备的if-then规则集合，定义在特征空间和类空间上的条件概率分布，模型可读性强，分类速度快。学习过程是由训练数据预估条件概率模型（从训练数据中归纳出一组分类规则）。</em></p>\n<ul>\n<li>该算法主要包含三个步骤：特征选择、决策树的生成、剪枝</li>\n<li>内部结点表示一个特征或者属性，叶子节点表示一个类。</li>\n<li><strong>损失函数</strong>：正则化的极大似然函数，<strong>策略</strong>：以损失函数为目标的最小化。</li>\n</ul>\n<p><em>从所有可能的决策树中选取最优决策树是NP完全问题，所以决策树的学习通常采用启发式算法，近似求解这一最优化问题，得到一个次最优的决策树。</em></p>\n<ul>\n<li><p>过程：递归选择最优特征，根据该特征对训练数据进行分割，使得各个子数据集有一个最好的分类过程。</p>\n<p>这种方法容易过拟合，所以要注意剪枝过程。</p>\n</li>\n<li><p>如果特征的数量众多，在开始学习之前，可以对特征进行选择，留下对数据具有足够分类能力的特征。</p>\n</li>\n<li><p>树的生成只考虑局部最优，剪枝考虑全局最优。</p>\n</li>\n</ul>\n<p><strong>熵</strong>：不确定性的大小。</p>\n<ul>\n<li><p>当各个微观状态出现概率相等时，熵达到最大值。</p>\n<p>熵值依赖于X的分布，与其大小无关。</p>\n</li>\n<li><p>条件熵：X给定的条件下，条件概率分布的熵对X的数学期望。（按某一个特征分类后的和）</p>\n</li>\n<li><p>经验熵，经验条件熵：由数据估计得到的熵和条件熵。</p>\n</li>\n<li><p>信息增益：经验熵与给定特征条件下经验条件熵之差。</p>\n</li>\n</ul>\n<p><em>熵与条件熵之差称为互信息，决策树中的信息增益等价于训练集中类与特征的互信息。</em></p>\n<p><strong>特征选择</strong>：</p>\n<p>信息增益（ID3），信息增益比（C4.5）（信息增益存在偏向于选择取值较多的特征的问题，信息增益比可以对这个问题进行校正）。</p>\n<p><strong>树的生成</strong>：</p>\n<p>启发式算法，每一步最优分割。</p>\n<p><strong>剪枝</strong>：通过极小化整体的损失函数或者代价函数实现，正则项限制复杂度。</p>\n<p>分为预剪枝（一边建立一边剪枝，控制树深度、叶子节点样本数、叶子节点个数、信息增益量）和后剪枝（优化损失函数）</p>\n<p>决策树的生成只考虑了信息增益（比）对训练集更好地拟合，而剪枝考虑减小模型的复杂度，利用损失函数最小化原则进行剪枝就是用正则化的极大似然估计进行模型选择。</p>\n<p>计算每个节点的经验熵，递归地从叶子节点往上回缩，直到选得损失函数最小的子树。</p>\n<p><strong>CART</strong>：（二叉树）</p>\n<p>在给定输入随机变量X条件下输出随机变量Y的条件概率分布的学习方法。</p>\n<p><strong>生成树</strong>：</p>\n<p>递归构建二叉树，对回归树用<strong>平方误差最小化</strong>准则，分类树用<strong>基尼指数最小化</strong>准则进行特征选择，生成二叉树。</p>\n<p><strong>剪枝</strong>：</p>\n<p>从生成算法的决策树底端开始不断剪枝，直到根节点，形成一个子树序列，然后通过交叉验证在独立的验证数据集上对子树序列进行测试，选取最优子树。</p>\n<hr>\n<blockquote>\n<p>涉及到<strong>距离度量</strong>时，缺失的数据就会比较重要。</p>\n</blockquote>\n<p><strong>随机森林和XGBoost缺失值处理</strong>：</p>\n<ul>\n<li><p>随机森林：1、数值型变量用所有对应类别中的中位数替换，类别型变量用出现最多的值（众数）替换</p>\n<p>​           2、加权，相似的点拥有更高的权重          </p>\n</li>\n<li><p>XGBoost：训练时缺失数据会被分到左子树或者右子树计算损失，选择较优的那个。如果训练时没有缺失而预测时出现缺失，则默认被分到右子树。</p>\n</li>\n</ul>\n<hr>\n<p><strong>PCA</strong>：</p>\n<blockquote>\n<p>求解协方差矩阵的topK大的特征向量</p>\n</blockquote>\n<p>1、数据在低维线性空间（主子空间）上的正交投影，使得投影数据的方差最大化</p>\n<p>2、使得投影代价（数据点和它们的投影间的平方距离）最小的线性投影</p>\n<p>标准化有什么好处？</p>\n<blockquote>\n<p>防止过分捕捉某些数值大的特征，让每个维度的重要性一样。</p>\n<p>有利于梯度下降法的收敛。</p>\n</blockquote>\n<hr>\n<p><strong>Kmeans</strong>:</p>\n<blockquote>\n<p>k均值算法对应于用于高斯混合模型的EM算法的一个特定的非概率极限</p>\n<p>k-means算法是高斯混合聚类在混合成分方差相等，且每个样本仅指派一个混合成分时候的特例。 </p>\n</blockquote>\n<p>数据集${x_n}$，聚类中心${\\mu_k}$，定义一个目标函数：<br>$$<br>J=\\sum_{n=1}^{N}\\sum_{k=1}^{K}r_{nk}||x_n-\\mu_k||^2<br>$$<br>如果数据点$x_n$被分配到类别$k$，则$r_{nk}=1$</p>\n<p>目标是寻找$r_{nk}$和$\\mu_k$的值，使得$J$最小化，可以使用一种迭代的方法完成这件事，每次迭代涉及两个连续步骤，分别为$r_{nk}$的最优化和$\\mu_k$的最优化。</p>\n<ul>\n<li><p>选择$\\mu_k$的初始值</p>\n</li>\n<li><p>关于$r_{nk}$优化$J$，保持$\\mu_k$固定（E）</p>\n<p>$r_{nk}= \\begin{cases}1&amp;\\mbox{if $k=arg\\ min_j ||x_n-\\mu_j||^2$}, \\0 &amp; \\text{else}.\\end{cases}$</p>\n</li>\n<li><p>关于$\\mu_k$优化$J$，保持$r_{nk}$固定（M）</p>\n<p>$\\partial J/\\partial \\mu_k = 2\\sum_{n=1}^{N}r_{nk}(x_n-\\mu_k)=0$</p>\n<p>$\\Rightarrow \\mu_k=\\frac{\\sum_nr_{nk}x_n}{\\sum_nr_{nk}}$</p>\n</li>\n<li><p>不断重复这两个阶段直至收敛</p>\n</li>\n</ul>\n<p><strong>高斯混合模型</strong>：</p>\n<p><img src=\"/2018/08/25/ML&DL基础概念/GMM.png\" alt=\"GMM\"></p>\n<hr>\n<p><strong>线性模型</strong>：</p>\n<p>GLM建模过程：先明确y(条件概率？)服从什么分布，找到一个合适的链接函数，将参数$\\theta$映射成整条实直线，规定$f(\\theta) = a + bx$ 。<a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NTUxNTM0Mg==&amp;mid=2247487577&amp;idx=3&amp;sn=eaa836d0bf6aeb4e454a73f42f70340b&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">推导</a></p>\n<p>回归的线性模型和分类的线性模型：基于<strong>固定</strong>非线性基函数的线性组合。$y(x,w)=f(\\sum_{j=1}^{M}w_j\\phi_j(x))$,$f(.)$在分类问题中是一个非线性激活函数，在回归问题中为恒等函数。</p>\n<p>线性回归的模型可以表达非线性的东西，因为基函数是非线性的（这里基函数是固定的，NN、SVM是变化基）。</p>\n<p>多项式基函数的局限：它们是输入变量的全局函数，对于输入空间一个区域的改变将会影响所有的其他区域。</p>\n<p>对$x$做非线性变化，再对这些基函数线性组合，会使得计算量变得庞大，可以使用kernel trick，直接由核函数来计算内积，来解决非线性关系。</p>\n<p>固定基函数的线性组合构成的回归模型和分类模型，它们的实际应用被<strong>维数灾难</strong>问题限制了。为了将这些模型应用于大规模问题，有必要根据数据调节基函数。（SVM、神经网络）</p>\n<p>如何避免维度灾难问题？</p>\n<p>kernel function 满足交换律（内积满足交换律），满足Mercer定理（核矩阵是半正定的）。</p>\n<blockquote>\n<p>有一些模式识别方法，对于新输入的预测纯粹依靠学习到的参数向量$w$，也有一类方法，训练数据点或者它的一个子集在预测阶段任然保留并且被使用。如最近邻方法（memory-based，训练速度快，预测速度慢）、核函数方法（每一个核函数都以训练数据为中心）。</p>\n</blockquote>\n<p>核方法：</p>\n<p>许多线性参数模型可以被转化为一个等价的“对偶表示”，预测的基础也是在训练数据点处计算的核函数的线性组合。对于基于固定非线性特征空间映射$\\phi(x)$的模型来说，核函数关系如下：<br>$$<br>k(x,x^\\prime) = \\phi(x)^T\\phi(x^\\prime)<br>$$<br>对偶表示：完全通过核函数表示，可以直接针对核函数进行计算，<strong>避免了显式地引入特征向量</strong>$\\phi(x)$，这使得我们可以隐式地使用高维特征空间，甚至无限维特征空间。</p>\n<p>构造核：核函数对应于某个特征空间的标量积，合法核函数的充分必要条件：Gram矩阵在所有的集合${x_n}$的选择下都是半正定的。</p>\n<p>多项式核</p>\n<p>高斯核？无穷维？</p>\n<p>sigmoid核（Gram矩阵是非半正定的也可以使用）</p>\n<p>很多基于核的学习算法最大的局限是核函数必须对所有的可能点求值，这在训练阶段的计算上是不可行的。</p>\n<p>$\\Longrightarrow\\Downarrow$</p>\n<p>SVM(分类，回归，异常检测)</p>\n<p>线性可分：存在$w,b$,有$t_ny_n &gt; 0$</p>\n<p>margin：决策边界与任意样本之间的最小距离，这个决策边界的位置由数据点的一个子集确定，这些数据点称为支持向量</p>\n<p>soft margin：引入松弛变量，允许一些训练数据点被错分</p>\n<p>核函数对应于特征空间的内积，特征空间可以是高维甚至是无穷维的，通过直接对核函数操作而不显式引入特征空间，可以有效地避免维度灾难的问题。（然而。。）</p>\n<p>对新输入的预测只通过支持向量来完成，但是训练阶段使用了整个数据集，所以一个解决二次规划的高效算法很重要。</p>\n<p>SMO：</p>\n<p>多分类SVM：</p>\n<p>SVR：</p>\n<hr>\n<h3 id=\"DL\"><a href=\"#DL\" class=\"headerlink\" title=\"DL\"></a>DL</h3><h5 id=\"基本概念：\"><a href=\"#基本概念：\" class=\"headerlink\" title=\"基本概念：\"></a>基本概念：</h5><p><strong>神经网络</strong></p>\n<p>通用近似原理：一个带有线性输出的两层网络可以在任意精度下近似任何输入变量较少的连续函数，只要隐含单元的数量足够多。</p>\n<p>前馈神经网络（MLP）：使用参数形式的基函数，这些参数可以在训练阶段调节。</p>\n<p>三层网络函数：$i(D维),j(M维)[a=w^Tx,z=h(a)],k(K维)[a = w^Tz,\\sigma(a)]$<br>$$<br>y_k(x,w) = \\sigma(\\sum_{j=0}^{M}w_{kj}^{(2)}h(\\sum_{i=0}^{D}w_{ji}^{(1)}x_i)<br>$$<br>误差方向传播：提供了计算导数的一个高效方法<br>$$<br>\\delta_j = h^\\prime(a_j)\\sum_k(\\delta_kw_{kj})<br>$$<br><img src=\"/2018/08/25/ML&DL基础概念/BP.jpg\" alt=\"BP\"></p>\n<p>卷积网络：</p>\n<p>将不变性的性质融入到神经网络结构中，以构造对输入变量的变换具有不变性的模型，并能提取多个局部特征（读个feature map）</p>\n<p>特点：1、卷积（不变性，检测不同位置的相同模式） 2、权值共享（feature map） 3、下采样（微小平移不敏感）</p>\n<p><strong>梯度下降法的步骤</strong>：</p>\n<p>（梯度下降法、批量最优化方法[共轭梯度法、拟牛顿法]、随机梯度下降（高效地处理数据中的冗余性，可以逃离局部最小值点））</p>\n<p>1、随机初始化权重和偏差</p>\n<p>2、把输入传入网络得到输出值</p>\n<p>3、计算预测值与真实值之间的误差</p>\n<p>4、对每一个产生误差的神经元，调整相应的权重值以减小误差</p>\n<p>5、重复迭代，直至网络权重达到最佳值</p>\n<p><strong>跳出局部最小值的策略</strong>：</p>\n<p>1、尝试不同的参数初始化策略，再选择</p>\n<p>2、模拟退火</p>\n<blockquote>\n<p>每一步都以一定的概率接受比当前差的结果，有助于跳出局部极值，接受“次优解”的概率随着时间的推移不断降低</p>\n</blockquote>\n<p>3、使用随机梯度下降</p>\n<p>4、动量</p>\n<p><strong>各种梯度下降</strong>：</p>\n<p><strong>梯度消失爆炸</strong>：</p>\n<blockquote>\n<p>原因：1、网络过深。2、激活函数选择不合适（如sigmoid的导数不会超过0.25）</p>\n</blockquote>\n<p>解决办法：</p>\n<p>1、预训练+微调</p>\n<p>2、梯度剪切、权重正则（针对爆炸）[出现的更多的是梯度消失]</p>\n<p>3、更换激活函数</p>\n<p>4、batchnorm（消除放大缩小影响，把梯度拉回非饱和区）</p>\n<p>5、使用残差结构（shortcut）</p>\n<p>6、使用LSTM（gates）</p>\n<p><strong>各类激活函数比较</strong>：</p>\n<p>relu：</p>\n<blockquote>\n<p>缓解梯度消失爆炸、计算方便、加速网络训练</p>\n</blockquote>\n<p>leakrelu:</p>\n<p>elu:</p>\n<p><strong>BN</strong>：</p>\n","site":{"data":{}},"excerpt":"<p><strong>统计学习</strong>偏向于理论的优美完善，研究泛化误差界。<strong>机器学习</strong>是统计学习对实践技术的延伸，为实际问题提供算法支撑。<strong>数据挖掘</strong>偏重于大量数据的实践应用，注重实际问题的解决。</p>","more":"<h3 id=\"ML\"><a href=\"#ML\" class=\"headerlink\" title=\"ML\"></a>ML</h3><p><strong>WTF</strong>：从给定的训练数据集合出发，<strong>假设</strong>数据是独立同分布产生的，<strong>假设</strong>要学习的模型是某个函数集合（假设空间），有某评价准则，从假设空间挑选最优模型。</p>\n<p>其中涉及的变换空间有：输入空间、特征空间、输出空间</p>\n<p>统计学习三个要素：<strong>模型</strong>、<strong>策略</strong>、<strong>算法</strong></p>\n<p>目标：研究泛化误差界</p>\n<hr>\n<h5 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h5><ul>\n<li><p>监督学习关于数据的基本假设：输入输出的随机变量遵循联合概率分布（$P(X,Y)$）。</p>\n<p>分为概率模型和非概率模型，分别表示为条件概率分布（$P(Y|X)$）和决策函数（$Y=f(X)$）。</p>\n</li>\n<li><p>损失函数和风险函数：一次预测的好坏和平均意义下模型预测结果的好坏</p>\n</li>\n<li><p>风险函数：期望损失： 损失函数*联合概率分布的二重积分</p>\n</li>\n</ul>\n<blockquote>\n<p>由于联合概率是未知的，根据大数定律，当样本容量趋于无穷时，经验风险趋于期望风险，所以可以由经验风险来求期望风险，但是由于样本的数量有限，效果往往达不到预期。</p>\n</blockquote>\n<ul>\n<li>监督学习的两个基本策略：经验风险最小化(empiracal risk minimization)和结构风险最小化(structural risk minimization)</li>\n<li>ERM：样本容量足够大的时候能达到较好的效果，样本容量较小的时候容易产生过拟合，例：极大似然估计（模型是条件概率分布，损失函数是对数损失，经验风险最小化等价于极大似然估计）。</li>\n<li>SRM：通过正则化系数来权衡经验风险和模型复杂度，模型越复杂时，正则项越大，例：最大后验估计（模型是条件概率分布，损失函数为对数损失函数，模型复杂度由先验概率表示，结构风险最小化等价于最大后验估计）。</li>\n</ul>\n<p>贝叶斯定理中任意一个量都可以从联合概率分布得到，要么通过积分的方式，要么通过关于某个合适的变量求条件概率。</p>\n<p>频率派和贝叶斯派区别和联系：</p>\n<ul>\n<li>频率观点：通过最优化某些准则（如似然函数）来确定参数的具体值。</li>\n<li>贝叶斯观点：给定观察数据，我们引入参数的先验分布，然后使用贝叶斯定理来计算对应的后验概率。</li>\n</ul>\n<p>共轭先验：使得后验概率分布的函数形式与先验概率相同，一般称先验分布与似然函数是共轭的。</p>\n<p>关于熵：</p>\n<blockquote>\n<p>我们一般使用<strong>信息量</strong>来进行<strong>不确定性</strong>的度量。分布为$P(X)$随机变量$X$的自信息定义为：$-log(p(X))$。</p>\n<blockquote>\n<p>对于两个不相关的事件x和y，定义$I(x)$来表示时间的信息，则$I(x,y)=I(x)+I(y)$，而$P(x,y)=P(x)P(y)$。由此可知$I(x)$与$P(x)$的对数相关，则可定义$I(x)=-log(P(x))$，负数为了保证信息量为正数。</p>\n</blockquote>\n<p><strong>(信息)熵</strong>定义为信息量关于随机变量$X$概率分布的期望，也就是定义为该随机变量所有可能发生的事件产生信息量的期望。（最短平均编码长度？）。</p>\n<blockquote>\n<p>1维随机变量：$H(X)=-\\sum_xp(x)log(p(x))$</p>\n<p>多维的联合熵：$H(X,Y)=-\\sum_{x,y}p(x,y)log(p(x,y))=-\\sum_{i=1}^{n}\\sum_{j=1}^{m}p(x_i,y_i)log(p(x_i,y_i))$</p>\n<blockquote>\n<p>随机变量取值个数越多熵越大，当随机变量均匀分布时，熵最大。($0&lt;H(X)&lt;log(n)$)</p>\n</blockquote>\n</blockquote>\n<p><strong>条件熵</strong>：$X$给定条件下$Y$的条件概率分布的熵对随机变量$X$的期望，条件熵 = 联合熵 - 单独熵。</p>\n<blockquote>\n<p>$H(Y|X)=\\sum_xp(x)H(Y|X=x)=-\\sum_xp(x)\\sum_yp(y|x)logp(y|x)=-\\sum_x\\sum_yp(x,y)logp(y,x)=-\\sum_{x,y}p(x,y)logp(y|x)$</p>\n<p>$H(X,Y)=-\\sum_{x,y}p(x,y)logp(x,y)=H(Y|X)+H(X)$</p>\n<p>$H(Y|X)=H(X,Y)-H(X)$</p>\n</blockquote>\n<p><strong>相对熵</strong>（KL散度）：两个概率分布之间的差异。</p>\n<blockquote>\n<p>$D_{KL}(p||q)=\\sum_xp(x)log\\frac{p(x)}{q(x)}$(p与q之间的对数差在p上的期望值)</p>\n</blockquote>\n<p><strong>交叉熵</strong>：模型的分布与训练时分布的差异，当KL散度为0的时候，模型预测值得分布于训练集分布相同。</p>\n<blockquote>\n<p>$H(p,q)=-\\sum_xp(x)logq(x)$</p>\n<p>$H(p,q)=H(p)+D_{KL}(p||q)$</p>\n</blockquote>\n<p>熵与方差的关系(在大部分分布的情况下正相关？)</p>\n<p><strong>信息增益</strong>：熵-条件熵</p>\n<p><strong>互信息</strong>：联合分布于乘积分布之间的相对熵，熵-条件熵</p>\n<blockquote>\n<p>$I(X;Y)=\\sum_{x,y}p(x,y)log\\frac{p(x,y)}{p(x)p(y)}=H(X)-H(X|Y)$</p>\n</blockquote>\n</blockquote>\n<p>过拟合和欠拟合：</p>\n<blockquote>\n<p>欠拟合指的是模型不能在训练集上获得足够低的误差，过拟合指的是训练误差和测试误差的差距太大。</p>\n<p>调整模型的<strong>容量</strong>，</p>\n<p>当算法容量适合任务的复杂度和所提供数据的数量时，算法效果最佳。</p>\n</blockquote>\n<p>VC维：</p>\n<blockquote>\n<p>量化模型（二元分类器）容量，该分类器能够分类的训练样本的最大数目。训练误差和泛化误差之间差异的上界随着模型容量的增长而增长，但是随着训练样本增多而下降。</p>\n</blockquote>\n<p>No Free Lunch theorem：</p>\n<blockquote>\n<p>在所有可能的数据生成分布上平均后，每一个分类算法在未事先观测的点上都有相同的错误率。没有一个机器学习算法总是比其他的要好。但是这个结论只在我们考虑所有的数据生成分布时才成立。真实应用中，如果我们对遇到的概率分布进行假设，则可以设计在这些分布上效果良好的学习算法。</p>\n<p>机器学习是理解什么样的分布于人工智能获取经验的“真实世界”相关，以及什么样的学习算法在我们关注的数据生成分布上效果要好。</p>\n</blockquote>\n<p>正则项：</p>\n<blockquote>\n<p>修改学习算法，使其降低泛化误差而非训练误差</p>\n</blockquote>\n<ul>\n<li>当经验风险项较小时，表示模型较复杂，包含的参数越多，正则项就会越大。</li>\n<li>正则项的作用就是选择经验风险和模型复杂度同时较小的模型。奥卡姆剃刀法则（能很好地解释已知数据并且十分简单的才是最好的模型）。</li>\n<li>从贝叶斯的角度看，正则项相当于模型的先验概率，简单的模型有较大的先验概率，复杂的模型有较小的先验概率。</li>\n<li>可以看成是一种模型选择的手段，其他模型选择方法还有：交叉验证（重复使用数据）。</li>\n</ul>\n<p>在模型中增加更多的特征一般会增加训练样本的准确率，减小bias。但是测试样本的准确率不一定增加，除非增加的特征为有效特征。</p>\n<p>生成模型和判别模型</p>\n<ul>\n<li><p>生成方法由数据学习联合概率分布，然后求出条件概率分布作为预测模型。</p>\n</li>\n<li><p>判别方法直接学习决策函数或条件概率分布。</p>\n</li>\n<li><p>生成方法可以还原出联合概率分布，学习收敛速度快，样本容量的增加时可以更快收敛于真实模型，存在隐变量时可以使用而不能使用判别模型。</p>\n</li>\n<li><p>判别模型直接面对预测，往往学习的准确率更高，可以对数据进行各种程度的抽象，定义特征，简化学习问题。</p>\n</li>\n</ul>\n<p>判别数据集是否线性可分</p>\n<ul>\n<li>低维直接画图判断，高维检查凸包是否相交。</li>\n</ul>\n<p>模型选择</p>\n<ul>\n<li>prml第一章中，多项式曲线拟合主要在于1、<strong>函数空间</strong>的选择（拟合三角函数为何用多项式函数），其中正则化方法对函数空间进行限制，使得函数空间变小。2、确定了多项式拟合后，<strong>阶数</strong>如何选择。</li>\n<li>一个模型中可能存在多个控制模型复杂度的参数。</li>\n<li>最大似然的方法容易过拟合，尤其是数据集小的时候（太小不服从大数定律？频率派的思想？）</li>\n<li>在数据量充足的情况下，一般选择在验证集上表现好的模型。但是在验证集很小的情况下对预测的表现估计会有一定的噪声。如果模型的设计使用有限规模的数据集迭代很多次，对于验证集会发生一定程度的过拟合。因此，保留一个第三方的测试集很有必要，最终使用该数据集来进行模型选择。</li>\n<li>在训练集和测试集有限的情况下，可以使用交叉验证（CV、Loocv）来充分利用数据。但是也有其缺点，交叉验证需要进行训练的次数随着折数的增加而增加，如果训练本身很耗时不太适用。对于一个模型有多个复杂度参数的情况，探索这些参数的组合所需的训练次数是参数个数的指数函数（$2^n$）。</li>\n<li>模型选择的理想情况：模型的选择依赖于训练数据，且允许在一轮训练中对比多个超参数和模型类型。</li>\n<li>信息准则：赤池信息准则（AIC【考虑模型的复杂度和模型的拟合度】）、贝叶斯信息准则（BIC）（倾向于选择过于简单的模型）。。</li>\n</ul>\n<p>泛函，指函数张成的空间。例Taylor公式，任意一个函数可以放到（$1,x,x^2,x^3…$）所张成的函数空间，如果是有限个基的话就称为欧式空间，无穷的话就是Hilbert空间。</p>\n<p>回归分析，p-value(假设检验的角度)？</p>\n<p>维度灾难</p>\n<p>（特征的数量有一个邻界点，过多带来过拟合）</p>\n<ul>\n<li><p>如果把空间的区域分割成一个一个的单元格，单元格的数量随着空间的维数以指数的形式增大。此时，为了保证这些单元格都不为空，需要指数级增长的训练数据（维度在指数级地爆炸增长）。</p>\n<blockquote>\n<p>增加维度来获得最佳线性分类效果等价于在低维空间中使用非线性模型</p>\n</blockquote>\n</li>\n<li><p>对于一个M阶多项式，系数数量的增长速度类似于D（维度）的M次方。$y(x,w)=w_0+\\sum_{i=1}^{D}w_ix_i+\\sum_{i=1}^{D}\\sum_{j=1}^{D}w_{ij}x_ix_j+\\sum_{i=1}^{D}\\sum_{j=1}^{D}\\sum_{k=1}^{D}w_{ijk}x_ix_jx_k$</p>\n</li>\n<li><p>D很大时，一个球体的大部分体积都聚集在表面附近的薄壳上（样本密度越来越小，数据的稀疏性变得愈发明显）。</p>\n</li>\n<li><p>距离度量（欧式距离）失效，最近距离和最远距离变得不可辨别</p>\n</li>\n</ul>\n<p>各种分布</p>\n<blockquote>\n<p>【随着数据量的增加，参数的后验分布等于最大似然解。在数据量足够的情况下,先验知识就显得不是那么重要了。】</p>\n</blockquote>\n<ul>\n<li><p>伯努利分布（二项分布的特例）</p>\n<p>二元随机变量$x\\in{0,1}$，概率分布：$p(x=1|\\mu)=\\mu$，$Beru(x|\\mu)=\\mu^x(1-\\mu)^{(1-x)}$，$E[x]=\\mu,var[x]=\\mu(1-\\mu)$，对于一个观测数据集$D={x_1,…,x_n}$，似然函数为：$P(D|\\mu)=\\prod_{i=1}^{N}p(x_n|\\mu)$</p>\n</li>\n<li><p>二项式分布（泊松分布是二项式分布的极限形式，二项式分布也能推出正态分布）</p>\n</li>\n<li><p>beta分布（引入先验，二项分布的共轭分布。beta分布于二项式分布的似然函数有着相同的形式，当用beta分布作为二项式分布参数的先验分布，乘似然函数后得到的后验分布依然是beta分布）</p>\n</li>\n<li><p>多项式分布–&gt;狄利克雷分布（二项-&gt;抛硬币，多项-&gt;掷骰子）</p>\n</li>\n<li><p>高斯分布</p>\n</li>\n<li><p>t分布（无限个均值一样，方差不同的高斯分布混合而成）</p>\n</li>\n<li><p>混合高斯模型（隐变量：数据点属于哪个高斯分布，EM（隐变量，模型参数））</p>\n</li>\n<li><p>指数族</p>\n</li>\n</ul>\n<hr>\n<h5 id=\"Naive贝叶斯：\"><a href=\"#Naive贝叶斯：\" class=\"headerlink\" title=\"Naive贝叶斯：\"></a>Naive贝叶斯：</h5><ul>\n<li>贝叶斯定理+特征条件独立性假设。</li>\n<li>对于给定的数据集，基于特征条件独立假设学习输入输出的联合概率分布($P(X,Y)​$)，然后基于此模型，对于给定的输入$X​$，利用贝叶斯定理求出后验概率($P(Y|X)​$)。（联合概率分布 == 先验概率($P(Y)​$)*条件概率($P(X|Y)​$)（条件独立性假设））</li>\n<li>学习到生成数据的机制，即生成模型。</li>\n<li>分类的特征在类确定的条件下都是条件独立的。</li>\n<li>后验概率最大化 == 0-1损失时的期望风险最小化。</li>\n</ul>\n<hr>\n<h5 id=\"决策树：\"><a href=\"#决策树：\" class=\"headerlink\" title=\"决策树：\"></a>决策树：</h5><p><em>互斥且完备的if-then规则集合，定义在特征空间和类空间上的条件概率分布，模型可读性强，分类速度快。学习过程是由训练数据预估条件概率模型（从训练数据中归纳出一组分类规则）。</em></p>\n<ul>\n<li>该算法主要包含三个步骤：特征选择、决策树的生成、剪枝</li>\n<li>内部结点表示一个特征或者属性，叶子节点表示一个类。</li>\n<li><strong>损失函数</strong>：正则化的极大似然函数，<strong>策略</strong>：以损失函数为目标的最小化。</li>\n</ul>\n<p><em>从所有可能的决策树中选取最优决策树是NP完全问题，所以决策树的学习通常采用启发式算法，近似求解这一最优化问题，得到一个次最优的决策树。</em></p>\n<ul>\n<li><p>过程：递归选择最优特征，根据该特征对训练数据进行分割，使得各个子数据集有一个最好的分类过程。</p>\n<p>这种方法容易过拟合，所以要注意剪枝过程。</p>\n</li>\n<li><p>如果特征的数量众多，在开始学习之前，可以对特征进行选择，留下对数据具有足够分类能力的特征。</p>\n</li>\n<li><p>树的生成只考虑局部最优，剪枝考虑全局最优。</p>\n</li>\n</ul>\n<p><strong>熵</strong>：不确定性的大小。</p>\n<ul>\n<li><p>当各个微观状态出现概率相等时，熵达到最大值。</p>\n<p>熵值依赖于X的分布，与其大小无关。</p>\n</li>\n<li><p>条件熵：X给定的条件下，条件概率分布的熵对X的数学期望。（按某一个特征分类后的和）</p>\n</li>\n<li><p>经验熵，经验条件熵：由数据估计得到的熵和条件熵。</p>\n</li>\n<li><p>信息增益：经验熵与给定特征条件下经验条件熵之差。</p>\n</li>\n</ul>\n<p><em>熵与条件熵之差称为互信息，决策树中的信息增益等价于训练集中类与特征的互信息。</em></p>\n<p><strong>特征选择</strong>：</p>\n<p>信息增益（ID3），信息增益比（C4.5）（信息增益存在偏向于选择取值较多的特征的问题，信息增益比可以对这个问题进行校正）。</p>\n<p><strong>树的生成</strong>：</p>\n<p>启发式算法，每一步最优分割。</p>\n<p><strong>剪枝</strong>：通过极小化整体的损失函数或者代价函数实现，正则项限制复杂度。</p>\n<p>分为预剪枝（一边建立一边剪枝，控制树深度、叶子节点样本数、叶子节点个数、信息增益量）和后剪枝（优化损失函数）</p>\n<p>决策树的生成只考虑了信息增益（比）对训练集更好地拟合，而剪枝考虑减小模型的复杂度，利用损失函数最小化原则进行剪枝就是用正则化的极大似然估计进行模型选择。</p>\n<p>计算每个节点的经验熵，递归地从叶子节点往上回缩，直到选得损失函数最小的子树。</p>\n<p><strong>CART</strong>：（二叉树）</p>\n<p>在给定输入随机变量X条件下输出随机变量Y的条件概率分布的学习方法。</p>\n<p><strong>生成树</strong>：</p>\n<p>递归构建二叉树，对回归树用<strong>平方误差最小化</strong>准则，分类树用<strong>基尼指数最小化</strong>准则进行特征选择，生成二叉树。</p>\n<p><strong>剪枝</strong>：</p>\n<p>从生成算法的决策树底端开始不断剪枝，直到根节点，形成一个子树序列，然后通过交叉验证在独立的验证数据集上对子树序列进行测试，选取最优子树。</p>\n<hr>\n<blockquote>\n<p>涉及到<strong>距离度量</strong>时，缺失的数据就会比较重要。</p>\n</blockquote>\n<p><strong>随机森林和XGBoost缺失值处理</strong>：</p>\n<ul>\n<li><p>随机森林：1、数值型变量用所有对应类别中的中位数替换，类别型变量用出现最多的值（众数）替换</p>\n<p>​           2、加权，相似的点拥有更高的权重          </p>\n</li>\n<li><p>XGBoost：训练时缺失数据会被分到左子树或者右子树计算损失，选择较优的那个。如果训练时没有缺失而预测时出现缺失，则默认被分到右子树。</p>\n</li>\n</ul>\n<hr>\n<p><strong>PCA</strong>：</p>\n<blockquote>\n<p>求解协方差矩阵的topK大的特征向量</p>\n</blockquote>\n<p>1、数据在低维线性空间（主子空间）上的正交投影，使得投影数据的方差最大化</p>\n<p>2、使得投影代价（数据点和它们的投影间的平方距离）最小的线性投影</p>\n<p>标准化有什么好处？</p>\n<blockquote>\n<p>防止过分捕捉某些数值大的特征，让每个维度的重要性一样。</p>\n<p>有利于梯度下降法的收敛。</p>\n</blockquote>\n<hr>\n<p><strong>Kmeans</strong>:</p>\n<blockquote>\n<p>k均值算法对应于用于高斯混合模型的EM算法的一个特定的非概率极限</p>\n<p>k-means算法是高斯混合聚类在混合成分方差相等，且每个样本仅指派一个混合成分时候的特例。 </p>\n</blockquote>\n<p>数据集${x_n}$，聚类中心${\\mu_k}$，定义一个目标函数：<br>$$<br>J=\\sum_{n=1}^{N}\\sum_{k=1}^{K}r_{nk}||x_n-\\mu_k||^2<br>$$<br>如果数据点$x_n$被分配到类别$k$，则$r_{nk}=1$</p>\n<p>目标是寻找$r_{nk}$和$\\mu_k$的值，使得$J$最小化，可以使用一种迭代的方法完成这件事，每次迭代涉及两个连续步骤，分别为$r_{nk}$的最优化和$\\mu_k$的最优化。</p>\n<ul>\n<li><p>选择$\\mu_k$的初始值</p>\n</li>\n<li><p>关于$r_{nk}$优化$J$，保持$\\mu_k$固定（E）</p>\n<p>$r_{nk}= \\begin{cases}1&amp;\\mbox{if $k=arg\\ min_j ||x_n-\\mu_j||^2$}, \\0 &amp; \\text{else}.\\end{cases}$</p>\n</li>\n<li><p>关于$\\mu_k$优化$J$，保持$r_{nk}$固定（M）</p>\n<p>$\\partial J/\\partial \\mu_k = 2\\sum_{n=1}^{N}r_{nk}(x_n-\\mu_k)=0$</p>\n<p>$\\Rightarrow \\mu_k=\\frac{\\sum_nr_{nk}x_n}{\\sum_nr_{nk}}$</p>\n</li>\n<li><p>不断重复这两个阶段直至收敛</p>\n</li>\n</ul>\n<p><strong>高斯混合模型</strong>：</p>\n<p><img src=\"/2018/08/25/ML&DL基础概念/GMM.png\" alt=\"GMM\"></p>\n<hr>\n<p><strong>线性模型</strong>：</p>\n<p>GLM建模过程：先明确y(条件概率？)服从什么分布，找到一个合适的链接函数，将参数$\\theta$映射成整条实直线，规定$f(\\theta) = a + bx$ 。<a href=\"https://mp.weixin.qq.com/s?__biz=MzU1NTUxNTM0Mg==&amp;mid=2247487577&amp;idx=3&amp;sn=eaa836d0bf6aeb4e454a73f42f70340b&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">推导</a></p>\n<p>回归的线性模型和分类的线性模型：基于<strong>固定</strong>非线性基函数的线性组合。$y(x,w)=f(\\sum_{j=1}^{M}w_j\\phi_j(x))$,$f(.)$在分类问题中是一个非线性激活函数，在回归问题中为恒等函数。</p>\n<p>线性回归的模型可以表达非线性的东西，因为基函数是非线性的（这里基函数是固定的，NN、SVM是变化基）。</p>\n<p>多项式基函数的局限：它们是输入变量的全局函数，对于输入空间一个区域的改变将会影响所有的其他区域。</p>\n<p>对$x$做非线性变化，再对这些基函数线性组合，会使得计算量变得庞大，可以使用kernel trick，直接由核函数来计算内积，来解决非线性关系。</p>\n<p>固定基函数的线性组合构成的回归模型和分类模型，它们的实际应用被<strong>维数灾难</strong>问题限制了。为了将这些模型应用于大规模问题，有必要根据数据调节基函数。（SVM、神经网络）</p>\n<p>如何避免维度灾难问题？</p>\n<p>kernel function 满足交换律（内积满足交换律），满足Mercer定理（核矩阵是半正定的）。</p>\n<blockquote>\n<p>有一些模式识别方法，对于新输入的预测纯粹依靠学习到的参数向量$w$，也有一类方法，训练数据点或者它的一个子集在预测阶段任然保留并且被使用。如最近邻方法（memory-based，训练速度快，预测速度慢）、核函数方法（每一个核函数都以训练数据为中心）。</p>\n</blockquote>\n<p>核方法：</p>\n<p>许多线性参数模型可以被转化为一个等价的“对偶表示”，预测的基础也是在训练数据点处计算的核函数的线性组合。对于基于固定非线性特征空间映射$\\phi(x)$的模型来说，核函数关系如下：<br>$$<br>k(x,x^\\prime) = \\phi(x)^T\\phi(x^\\prime)<br>$$<br>对偶表示：完全通过核函数表示，可以直接针对核函数进行计算，<strong>避免了显式地引入特征向量</strong>$\\phi(x)$，这使得我们可以隐式地使用高维特征空间，甚至无限维特征空间。</p>\n<p>构造核：核函数对应于某个特征空间的标量积，合法核函数的充分必要条件：Gram矩阵在所有的集合${x_n}$的选择下都是半正定的。</p>\n<p>多项式核</p>\n<p>高斯核？无穷维？</p>\n<p>sigmoid核（Gram矩阵是非半正定的也可以使用）</p>\n<p>很多基于核的学习算法最大的局限是核函数必须对所有的可能点求值，这在训练阶段的计算上是不可行的。</p>\n<p>$\\Longrightarrow\\Downarrow$</p>\n<p>SVM(分类，回归，异常检测)</p>\n<p>线性可分：存在$w,b$,有$t_ny_n &gt; 0$</p>\n<p>margin：决策边界与任意样本之间的最小距离，这个决策边界的位置由数据点的一个子集确定，这些数据点称为支持向量</p>\n<p>soft margin：引入松弛变量，允许一些训练数据点被错分</p>\n<p>核函数对应于特征空间的内积，特征空间可以是高维甚至是无穷维的，通过直接对核函数操作而不显式引入特征空间，可以有效地避免维度灾难的问题。（然而。。）</p>\n<p>对新输入的预测只通过支持向量来完成，但是训练阶段使用了整个数据集，所以一个解决二次规划的高效算法很重要。</p>\n<p>SMO：</p>\n<p>多分类SVM：</p>\n<p>SVR：</p>\n<hr>\n<h3 id=\"DL\"><a href=\"#DL\" class=\"headerlink\" title=\"DL\"></a>DL</h3><h5 id=\"基本概念：\"><a href=\"#基本概念：\" class=\"headerlink\" title=\"基本概念：\"></a>基本概念：</h5><p><strong>神经网络</strong></p>\n<p>通用近似原理：一个带有线性输出的两层网络可以在任意精度下近似任何输入变量较少的连续函数，只要隐含单元的数量足够多。</p>\n<p>前馈神经网络（MLP）：使用参数形式的基函数，这些参数可以在训练阶段调节。</p>\n<p>三层网络函数：$i(D维),j(M维)[a=w^Tx,z=h(a)],k(K维)[a = w^Tz,\\sigma(a)]$<br>$$<br>y_k(x,w) = \\sigma(\\sum_{j=0}^{M}w_{kj}^{(2)}h(\\sum_{i=0}^{D}w_{ji}^{(1)}x_i)<br>$$<br>误差方向传播：提供了计算导数的一个高效方法<br>$$<br>\\delta_j = h^\\prime(a_j)\\sum_k(\\delta_kw_{kj})<br>$$<br><img src=\"/2018/08/25/ML&DL基础概念/BP.jpg\" alt=\"BP\"></p>\n<p>卷积网络：</p>\n<p>将不变性的性质融入到神经网络结构中，以构造对输入变量的变换具有不变性的模型，并能提取多个局部特征（读个feature map）</p>\n<p>特点：1、卷积（不变性，检测不同位置的相同模式） 2、权值共享（feature map） 3、下采样（微小平移不敏感）</p>\n<p><strong>梯度下降法的步骤</strong>：</p>\n<p>（梯度下降法、批量最优化方法[共轭梯度法、拟牛顿法]、随机梯度下降（高效地处理数据中的冗余性，可以逃离局部最小值点））</p>\n<p>1、随机初始化权重和偏差</p>\n<p>2、把输入传入网络得到输出值</p>\n<p>3、计算预测值与真实值之间的误差</p>\n<p>4、对每一个产生误差的神经元，调整相应的权重值以减小误差</p>\n<p>5、重复迭代，直至网络权重达到最佳值</p>\n<p><strong>跳出局部最小值的策略</strong>：</p>\n<p>1、尝试不同的参数初始化策略，再选择</p>\n<p>2、模拟退火</p>\n<blockquote>\n<p>每一步都以一定的概率接受比当前差的结果，有助于跳出局部极值，接受“次优解”的概率随着时间的推移不断降低</p>\n</blockquote>\n<p>3、使用随机梯度下降</p>\n<p>4、动量</p>\n<p><strong>各种梯度下降</strong>：</p>\n<p><strong>梯度消失爆炸</strong>：</p>\n<blockquote>\n<p>原因：1、网络过深。2、激活函数选择不合适（如sigmoid的导数不会超过0.25）</p>\n</blockquote>\n<p>解决办法：</p>\n<p>1、预训练+微调</p>\n<p>2、梯度剪切、权重正则（针对爆炸）[出现的更多的是梯度消失]</p>\n<p>3、更换激活函数</p>\n<p>4、batchnorm（消除放大缩小影响，把梯度拉回非饱和区）</p>\n<p>5、使用残差结构（shortcut）</p>\n<p>6、使用LSTM（gates）</p>\n<p><strong>各类激活函数比较</strong>：</p>\n<p>relu：</p>\n<blockquote>\n<p>缓解梯度消失爆炸、计算方便、加速网络训练</p>\n</blockquote>\n<p>leakrelu:</p>\n<p>elu:</p>\n<p><strong>BN</strong>：</p>"},{"title":"carryC","date":"2019-07-07T14:48:03.000Z","_content":"\n。。。\n\n<!--more-->\n\n```python\nimport sys\nimport os\nimport re\n\nprint(sys.argv[0])\nprint(os.getcwd())\nprint(os.path.abspath('.'))\nprint(os.path.abspath('..'))\n\ndef findtxt(path, ret):\n    \"\"\"Finding the *.txt file in specify path\"\"\"\n    filelist = os.listdir(path)\n    for filename in filelist:\n        de_path = os.path.join(path, filename)\n        if os.path.isfile(de_path):\n            if de_path.endswith(\".txt\"): #Specify to find the txt file.\n                ret.append(de_path)\n        else:\n            findtxt(de_path, ret)\n            \n\ntxt_files = []\nfindtxt(root_path,txt_files)\n\ndef get_item(files_list):\n    res = []\n    for i in range(len(files_list)):\n        file_items = []\n        with open(files_list[i]) as f:\n        #     print(f.read().split('\\n'))\n        #     print(type(f.read().split('\\n')))\n            file_items = f.read().split('\\n')\n            file_highlights = []\n            for j in range(len(file_items)):\n                file_highlights.append(file_items[j].split('.')[1])\n            res.append(file_highlights)\n    print(res)\n    return res\n\nres_func_list = get_item(txt_files)\n```\n\n#### epoll\n\nlinuxIO多路复用的管理机制\n\n- 支持一个进程打开大数目的socket描述符\n- IO效率不随着FD数目增加而线性下降\n- 使用mmap加速内核与用户空间的消息传递\n- 内核微调\n\n工作方式LT/ET\n\nblock和no-block socket\n\n使用：\n\n```c\n#include <sys/epoll.h>\nkdpfd = create_epoll(int maxfds);//close()\nnfds = epoll_wait(kdpfd, events, maxevents, -1);\nfor( ; ; )\n    {\n        nfds = epoll_wait(epfd,events,20,500);\n        for(i=0;i<nfds;++i)\n        {\n            if(events[i].data.fd==listenfd) //有新的连接；我们可以注册多个FD,如果内核发现事件，就会载入events，如果有我们要的描述符也就是listenfd，说明某某套接字监听描述符所对应的事件发生了变化。每次最多监测20个fd数。\n            {\n                connfd = accept(listenfd,(sockaddr *)&clientaddr, &clilen); //accept这个连接\n                ev.data.fd=connfd;\n                ev.events=EPOLLIN|EPOLLET;//LT\n                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&ev); //将新的fd添加到epoll的监听队列中\n            }\n            else if( events[i].events&EPOLLIN ) //接收到数据，读socket,数据可读标志EPOLLIN\n            {\n                n = read(sockfd, line, MAXLINE)) < 0    //读\n                ev.data.ptr = md;     //md为自定义类型，添加数据\n                ev.events=EPOLLOUT|EPOLLET;\n                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓\n            }\n            else if(events[i].events&EPOLLOUT) //有数据待发送，写socket\n            {\n                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    //取数据\n                sockfd = md->fd;\n                send( sockfd, md->ptr, strlen((char*)md->ptr), 0 );        //发送数据\n                ev.data.fd=sockfd;\n                ev.events=EPOLLIN|EPOLLET;\n                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev); //修改标识符，等待下一个循环时接收数据\n            }\n            else\n            {\n                //其他的处理\n            }\n        }\n    }\n```\n\nUDP：（UserDatagramProtocol）\n\n无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多\n\nTCP：\n\n面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接\n\n**超时重传机制**和**数据应答机制**保证可靠传输\n\nRTT-RoundTripTime\n\nWindowSize\n\nMSS-maximun segment size\n\nACK\n\nFLOW-control：\n\n​\t滑动窗口：加快传输效率，避免每一次发送数据都要等待接收端确认再发送下一个数据，而是在等待确认的过程中继续发送数据，在窗口大小内都是可以接受的。\n\nCongestion-Control：\n\n​\t慢开始，避免拥塞\n\n​\t快重传，快恢复\n\n回调函数：\n\n```c\n//定义主函数，回调函数作为参数\nfunction A(callback) {\n    callback();  \n    console.log('我是主函数');      \n}\n\n//定义回调函数\nfunction B(){\n    setTimeout(\"console.log('我是回调函数')\", 3000);//模仿耗时操作  \n}\n\n//调用主函数，将函数B传进去\nA(B);\n```\n\nQUIC协议：\n\n0-RTT握手过程：\n\n​\t通信双方发起通信连接时，第一个数据包就可以携带有效业务数据。\n\n​\tDH算法\n\n重传与恢复\n\n安全性\n\n\n\nobservatory：utils.update_repository","source":"_posts/carryC.md","raw":"---\ntitle: carryC\ndate: 2019-07-07 22:48:03\ntags: [notes,...]\n---\n\n。。。\n\n<!--more-->\n\n```python\nimport sys\nimport os\nimport re\n\nprint(sys.argv[0])\nprint(os.getcwd())\nprint(os.path.abspath('.'))\nprint(os.path.abspath('..'))\n\ndef findtxt(path, ret):\n    \"\"\"Finding the *.txt file in specify path\"\"\"\n    filelist = os.listdir(path)\n    for filename in filelist:\n        de_path = os.path.join(path, filename)\n        if os.path.isfile(de_path):\n            if de_path.endswith(\".txt\"): #Specify to find the txt file.\n                ret.append(de_path)\n        else:\n            findtxt(de_path, ret)\n            \n\ntxt_files = []\nfindtxt(root_path,txt_files)\n\ndef get_item(files_list):\n    res = []\n    for i in range(len(files_list)):\n        file_items = []\n        with open(files_list[i]) as f:\n        #     print(f.read().split('\\n'))\n        #     print(type(f.read().split('\\n')))\n            file_items = f.read().split('\\n')\n            file_highlights = []\n            for j in range(len(file_items)):\n                file_highlights.append(file_items[j].split('.')[1])\n            res.append(file_highlights)\n    print(res)\n    return res\n\nres_func_list = get_item(txt_files)\n```\n\n#### epoll\n\nlinuxIO多路复用的管理机制\n\n- 支持一个进程打开大数目的socket描述符\n- IO效率不随着FD数目增加而线性下降\n- 使用mmap加速内核与用户空间的消息传递\n- 内核微调\n\n工作方式LT/ET\n\nblock和no-block socket\n\n使用：\n\n```c\n#include <sys/epoll.h>\nkdpfd = create_epoll(int maxfds);//close()\nnfds = epoll_wait(kdpfd, events, maxevents, -1);\nfor( ; ; )\n    {\n        nfds = epoll_wait(epfd,events,20,500);\n        for(i=0;i<nfds;++i)\n        {\n            if(events[i].data.fd==listenfd) //有新的连接；我们可以注册多个FD,如果内核发现事件，就会载入events，如果有我们要的描述符也就是listenfd，说明某某套接字监听描述符所对应的事件发生了变化。每次最多监测20个fd数。\n            {\n                connfd = accept(listenfd,(sockaddr *)&clientaddr, &clilen); //accept这个连接\n                ev.data.fd=connfd;\n                ev.events=EPOLLIN|EPOLLET;//LT\n                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&ev); //将新的fd添加到epoll的监听队列中\n            }\n            else if( events[i].events&EPOLLIN ) //接收到数据，读socket,数据可读标志EPOLLIN\n            {\n                n = read(sockfd, line, MAXLINE)) < 0    //读\n                ev.data.ptr = md;     //md为自定义类型，添加数据\n                ev.events=EPOLLOUT|EPOLLET;\n                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓\n            }\n            else if(events[i].events&EPOLLOUT) //有数据待发送，写socket\n            {\n                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    //取数据\n                sockfd = md->fd;\n                send( sockfd, md->ptr, strlen((char*)md->ptr), 0 );        //发送数据\n                ev.data.fd=sockfd;\n                ev.events=EPOLLIN|EPOLLET;\n                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev); //修改标识符，等待下一个循环时接收数据\n            }\n            else\n            {\n                //其他的处理\n            }\n        }\n    }\n```\n\nUDP：（UserDatagramProtocol）\n\n无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多\n\nTCP：\n\n面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接\n\n**超时重传机制**和**数据应答机制**保证可靠传输\n\nRTT-RoundTripTime\n\nWindowSize\n\nMSS-maximun segment size\n\nACK\n\nFLOW-control：\n\n​\t滑动窗口：加快传输效率，避免每一次发送数据都要等待接收端确认再发送下一个数据，而是在等待确认的过程中继续发送数据，在窗口大小内都是可以接受的。\n\nCongestion-Control：\n\n​\t慢开始，避免拥塞\n\n​\t快重传，快恢复\n\n回调函数：\n\n```c\n//定义主函数，回调函数作为参数\nfunction A(callback) {\n    callback();  \n    console.log('我是主函数');      \n}\n\n//定义回调函数\nfunction B(){\n    setTimeout(\"console.log('我是回调函数')\", 3000);//模仿耗时操作  \n}\n\n//调用主函数，将函数B传进去\nA(B);\n```\n\nQUIC协议：\n\n0-RTT握手过程：\n\n​\t通信双方发起通信连接时，第一个数据包就可以携带有效业务数据。\n\n​\tDH算法\n\n重传与恢复\n\n安全性\n\n\n\nobservatory：utils.update_repository","slug":"carryC","published":1,"updated":"2019-07-16T15:29:11.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjz73d2rz0016qsezxsgjihn0","content":"<p>。。。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">print(sys.argv[<span class=\"number\">0</span>])</span><br><span class=\"line\">print(os.getcwd())</span><br><span class=\"line\">print(os.path.abspath(<span class=\"string\">'.'</span>))</span><br><span class=\"line\">print(os.path.abspath(<span class=\"string\">'..'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findtxt</span><span class=\"params\">(path, ret)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Finding the *.txt file in specify path\"\"\"</span></span><br><span class=\"line\">    filelist = os.listdir(path)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> filelist:</span><br><span class=\"line\">        de_path = os.path.join(path, filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.isfile(de_path):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> de_path.endswith(<span class=\"string\">\".txt\"</span>): <span class=\"comment\">#Specify to find the txt file.</span></span><br><span class=\"line\">                ret.append(de_path)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            findtxt(de_path, ret)</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">txt_files = []</span><br><span class=\"line\">findtxt(root_path,txt_files)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_item</span><span class=\"params\">(files_list)</span>:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(files_list)):</span><br><span class=\"line\">        file_items = []</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(files_list[i]) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        <span class=\"comment\">#     print(f.read().split('\\n'))</span></span><br><span class=\"line\">        <span class=\"comment\">#     print(type(f.read().split('\\n')))</span></span><br><span class=\"line\">            file_items = f.read().split(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            file_highlights = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(file_items)):</span><br><span class=\"line\">                file_highlights.append(file_items[j].split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>])</span><br><span class=\"line\">            res.append(file_highlights)</span><br><span class=\"line\">    print(res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">res_func_list = get_item(txt_files)</span><br></pre></td></tr></table></figure>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>linuxIO多路复用的管理机制</p>\n<ul>\n<li>支持一个进程打开大数目的socket描述符</li>\n<li>IO效率不随着FD数目增加而线性下降</li>\n<li>使用mmap加速内核与用户空间的消息传递</li>\n<li>内核微调</li>\n</ul>\n<p>工作方式LT/ET</p>\n<p>block和no-block socket</p>\n<p>使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\">kdpfd = create_epoll(<span class=\"keyword\">int</span> maxfds);<span class=\"comment\">//close()</span></span><br><span class=\"line\">nfds = epoll_wait(kdpfd, events, maxevents, <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>( ; ; )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nfds = epoll_wait(epfd,events,<span class=\"number\">20</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;nfds;++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(events[i].data.fd==listenfd) <span class=\"comment\">//有新的连接；我们可以注册多个FD,如果内核发现事件，就会载入events，如果有我们要的描述符也就是listenfd，说明某某套接字监听描述符所对应的事件发生了变化。每次最多监测20个fd数。</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class=\"comment\">//accept这个连接</span></span><br><span class=\"line\">                ev.data.fd=connfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;<span class=\"comment\">//LT</span></span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class=\"comment\">//将新的fd添加到epoll的监听队列中</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( events[i].events&amp;EPOLLIN ) <span class=\"comment\">//接收到数据，读socket,数据可读标志EPOLLIN</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n = read(sockfd, line, MAXLINE)) &lt; <span class=\"number\">0</span>    <span class=\"comment\">//读</span></span><br><span class=\"line\">                ev.data.ptr = md;     <span class=\"comment\">//md为自定义类型，添加数据</span></span><br><span class=\"line\">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class=\"comment\">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(events[i].events&amp;EPOLLOUT) <span class=\"comment\">//有数据待发送，写socket</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class=\"comment\">//取数据</span></span><br><span class=\"line\">                sockfd = md-&gt;fd;</span><br><span class=\"line\">                send( sockfd, md-&gt;ptr, <span class=\"built_in\">strlen</span>((<span class=\"keyword\">char</span>*)md-&gt;ptr), <span class=\"number\">0</span> );        <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">                ev.data.fd=sockfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class=\"comment\">//修改标识符，等待下一个循环时接收数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//其他的处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>UDP：（UserDatagramProtocol）</p>\n<p>无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多</p>\n<p>TCP：</p>\n<p>面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接</p>\n<p><strong>超时重传机制</strong>和<strong>数据应答机制</strong>保证可靠传输</p>\n<p>RTT-RoundTripTime</p>\n<p>WindowSize</p>\n<p>MSS-maximun segment size</p>\n<p>ACK</p>\n<p>FLOW-control：</p>\n<p>​    滑动窗口：加快传输效率，避免每一次发送数据都要等待接收端确认再发送下一个数据，而是在等待确认的过程中继续发送数据，在窗口大小内都是可以接受的。</p>\n<p>Congestion-Control：</p>\n<p>​    慢开始，避免拥塞</p>\n<p>​    快重传，快恢复</p>\n<p>回调函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义主函数，回调函数作为参数</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">A</span><span class=\"params\">(callback)</span> </span>&#123;</span><br><span class=\"line\">    callback();  </span><br><span class=\"line\">    console.log('我是主函数');      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义回调函数</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">B</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"string\">\"console.log('我是回调函数')\"</span>, <span class=\"number\">3000</span>);<span class=\"comment\">//模仿耗时操作  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用主函数，将函数B传进去</span></span><br><span class=\"line\">A(B);</span><br></pre></td></tr></table></figure>\n<p>QUIC协议：</p>\n<p>0-RTT握手过程：</p>\n<p>​    通信双方发起通信连接时，第一个数据包就可以携带有效业务数据。</p>\n<p>​    DH算法</p>\n<p>重传与恢复</p>\n<p>安全性</p>\n<p>observatory：utils.update_repository</p>\n","site":{"data":{}},"excerpt":"<p>。。。</p>","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">print(sys.argv[<span class=\"number\">0</span>])</span><br><span class=\"line\">print(os.getcwd())</span><br><span class=\"line\">print(os.path.abspath(<span class=\"string\">'.'</span>))</span><br><span class=\"line\">print(os.path.abspath(<span class=\"string\">'..'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findtxt</span><span class=\"params\">(path, ret)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Finding the *.txt file in specify path\"\"\"</span></span><br><span class=\"line\">    filelist = os.listdir(path)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> filelist:</span><br><span class=\"line\">        de_path = os.path.join(path, filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.isfile(de_path):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> de_path.endswith(<span class=\"string\">\".txt\"</span>): <span class=\"comment\">#Specify to find the txt file.</span></span><br><span class=\"line\">                ret.append(de_path)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            findtxt(de_path, ret)</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">txt_files = []</span><br><span class=\"line\">findtxt(root_path,txt_files)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_item</span><span class=\"params\">(files_list)</span>:</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(files_list)):</span><br><span class=\"line\">        file_items = []</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(files_list[i]) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        <span class=\"comment\">#     print(f.read().split('\\n'))</span></span><br><span class=\"line\">        <span class=\"comment\">#     print(type(f.read().split('\\n')))</span></span><br><span class=\"line\">            file_items = f.read().split(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            file_highlights = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(file_items)):</span><br><span class=\"line\">                file_highlights.append(file_items[j].split(<span class=\"string\">'.'</span>)[<span class=\"number\">1</span>])</span><br><span class=\"line\">            res.append(file_highlights)</span><br><span class=\"line\">    print(res)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">res_func_list = get_item(txt_files)</span><br></pre></td></tr></table></figure>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>linuxIO多路复用的管理机制</p>\n<ul>\n<li>支持一个进程打开大数目的socket描述符</li>\n<li>IO效率不随着FD数目增加而线性下降</li>\n<li>使用mmap加速内核与用户空间的消息传递</li>\n<li>内核微调</li>\n</ul>\n<p>工作方式LT/ET</p>\n<p>block和no-block socket</p>\n<p>使用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\">kdpfd = create_epoll(<span class=\"keyword\">int</span> maxfds);<span class=\"comment\">//close()</span></span><br><span class=\"line\">nfds = epoll_wait(kdpfd, events, maxevents, <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>( ; ; )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nfds = epoll_wait(epfd,events,<span class=\"number\">20</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;nfds;++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(events[i].data.fd==listenfd) <span class=\"comment\">//有新的连接；我们可以注册多个FD,如果内核发现事件，就会载入events，如果有我们要的描述符也就是listenfd，说明某某套接字监听描述符所对应的事件发生了变化。每次最多监测20个fd数。</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class=\"comment\">//accept这个连接</span></span><br><span class=\"line\">                ev.data.fd=connfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;<span class=\"comment\">//LT</span></span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class=\"comment\">//将新的fd添加到epoll的监听队列中</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( events[i].events&amp;EPOLLIN ) <span class=\"comment\">//接收到数据，读socket,数据可读标志EPOLLIN</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n = read(sockfd, line, MAXLINE)) &lt; <span class=\"number\">0</span>    <span class=\"comment\">//读</span></span><br><span class=\"line\">                ev.data.ptr = md;     <span class=\"comment\">//md为自定义类型，添加数据</span></span><br><span class=\"line\">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class=\"comment\">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(events[i].events&amp;EPOLLOUT) <span class=\"comment\">//有数据待发送，写socket</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class=\"comment\">//取数据</span></span><br><span class=\"line\">                sockfd = md-&gt;fd;</span><br><span class=\"line\">                send( sockfd, md-&gt;ptr, <span class=\"built_in\">strlen</span>((<span class=\"keyword\">char</span>*)md-&gt;ptr), <span class=\"number\">0</span> );        <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">                ev.data.fd=sockfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class=\"comment\">//修改标识符，等待下一个循环时接收数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//其他的处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>UDP：（UserDatagramProtocol）</p>\n<p>无连接、面向事务简单不可靠、速度快、适合传输量小的场景、资源消耗少、面向数据报、可以一对多</p>\n<p>TCP：</p>\n<p>面向连接、可靠、传输数据量大、速度较慢、面向字节流、点对点连接</p>\n<p><strong>超时重传机制</strong>和<strong>数据应答机制</strong>保证可靠传输</p>\n<p>RTT-RoundTripTime</p>\n<p>WindowSize</p>\n<p>MSS-maximun segment size</p>\n<p>ACK</p>\n<p>FLOW-control：</p>\n<p>​    滑动窗口：加快传输效率，避免每一次发送数据都要等待接收端确认再发送下一个数据，而是在等待确认的过程中继续发送数据，在窗口大小内都是可以接受的。</p>\n<p>Congestion-Control：</p>\n<p>​    慢开始，避免拥塞</p>\n<p>​    快重传，快恢复</p>\n<p>回调函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义主函数，回调函数作为参数</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">A</span><span class=\"params\">(callback)</span> </span>&#123;</span><br><span class=\"line\">    callback();  </span><br><span class=\"line\">    console.log('我是主函数');      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义回调函数</span></span><br><span class=\"line\"><span class=\"function\">function <span class=\"title\">B</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"string\">\"console.log('我是回调函数')\"</span>, <span class=\"number\">3000</span>);<span class=\"comment\">//模仿耗时操作  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用主函数，将函数B传进去</span></span><br><span class=\"line\">A(B);</span><br></pre></td></tr></table></figure>\n<p>QUIC协议：</p>\n<p>0-RTT握手过程：</p>\n<p>​    通信双方发起通信连接时，第一个数据包就可以携带有效业务数据。</p>\n<p>​    DH算法</p>\n<p>重传与恢复</p>\n<p>安全性</p>\n<p>observatory：utils.update_repository</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjz73d2q70000qseztvnrbvw2","tag_id":"cjz73d2qd0001qsez7ic0otac","_id":"cjz73d2qf0003qsezhkd3sf9p"},{"post_id":"cjz73d2q70000qseztvnrbvw2","tag_id":"cjz73d2qf0002qsezjruprq4c","_id":"cjz73d2qf0004qsezque2ukga"},{"post_id":"cjz73d2qt0005qsez3myv2eau","tag_id":"cjz73d2qd0001qsez7ic0otac","_id":"cjz73d2r0000aqsezmz0c20vu"},{"post_id":"cjz73d2qt0005qsez3myv2eau","tag_id":"cjz73d2qx0008qsezyfkvfua6","_id":"cjz73d2r1000bqsezhvrj3sby"},{"post_id":"cjz73d2qv0007qsez0zmjgokw","tag_id":"cjz73d2qd0001qsez7ic0otac","_id":"cjz73d2r2000dqsez9o8imuuu"},{"post_id":"cjz73d2qv0007qsez0zmjgokw","tag_id":"cjz73d2qz0009qsezsa3vk2cj","_id":"cjz73d2r2000eqsezrywbombg"},{"post_id":"cjz73d2qv0007qsez0zmjgokw","tag_id":"cjz73d2r1000cqsez9taz6mbo","_id":"cjz73d2r2000fqsezk2n9avmi"},{"post_id":"cjz73d2rb000hqsezlczibg2u","tag_id":"cjz73d2qd0001qsez7ic0otac","_id":"cjz73d2rg000mqsezlf0fg03v"},{"post_id":"cjz73d2rb000hqsezlczibg2u","tag_id":"cjz73d2rd000jqsez1vx9k4vh","_id":"cjz73d2ri000nqsezz6wm1hua"},{"post_id":"cjz73d2rc000iqsez8mjplmlg","tag_id":"cjz73d2rg000lqsez929ki4i8","_id":"cjz73d2rl000sqsezjwr68zj8"},{"post_id":"cjz73d2rc000iqsez8mjplmlg","tag_id":"cjz73d2ri000oqseze53ngatl","_id":"cjz73d2rl000tqsez99lhgebl"},{"post_id":"cjz73d2rc000iqsez8mjplmlg","tag_id":"cjz73d2ri000pqsez1bqaxuq2","_id":"cjz73d2rm000vqsez0kwprwq7"},{"post_id":"cjz73d2rc000iqsez8mjplmlg","tag_id":"cjz73d2rj000qqsezgtsthqec","_id":"cjz73d2rm000wqsezqmzuvnua"},{"post_id":"cjz73d2re000kqsezpbg0ufsg","tag_id":"cjz73d2rg000lqsez929ki4i8","_id":"cjz73d2rn000zqsezzxcfa028"},{"post_id":"cjz73d2re000kqsezpbg0ufsg","tag_id":"cjz73d2ri000oqseze53ngatl","_id":"cjz73d2rn0010qsezxx0ekhng"},{"post_id":"cjz73d2re000kqsezpbg0ufsg","tag_id":"cjz73d2rm000xqsezfxidl547","_id":"cjz73d2rn0011qsezflovpq1j"},{"post_id":"cjz73d2re000kqsezpbg0ufsg","tag_id":"cjz73d2rm000yqsezoeykxmwm","_id":"cjz73d2rn0012qsezoumswn8y"},{"post_id":"cjz73d2rz0016qsezxsgjihn0","tag_id":"cjz73d2qd0001qsez7ic0otac","_id":"cjz73d2s20017qsez0xai2ecf"},{"post_id":"cjz73d2rz0016qsezxsgjihn0","tag_id":"cjz73d2qx0008qsezyfkvfua6","_id":"cjz73d2s30019qsezu92ud95p"},{"post_id":"cjz73d2rv0013qsezfdj950h5","tag_id":"cjz73d2rg000lqsez929ki4i8","_id":"cjz73d2s3001aqsez796qlryi"},{"post_id":"cjz73d2rv0013qsezfdj950h5","tag_id":"cjz73d2ri000oqseze53ngatl","_id":"cjz73d2s4001cqsezmlmct1ga"},{"post_id":"cjz73d2rv0013qsezfdj950h5","tag_id":"cjz73d2ri000pqsez1bqaxuq2","_id":"cjz73d2s4001dqsez4igya0hr"},{"post_id":"cjz73d2rv0013qsezfdj950h5","tag_id":"cjz73d2rz0015qsezlq4h8nbw","_id":"cjz73d2s5001fqseznqrrd0ld"},{"post_id":"cjz73d2rx0014qsez0eavj9py","tag_id":"cjz73d2qd0001qsez7ic0otac","_id":"cjz73d2s5001gqsezgggvy3n4"},{"post_id":"cjz73d2rx0014qsez0eavj9py","tag_id":"cjz73d2s20018qsezpt8ybad6","_id":"cjz73d2s6001hqsezfjli2cpq"},{"post_id":"cjz73d2rx0014qsez0eavj9py","tag_id":"cjz73d2s3001bqsezql0h063l","_id":"cjz73d2s6001iqsez4t7imor3"},{"post_id":"cjz73d2rx0014qsez0eavj9py","tag_id":"cjz73d2s5001eqsezmfeng6pw","_id":"cjz73d2s6001jqsez6maxz6l8"}],"Tag":[{"name":"notes","_id":"cjz73d2qd0001qsez7ic0otac"},{"name":"大数据","_id":"cjz73d2qf0002qsezjruprq4c"},{"name":"...","_id":"cjz73d2qx0008qsezyfkvfua6"},{"name":"Github Pages","_id":"cjz73d2qz0009qsezsa3vk2cj"},{"name":"Hexo","_id":"cjz73d2r1000cqsez9taz6mbo"},{"name":"面试总结","_id":"cjz73d2rd000jqsez1vx9k4vh"},{"name":"coding","_id":"cjz73d2rg000lqsez929ki4i8"},{"name":"Java","_id":"cjz73d2ri000oqseze53ngatl"},{"name":"Python","_id":"cjz73d2ri000pqsez1bqaxuq2"},{"name":"排序算法","_id":"cjz73d2rj000qqsezgtsthqec"},{"name":"SQL","_id":"cjz73d2rm000xqsezfxidl547"},{"name":"Shell","_id":"cjz73d2rm000yqsezoeykxmwm"},{"name":"语言基础知识","_id":"cjz73d2rz0015qsezlq4h8nbw"},{"name":"DataScience","_id":"cjz73d2s20018qsezpt8ybad6"},{"name":"MachineLearning","_id":"cjz73d2s3001bqsezql0h063l"},{"name":"DeepLearning","_id":"cjz73d2s5001eqsezmfeng6pw"}]}}